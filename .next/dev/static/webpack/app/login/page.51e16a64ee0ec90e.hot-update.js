"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./lib/services/api.ts":
/*!*****************************!*\
  !*** ./lib/services/api.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiBaseUrl: () => (/* binding */ apiBaseUrl),\n/* harmony export */   apiClient: () => (/* binding */ apiClient),\n/* harmony export */   apiVersion: () => (/* binding */ apiVersion)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n/**\n * API Service Layer\n *\n * Centralized API communication service that handles:\n * - Base URL configuration from environment variables\n * - Authentication headers (X-User-Id, X-User-Roles)\n * - Request/response interceptors\n * - Error handling\n *\n * Usage:\n * import { apiClient } from '@/lib/services/api'\n * const properties = await apiClient.properties.getAll()\n *\n * Environment Variables (in .env.local):\n * - NEXT_PUBLIC_API_BASE_URL: Backend API base URL (e.g., http://localhost:8080)\n * - NEXT_PUBLIC_API_VERSION: API version path (default: v1)\n */ // Configuration from environment variables\n// Use API Gateway (port 8090) as the single entry point for all services\n// If GATEWAY_URL is not set, fall back to individual service URLs for backward compatibility\nconst GATEWAY_URL = process.env.NEXT_PUBLIC_GATEWAY_URL || \"http://localhost:8090\";\nconst USE_GATEWAY = process.env.NEXT_PUBLIC_USE_GATEWAY !== \"false\" // Default to true\n;\n// Fallback URLs for individual services (used if USE_GATEWAY is false)\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || \"http://localhost:8082\";\nconst PROPERTY_API_BASE_URL = process.env.NEXT_PUBLIC_PROPERTY_API_BASE_URL || \"http://localhost:8081\";\nconst BOOKING_API_BASE_URL = USE_GATEWAY ? GATEWAY_URL : process.env.NEXT_PUBLIC_BOOKING_API_BASE_URL || \"http://localhost:8083\";\nconst PAYMENT_API_BASE_URL = USE_GATEWAY ? GATEWAY_URL : process.env.NEXT_PUBLIC_PAYMENT_API_BASE_URL || \"http://localhost:8085\";\nconst RECLAMATION_API_BASE_URL = process.env.NEXT_PUBLIC_RECLAMATION_API_BASE_URL || \"http://localhost:8091\";\nconst API_VERSION = process.env.NEXT_PUBLIC_API_VERSION || \"v1\";\nconst AUTH_TOKEN_KEY = process.env.NEXT_PUBLIC_AUTH_STORAGE_KEY || \"derent5_auth_token\";\nconst USER_DATA_KEY = process.env.NEXT_PUBLIC_USER_STORAGE_KEY || \"derent5_user_data\";\n// USE_MOCK_API is true if explicitly set to \"true\", otherwise false (use real API)\nconst USE_MOCK_API = false // process.env.NEXT_PUBLIC_USE_MOCK_API === \"true\"\n;\n// Only import mock API if needed (tree-shake when not used)\n// Only import mock API if needed (tree-shake when not used)\nlet mockApiClient = null;\nasync function getMockApi() {\n    if (!mockApiClient) {\n        throw new Error(\"Mock API has been removed\");\n    }\n    return mockApiClient;\n}\n/**\n * Decode JWT token to extract userId from subject\n */ function decodeJWT(token) {\n    try {\n        // JWT format: header.payload.signature\n        const parts = token.split(\".\");\n        if (parts.length !== 3) return null;\n        // Decode payload (base64url)\n        const payload = parts[1];\n        const decoded = JSON.parse(atob(payload.replace(/-/g, \"+\").replace(/_/g, \"/\")));\n        return {\n            userId: decoded.sub || decoded.subject,\n            roles: decoded.roles || []\n        };\n    } catch (error) {\n        return null;\n    }\n}\n/**\n * Get authentication headers from localStorage\n * Used for all API requests that require user context\n */ function getAuthHeaders() {\n    // Only run in browser\n    if (false) {}\n    const token = localStorage.getItem(AUTH_TOKEN_KEY);\n    if (!token) {\n        return {};\n    }\n    // Try to get userId from JWT token first\n    const decoded = decodeJWT(token);\n    const userId = decoded?.userId;\n    // Fallback to user data from localStorage\n    const userData = localStorage.getItem(USER_DATA_KEY);\n    let finalUserId = userId;\n    let roles = decoded?.roles || [];\n    if (userData) {\n        try {\n            const user = JSON.parse(userData);\n            finalUserId = finalUserId || user.id || \"\";\n            roles = roles.length > 0 ? roles : user.roles || [];\n        } catch (error) {\n        // Failed to parse user data\n        }\n    }\n    // Ensure userId is always a string (convert number to string if needed)\n    const userIdString = finalUserId ? String(finalUserId) : \"\";\n    const headers = {\n        \"X-User-Id\": userIdString,\n        \"X-User-Roles\": roles.join(\",\"),\n        ...token && {\n            Authorization: `Bearer ${token}`\n        }\n    };\n    return headers;\n}\n/**\n * Helper function to get the correct base URL for a service\n * Uses Gateway if enabled, otherwise falls back to individual service URLs\n */ function getServiceUrl(service) {\n    if (USE_GATEWAY) {\n        // All services go through the Gateway\n        return GATEWAY_URL;\n    }\n    // Fallback to individual service URLs\n    switch(service){\n        case 'auth':\n        case 'users':\n            return API_BASE_URL;\n        case 'properties':\n            return PROPERTY_API_BASE_URL;\n        case 'bookings':\n            return BOOKING_API_BASE_URL;\n        case 'payments':\n            return PAYMENT_API_BASE_URL;\n        case 'reclamations':\n        case 'admin-reclamations':\n            return RECLAMATION_API_BASE_URL;\n        default:\n            return API_BASE_URL;\n    }\n}\n/**\n * Build full URL with base and version\n * For Gateway, path already includes /api/v1/..., so we don't add it again\n */ function buildUrl(path, service = 'users') {\n    const baseUrl = getServiceUrl(service);\n    if (USE_GATEWAY) {\n        // Gateway routes preserve the full path\n        // Path should already include /api/v1/... or /api/... prefix\n        // If path doesn't start with /api, add the appropriate prefix based on service\n        if (path.startsWith('/api/')) {\n            return `${baseUrl}${path}`;\n        }\n        // Add appropriate prefix based on service\n        if (service === 'auth' || service === 'users') {\n            return `${baseUrl}/api/v1${path}`;\n        } else if (service === 'properties') {\n            return `${baseUrl}/api/v1${path}`;\n        } else if (service === 'bookings') {\n            return `${baseUrl}/api${path}`;\n        } else if (service === 'payments') {\n            return `${baseUrl}/api${path}`;\n        } else if (service === 'reclamations' || service === 'admin-reclamations') {\n            return `${baseUrl}/api${path}`;\n        }\n        return `${baseUrl}${path}`;\n    }\n    // For direct service calls, add version prefix\n    const basePath = `/api/${API_VERSION}`;\n    return `${baseUrl}${basePath}${path}`;\n}\n/**\n * Generic fetch wrapper with error handling\n */ async function request(path, options = {}) {\n    const { requiresAuth = true, service = 'users', ...fetchOptions } = options;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        ...requiresAuth && getAuthHeaders(),\n        ...fetchOptions.headers\n    };\n    const url = buildUrl(path, service);\n    try {\n        const response = await fetch(url, {\n            ...fetchOptions,\n            headers\n        });\n        if (!response.ok) {\n            let errorData = {};\n            let responseText = \"\";\n            try {\n                responseText = await response.text();\n                if (responseText) {\n                    try {\n                        errorData = JSON.parse(responseText);\n                    } catch (parseError) {\n                        // If JSON parsing fails, use the raw text\n                        errorData = {\n                            message: responseText,\n                            raw: responseText\n                        };\n                    }\n                }\n            } catch (textError) {\n                errorData = {\n                    message: `Failed to read response: ${textError}`\n                };\n            }\n            // If errorData is still empty, create a default error\n            if (Object.keys(errorData).length === 0) {\n                errorData = {\n                    message: `HTTP ${response.status}: ${response.statusText}`,\n                    status: response.status,\n                    statusText: response.statusText\n                };\n            }\n            // Extract error message from ErrorResponse format (used by user-service)\n            // ErrorResponse has: timestamp, status, error, message, path\n            const errorMessage = errorData.message || // ErrorResponse.message\n            errorData.error || // ErrorResponse.error (error title)\n            errorData.detail || // Standard Spring error format\n            errorData.raw || // Raw response text if JSON parsing failed\n            (Array.isArray(errorData.errors) ? errorData.errors.join(\", \") : null) || // Validation errors array\n            (typeof errorData === 'string' ? errorData : null) || `API Error: ${response.status} ${response.statusText}`;\n            const apiError = new Error(errorMessage);\n            apiError.status = response.status;\n            apiError.errorData = errorData;\n            apiError.responseText = responseText;\n            throw apiError;\n        }\n        // Check if response has content\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.includes(\"application/json\")) {\n            const data = await response.json();\n            return data;\n        } else {\n            // If no JSON content, return empty object for successful responses\n            const text = await response.text();\n            if (text) {\n                // Try to parse as JSON, if fails return text as message\n                try {\n                    return JSON.parse(text);\n                } catch  {\n                    return {\n                        message: text\n                    };\n                }\n            }\n            return {};\n        }\n    } catch (error) {\n        // Check if it's a connection error\n        if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n            const connectionError = new Error(`Cannot connect to backend server at ${API_BASE_URL}. Please make sure the backend is running.`);\n            connectionError.isConnectionError = true;\n            throw connectionError;\n        }\n        throw error;\n    }\n}\n/**\n * Multipart form data request for file uploads\n */ async function requestFormData(path, formData, options = {}) {\n    const { requiresAuth = true, service = 'users', ...fetchOptions } = options;\n    const headers = {\n        ...requiresAuth && getAuthHeaders(),\n        ...fetchOptions.headers\n    };\n    // Don't set Content-Type for FormData - browser will set it with boundary\n    delete headers[\"Content-Type\"];\n    const url = buildUrl(path, service);\n    try {\n        const response = await fetch(url, {\n            method: \"POST\",\n            ...fetchOptions,\n            headers,\n            body: formData\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(errorData.message || `API Error: ${response.status}`);\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        throw error;\n    }\n}\n/**\n * API Client - Organized by resource\n */ const apiClient = {\n    // ==================== PROPERTIES ====================\n    properties: {\n        async getAll () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getAll();\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async getAllForAdmin () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getAll();\n            }\n            // Use Gateway or property-service URL for admin endpoint\n            const url = buildUrl(\"/properties/admin/all\", 'properties');\n            const authHeaders = getAuthHeaders();\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...authHeaders\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    const errorMessage = errorData.error || errorData.message || `API Error: ${response.status}`;\n                    throw new Error(errorMessage);\n                }\n                const data = await response.json();\n                // Ensure data is an array\n                if (!Array.isArray(data)) {\n                    // If it's an error object, throw it\n                    if (data.error || data.message) {\n                        throw new Error(data.error || data.message || \"Invalid response format\");\n                    }\n                    // Otherwise return empty array\n                    return [];\n                }\n                return data;\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async getById (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getById(id);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async getMyProperties () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getAll();\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/my-properties`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    const errorMessage = errorData.error || errorData.message || `API Error: ${response.status}`;\n                    throw new Error(errorMessage);\n                }\n                const data = await response.json();\n                // Ensure data is an array\n                if (!Array.isArray(data)) {\n                    // If it's an error object, throw it\n                    if (data.error || data.message) {\n                        throw new Error(data.error || data.message || \"Invalid response format\");\n                    }\n                    // Otherwise return empty array\n                    return [];\n                }\n                return data;\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async create (data, images) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                const result = await mock.properties.create(data, images);\n                return {\n                    propertyId: result.id,\n                    id: result.id\n                };\n            }\n            const formData = new FormData();\n            // Create a Blob with JSON content type for the input part\n            // Spring's @RequestPart expects Content-Type: application/json for JSON parts\n            const inputBlob = new Blob([\n                JSON.stringify(data)\n            ], {\n                type: \"application/json\"\n            });\n            formData.append(\"input\", inputBlob);\n            images.forEach((file)=>{\n                formData.append(\"images\", file);\n            });\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties`;\n            const headers = {\n                ...getAuthHeaders()\n            };\n            // Don't set Content-Type header - let browser set it with boundary for multipart/form-data\n            try {\n                const response = await fetch(url, {\n                    method: \"POST\",\n                    headers,\n                    body: formData\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                const result = await response.json();\n                return result;\n            } catch (error) {\n                throw error;\n            }\n        },\n        async update (id, data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.update(id, data);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PUT\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify(data)\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                // Backend returns \"Property updated\" as plain text, not JSON\n                const responseText = await response.text();\n                try {\n                    const parsed = JSON.parse(responseText);\n                    return parsed;\n                } catch  {\n                    // If it's not JSON, return success object\n                    return {\n                        success: true\n                    };\n                }\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async delete (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.delete(id);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"DELETE\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async approve (id, isApproved) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.approve(id, isApproved);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/approve`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify({\n                        isApproved\n                    })\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        /**\n     * Hide property\n     */ async hide (id, isHidden) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return {\n                    success: true\n                };\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/hide`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify({\n                        isHidden\n                    })\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async suspend (id, reason) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.suspend(id, reason);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/suspend`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify({\n                        reason\n                    })\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async revokeSuspension (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.suspend(id, \"\") // Mock\n                ;\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/revoke-suspension`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async submitForApproval (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.approve(id, true);\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/submit-for-approval`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async cancelApprovalRequest (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return {\n                    success: true\n                };\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/cancel-approval-request`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        /**\n     * Get AI-powered price suggestion for a property and date range.\n     * This calls property-service, which forwards the request to the pricing model API.\n     */ async predictPrice (propertyId, checkInDate, checkOutDate) {\n            if (USE_MOCK_API) {\n                // Lightweight mock for UI development\n                return {\n                    predictedPriceMad: 430,\n                    predictedPriceUsd: 43,\n                    confidenceIntervalLower: 380,\n                    confidenceIntervalUpper: 480,\n                    city: \"casablanca\",\n                    season: \"summer\",\n                    modelVersion: \"1.0\",\n                    predictionTimestamp: new Date().toISOString(),\n                    currentPriceMad: 400,\n                    priceDifferencePercent: 7.5,\n                    recommendation: \"INCREASE\"\n                };\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${propertyId}/predict-price`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    propertyId,\n                    checkInDate,\n                    checkOutDate\n                })\n            });\n            const data = await response.json().catch(()=>({}));\n            if (!response.ok) {\n                const message = data?.message || data?.error || (typeof data === \"string\" ? data : null) || `Failed to get price suggestion: ${response.status}`;\n                throw new Error(message);\n            }\n            return data;\n        }\n    },\n    // ==================== TENANT RISK ====================\n    risk: {\n        getTenantRiskScore: async (tenantId)=>{\n            try {\n                // Use local Next.js proxy\n                const response = await fetch(`/api/tenant-risk/${tenantId}`, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    }\n                });\n                if (!response.ok) {\n                    throw new Error(`ML API Error: ${response.status} ${response.statusText}`);\n                }\n                return response.json();\n            } catch (error) {\n                console.error(\"Error fetching risk score:\", error);\n                throw error;\n            }\n        }\n    },\n    recommendations: {\n        getForTenant: async (tenantId, maxResults = 3)=>{\n            try {\n                const response = await fetch(`/api/recommendations/tenant/${tenantId}?max_results=${maxResults}`);\n                if (!response.ok) throw new Error(\"Failed to fetch recommendations\");\n                return response.json();\n            } catch (error) {\n                console.error(\"Error fetching recommendations:\", error);\n                throw error;\n            }\n        },\n        getSimilar: async (propertyId, maxResults = 3)=>{\n            try {\n                const response = await fetch(`/api/recommendations/similar/${propertyId}?max_results=${maxResults}`);\n                if (!response.ok) throw new Error(\"Failed to fetch similar properties\");\n                return response.json();\n            } catch (error) {\n                console.error(\"Error fetching similar properties:\", error);\n                throw error;\n            }\n        }\n    },\n    // ==================== VERIFICATION REQUESTS ====================\n    verificationRequests: {\n        async getAll () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.getAll();\n            }\n            return request(\"/verification-requests\");\n        },\n        async getByStatus (status) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.getByStatus(status);\n            }\n            return request(`/verification-requests/by-status/${status}`);\n        },\n        async create (propertyId, description) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.create(propertyId, description);\n            }\n            return request(\"/verification-requests\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    propertyId,\n                    description\n                })\n            });\n        },\n        async approve (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.approve(id);\n            }\n            return request(`/verification-requests/${id}/approve`, {\n                method: \"PATCH\"\n            });\n        },\n        async reject (id, reason) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.reject(id, reason);\n            }\n            return request(`/verification-requests/${id}/reject`, {\n                method: \"PATCH\",\n                body: JSON.stringify({\n                    reason\n                })\n            });\n        }\n    },\n    // ==================== PROPERTY TYPES ====================\n    propertyTypes: {\n        async getAll () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.propertyTypes.getAll();\n            }\n            return request(\"/property-types\", {\n                requiresAuth: false\n            });\n        },\n        async getById (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.propertyTypes.getById(id);\n            }\n            return request(`/property-types/${id}`, {\n                requiresAuth: false\n            });\n        }\n    },\n    // ==================== USERS ====================\n    users: {\n        async getMe () {\n            if (USE_MOCK_API) {\n                // Mock user data for development\n                return {\n                    firstName: \"Mock\",\n                    lastName: \"User\",\n                    email: \"mock@example.com\"\n                };\n            }\n            return request(\"/users/me\", {\n                method: \"GET\",\n                requiresAuth: true\n            });\n        },\n        /**\n     * Get user information by ID (for getting phone number, etc.)\n     */ async getById (userId) {\n            if (USE_MOCK_API) {\n                return {\n                    firstName: \"Mock\",\n                    lastName: \"User\",\n                    email: \"mock@example.com\",\n                    phoneNumber: 1234567890,\n                    score: 100\n                };\n            }\n            // Try to get from admin endpoint first (if user is admin) for more details\n            try {\n                const allUsers = await this.getAllForAdmin();\n                const user = allUsers.find((u)=>String(u.id) === String(userId));\n                if (user) {\n                    return {\n                        firstName: user.firstName,\n                        lastName: user.lastName,\n                        email: user.email,\n                        profilePicture: user.profilePicture,\n                        birthday: user.birthday,\n                        phoneNumber: user.phoneNumber,\n                        walletAddress: user.walletAddress,\n                        roles: user.roles,\n                        score: user.score,\n                        enabled: user.enabled\n                    };\n                }\n            } catch (err) {\n            // If admin endpoint fails, fallback to regular endpoint\n            }\n            // Fallback to regular endpoint\n            return request(`/users/${userId}`, {\n                method: \"GET\",\n                requiresAuth: true\n            });\n        },\n        async updateMe (data) {\n            if (USE_MOCK_API) {\n                // Mock update\n                return Promise.resolve();\n            }\n            return request(\"/users/me\", {\n                method: \"PUT\",\n                body: JSON.stringify(data),\n                requiresAuth: true\n            });\n        },\n        async updateProfilePicture (file) {\n            if (USE_MOCK_API) {\n                return {\n                    url: \"/placeholder-user.jpg\"\n                };\n            }\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            const headers = getAuthHeaders();\n            // Remove Content-Type header to let browser set it with boundary for multipart/form-data\n            delete headers[\"Content-Type\"];\n            const url = buildUrl(\"/users/me/profile-picture\");\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers,\n                body: formData\n            });\n            if (!response.ok) {\n                let errorData = {};\n                let responseText = \"\";\n                try {\n                    responseText = await response.text();\n                    if (responseText) {\n                        try {\n                            errorData = JSON.parse(responseText);\n                        } catch  {\n                            errorData = {\n                                message: responseText,\n                                raw: responseText\n                            };\n                        }\n                    }\n                } catch  {\n                    errorData = {\n                        message: `HTTP ${response.status}: ${response.statusText}`\n                    };\n                }\n                const errorMessage = errorData.message || errorData.error || errorData.raw || `API Error: ${response.status} ${response.statusText}`;\n                const apiError = new Error(errorMessage);\n                apiError.status = response.status;\n                apiError.errorData = errorData;\n                throw apiError;\n            }\n            const text = await response.text();\n            return {\n                url: text\n            } // Backend returns URL as plain text\n            ;\n        },\n        async changePassword (currentPassword, newPassword) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Password changed successfully\"\n                };\n            }\n            return request(\"/users/me/change-password\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    currentPassword,\n                    newPassword\n                })\n            });\n        },\n        async deleteProfilePicture () {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(\"/users/me/profile-picture\", {\n                method: \"DELETE\",\n                requiresAuth: true\n            });\n        },\n        async becomeHost () {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(\"/users/me/become-host\", {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async getAllForAdmin () {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            return request(\"/users/admin/all\", {\n                method: \"GET\",\n                requiresAuth: true\n            });\n        },\n        async enableUser (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/enable`, {\n                method: \"POST\",\n                body: JSON.stringify({}),\n                requiresAuth: true\n            });\n        },\n        async disableUser (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/disable`, {\n                method: \"POST\",\n                body: JSON.stringify({}),\n                requiresAuth: true\n            });\n        },\n        async addAdminRole (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/add-admin-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async removeAdminRole (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/remove-admin-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async addHostRoleByAdmin (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/add-host-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async removeHostRole (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/remove-host-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        }\n    },\n    // ==================== AUTHENTICATION ====================\n    auth: {\n        async register (data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                // Mock registration - simulate delay\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"User registered successfully\"\n                };\n            }\n            try {\n                const requestBody = {\n                    firstName: data.firstName,\n                    lastName: data.lastName,\n                    email: data.email,\n                    password: data.password,\n                    birthday: data.birthday,\n                    phoneNumber: data.phoneNumber,\n                    ...data.role && {\n                        role: data.role\n                    }\n                };\n                return await request(\"/auth/register\", {\n                    method: \"POST\",\n                    body: JSON.stringify(requestBody),\n                    requiresAuth: false\n                });\n            } catch (error) {\n                // If connection fails, throw with helpful message\n                if (error?.isConnectionError) {\n                    throw new Error(\"Backend server is not available. Please make sure the user-service is running on port 8080.\");\n                }\n                throw error;\n            }\n        },\n        async login (email, password) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                // Mock login - would use mock data\n                throw new Error(\"Mock login not implemented - use useAuth hook\");\n            }\n            return request(\"/auth/login\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    password\n                }),\n                requiresAuth: false\n            });\n        },\n        setAuth (token, user) {\n            if (true) {\n                localStorage.setItem(AUTH_TOKEN_KEY, token);\n                localStorage.setItem(USER_DATA_KEY, JSON.stringify(user));\n            }\n        },\n        getToken () {\n            if (false) {}\n            return localStorage.getItem(AUTH_TOKEN_KEY);\n        },\n        getUser () {\n            if (false) {}\n            const userData = localStorage.getItem(USER_DATA_KEY);\n            return userData ? JSON.parse(userData) : null;\n        },\n        clearAuth () {\n            if (true) {\n                localStorage.removeItem(AUTH_TOKEN_KEY);\n                localStorage.removeItem(USER_DATA_KEY);\n            }\n        },\n        hasRole (role) {\n            const user = this.getUser();\n            return user?.roles.includes(role) ?? false;\n        },\n        async verify (email, verificationCode) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"User verified successfully\"\n                };\n            }\n            return request(\"/auth/verify\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    verificationCode\n                }),\n                requiresAuth: false\n            });\n        },\n        async resendVerificationCode (email) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"Verification Code resent successfully\"\n                };\n            }\n            return request(`/auth/resend?email=${encodeURIComponent(email)}`, {\n                method: \"POST\",\n                requiresAuth: false\n            });\n        },\n        async forgotPassword (email) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return;\n            }\n            return request(\"/auth/forgot-password\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email\n                }),\n                requiresAuth: false\n            });\n        },\n        async verifyResetToken (token) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    valid: true\n                };\n            }\n            return request(\"/auth/verify-reset-token\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    token\n                }),\n                requiresAuth: false\n            });\n        },\n        async resetPassword (token, password) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return;\n            }\n            return request(\"/auth/reset-password\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    token,\n                    password\n                }),\n                requiresAuth: false\n            });\n        },\n        async verifyResetCode (email, code) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    valid: true\n                };\n            }\n            return request(\"/auth/verify-reset-code\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    code\n                }),\n                requiresAuth: false\n            });\n        },\n        async resetPasswordWithCode (email, code, newPassword) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"Password reset successfully\"\n                };\n            }\n            return request(\"/auth/reset-password-with-code\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    code,\n                    newPassword\n                }),\n                requiresAuth: false\n            });\n        }\n    },\n    bookings: {\n        /**\n     * Get all bookings for admin\n     */ async getAllForAdmin () {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/admin/all`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `Failed to fetch bookings: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n                    const connectionError = new Error(`Cannot connect to booking-service backend at ${BOOKING_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        /**\n     * Create a booking request\n     * Sends booking data to booking-service via RabbitMQ\n     */ async create (data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.create?.(data) || {\n                    status: \"accepted\",\n                    message: \"Booking request sent\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/request`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    userId: typeof data.userId === \"string\" ? parseInt(data.userId) : data.userId,\n                    propertyId: data.propertyId,\n                    checkInDate: data.checkInDate,\n                    checkOutDate: data.checkOutDate,\n                    numberOfGuests: data.numberOfGuests,\n                    requestedPrice: data.requestedPrice\n                })\n            });\n            const responseData = await response.json();\n            if (!response.ok) {\n                // If status is \"rejected\", return the response data instead of throwing\n                if (responseData.status === \"rejected\") {\n                    return responseData;\n                }\n                throw new Error(responseData.message || `Failed to create booking: ${response.status}`);\n            }\n            return responseData;\n        },\n        /**\n     * Get booking by ID\n     */ async getById (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.getById?.(id) || null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                if (response.status === 404) {\n                    return null;\n                }\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch booking: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get bookings by tenant ID\n     */ async getByTenantId (tenantId) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.getByTenantId?.(tenantId) || [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings?tenantId=${tenantId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get current booking for a user\n     */ async getCurrentBooking (userId) {\n            if (USE_MOCK_API) {\n                // Mock: return null for now (no current booking)\n                return null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/current?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (response.status === 204 || response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch current booking: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get pending bookings (negotiations) for a user\n     */ async getPendingBookings (userId) {\n            if (USE_MOCK_API) {\n                // Mock: return empty array\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/pending?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch pending bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get awaiting payment bookings for a user\n     */ async getAwaitingPaymentBookings (userId) {\n            if (USE_MOCK_API) {\n                // Mock: return empty array\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/payment?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch awaiting payment bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get property info for booking (price, discount, negotiation)\n     */ async getPropertyInfo (propertyId) {\n            if (USE_MOCK_API) {\n                // Mock property info\n                return {\n                    id: propertyId,\n                    ownerId: 1,\n                    pricePerNight: 100,\n                    isNegotiable: false,\n                    discountEnabled: false\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/property/${propertyId}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to booking-service backend at ${BOOKING_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        /**\n     * Get last booking ID (for polling after creation)\n     */ async getLastBookingId () {\n            if (USE_MOCK_API) {\n                return {\n                    bookingId: 1\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/booking-id`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n            if (response.status === 204 || response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                return null;\n            }\n            return response.json();\n        },\n        /**\n     * Update a booking\n     */ async update (id, data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.update?.(id, data) || null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    checkInDate: data.checkInDate,\n                    checkOutDate: data.checkOutDate,\n                    numberOfGuests: data.numberOfGuests,\n                    requestedPrice: data.requestedPrice\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                const errorMessage = errorData.message || errorData.error || `Failed to update booking: ${response.status}`;\n                const error = new Error(errorMessage);\n                error.status = response.status;\n                error.errorCode = errorData.error;\n                throw error;\n            }\n            const result = await response.json();\n            return result;\n        },\n        /**\n     * Delete/Cancel a booking (by tenant)\n     */ async delete (id, userId) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.delete?.(id, userId);\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"DELETE\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to cancel booking: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Tenant checkout (changes status to TENANT_CHECKED_OUT)\n     */ async tenantCheckout (id, tenantId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Tenant checked out successfully\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}/checkout/tenant?userId=${tenantId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to checkout: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Owner confirm checkout (changes status to COMPLETED)\n     */ async ownerConfirmCheckout (id, ownerId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Checkout confirmed successfully\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}/checkout/owner?userId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to confirm checkout: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * @deprecated Use tenantCheckout() or ownerConfirmCheckout() instead\n     */ async markAsCheckedOut (id, userId) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.markAsCheckedOut?.(id, userId) || null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}/checkout?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to mark as checked out: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get current bookings by owner (host)\n     */ async getCurrentBookingsByOwner (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/current/owner?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch current bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get pending negotiations by owner (host)\n     */ async getPendingNegotiations (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/negotiations?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch pending negotiations: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Accept negotiation (host)\n     */ async acceptNegotiation (bookingId, ownerId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Negotiation accepted\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${bookingId}/accept?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to accept negotiation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Reject negotiation (host)\n     */ async rejectNegotiation (bookingId, ownerId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Negotiation rejected\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${bookingId}/reject?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to reject negotiation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get all bookings by owner (host)\n     */ async getByOwnerId (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get confirmed bookings by owner (host)\n     */ async getConfirmedBookingsByOwner (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/confirmed/owner?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch confirmed bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get confirmed bookings by property ID\n     */ async getConfirmedBookingsByProperty (propertyId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/confirmed/property/${propertyId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch confirmed bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Report dispute (host or tenant)\n     */ async reportDispute (bookingId, userId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Dispute reported\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${bookingId}/dispute?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to report dispute: ${response.status}`);\n            }\n            return response.json();\n        }\n    },\n    /**\n   * Payment Service API\n   */ payments: {\n        /**\n     * Create payment intent\n     */ async createIntent (bookingId) {\n            if (USE_MOCK_API) {\n                return {\n                    referenceId: \"mock-ref-id\",\n                    to: \"0x1234567890123456789012345678901234567890\",\n                    value: \"1000000000000000000\",\n                    data: null,\n                    chainId: 31337,\n                    totalAmountWei: \"1000000000000000000\"\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/intent`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    bookingId\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to create payment intent: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get booking details for payment\n     */ async getBookingDetails (bookingId) {\n            if (USE_MOCK_API) {\n                return {\n                    bookingId,\n                    status: \"PENDING_PAYMENT\",\n                    totalPrice: 100.0,\n                    checkInDate: \"2025-12-01\",\n                    checkOutDate: \"2025-12-05\",\n                    propertyId: 1,\n                    propertyTitle: \"Mock Property\",\n                    propertyPrice: 20.0,\n                    ownerWalletAddress: \"0x1234567890123456789012345678901234567890\",\n                    userId: 1,\n                    currentUserId: 1,\n                    userFirstName: \"John\",\n                    userLastName: \"Doe\",\n                    userEmail: \"john@example.com\",\n                    userWalletAddress: null\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/booking/${bookingId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                let errorMessage = `Failed to fetch booking details: ${response.status}`;\n                try {\n                    const errorData = await response.json();\n                    // Backend returns { code, message } format\n                    errorMessage = errorData.message || errorData.code || errorMessage;\n                } catch (e) {\n                    // If response is not JSON, use status text\n                    errorMessage = response.statusText || errorMessage;\n                }\n                throw new Error(errorMessage);\n            }\n            return response.json();\n        },\n        /**\n     * Update wallet address\n     */ async updateWalletAddress (userId, walletAddress) {\n            if (USE_MOCK_API) {\n                return;\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/wallet-address`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    userId,\n                    walletAddress\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update wallet address: ${response.status}`);\n            }\n        },\n        /**\n     * Update transaction hash\n     */ async updateTransactionHash (bookingId, txHash) {\n            if (USE_MOCK_API) {\n                return;\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/booking/${bookingId}/tx-hash`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    txHash\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update transaction hash: ${response.status}`);\n            }\n        },\n        // Date modification removed - dates can only be changed from booking-service\n        /**\n     * Get transaction status\n     */ async getTransactionStatus (txHash) {\n            if (USE_MOCK_API) {\n                return {\n                    txHash,\n                    status: \"PENDING\",\n                    blockNumber: null,\n                    bookingId: null\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/tx/${txHash}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch transaction status: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Complete booking on blockchain (called by host when confirming checkout)\n     */ async completeBooking (bookingId) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\",\n                    message: \"Booking completed successfully on blockchain\"\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/booking/${bookingId}/complete`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                let errorData = {};\n                let errorText = \"\";\n                try {\n                    errorText = await response.text();\n                    if (errorText) {\n                        try {\n                            errorData = JSON.parse(errorText);\n                        } catch  {\n                            errorData = {\n                                message: errorText\n                            };\n                        }\n                    }\n                } catch (e) {\n                    // If response is not JSON, use status text\n                    errorData = {\n                        message: response.statusText || `Server error: ${response.status}`\n                    };\n                }\n                const errorMessage = errorData.message || errorData.error || errorText || `Failed to complete booking: ${response.status}`;\n                throw new Error(errorMessage);\n            }\n            return response.json();\n        }\n    },\n    // ==================== RECLAMATIONS ====================\n    reclamations: {\n        /**\n     * Create a reclamation for a booking\n     */ async create (bookingId, userId, complainantRole, reclamationType, title, description, images) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\",\n                    message: \"Reclamation created successfully\"\n                };\n            }\n            // Use reclamation-service directly to support images\n            const formData = new FormData();\n            formData.append(\"bookingId\", String(bookingId));\n            formData.append(\"userId\", String(userId));\n            formData.append(\"complainantRole\", complainantRole);\n            formData.append(\"reclamationType\", reclamationType);\n            if (title) formData.append(\"title\", title);\n            if (description) formData.append(\"description\", description);\n            if (images && images.length > 0) {\n                images.forEach((image)=>{\n                    formData.append(\"files\", image);\n                });\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/create`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    ...getAuthHeaders()\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to create reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get all reclamations by complainant ID (my complaints)\n     */ async getMyComplaints (userId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/my-complaints?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch complaints: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get all reclamations against a user (complaints against me)\n     */ async getComplaintsAgainstMe (userId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/against-me?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch complaints: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Upload attachments (images) for a reclamation\n     */ async uploadAttachments (reclamationId, files) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const formData = new FormData();\n            files.forEach((file)=>{\n                formData.append(\"files\", file);\n            });\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}/attachments`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    ...getAuthHeaders()\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to upload attachments: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation by booking ID and complainant ID\n     */ async getByBookingIdAndComplainant (bookingId, complainantId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/booking/${bookingId}/complainant/${complainantId}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                // 404 is expected when no reclamation exists - return null silently\n                if (response.status === 404) {\n                    return null;\n                }\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `Failed to fetch reclamation: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                // Silently handle 404 errors (no reclamation exists - this is normal)\n                if (error.message?.includes(\"404\") || error.message?.includes(\"Not Found\")) {\n                    return null;\n                }\n                throw error;\n            }\n        },\n        /**\n     * Get reclamation by ID\n     */ async getById (reclamationId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation attachments (images)\n     */ async getAttachments (reclamationId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}/attachments`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch attachments: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Delete a reclamation\n     */ async delete (reclamationId, userId) {\n            if (USE_MOCK_API) {\n                return;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"DELETE\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to delete reclamation: ${response.status}`);\n            }\n        },\n        /**\n     * Update a reclamation (title, description, images)\n     */ async update (reclamationId, userId, title, description, images) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\",\n                    message: \"Reclamation updated successfully\"\n                };\n            }\n            const formData = new FormData();\n            formData.append(\"userId\", String(userId));\n            if (title) formData.append(\"title\", title);\n            if (description) formData.append(\"description\", description);\n            if (images && images.length > 0) {\n                images.forEach((image)=>{\n                    formData.append(\"files\", image);\n                });\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    ...getAuthHeaders()\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get user phone number\n     */ async getUserPhoneNumber (userId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/user/${userId}/phone`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch phone number: ${response.status}`);\n            }\n            const data = await response.json();\n            return data.phoneNumber || null;\n        }\n    },\n    // ==================== ADMIN RECLAMATIONS ====================\n    adminReclamations: {\n        /**\n     * Get all reclamations (admin only)\n     */ async getAll () {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamations: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamations by status\n     */ async getByStatus (status) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/status/${status}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamations: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation by ID\n     */ async getById (reclamationId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Update reclamation severity\n     */ async updateSeverity (reclamationId, severity) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/severity?severity=${severity}`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update severity: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Review reclamation (move to IN_REVIEW)\n     */ async review (reclamationId) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/review`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to review reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Resolve reclamation with penalty\n     */ async resolve (reclamationId, resolutionNotes, approved) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/resolve`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    resolutionNotes,\n                    approved\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to resolve reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Reject reclamation\n     */ async reject (reclamationId, rejectionNotes) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/reject`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    rejectionNotes\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to reject reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation attachments (images)\n     */ async getAttachments (reclamationId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/attachments`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch attachments: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation statistics\n     */ async getStatistics () {\n            if (USE_MOCK_API) {\n                return {\n                    total: 0,\n                    open: 0,\n                    inReview: 0,\n                    resolved: 0,\n                    rejected: 0\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/statistics`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch statistics: ${response.status}`);\n            }\n            return response.json();\n        }\n    },\n    // ==================== MARKET TRENDS ====================\n    marketTrends: {\n        async getAllCities (periodMonths = 12) {\n            if (USE_MOCK_API) return {\n                trends: [],\n                insights: []\n            };\n            const response = await fetch(`/api/market-trends/all-cities?period_months=${periodMonths}`);\n            if (!response.ok) throw new Error(\"Failed to fetch market trends\");\n            return response.json();\n        },\n        async getCityTrends (city, periodMonths = 12) {\n            if (USE_MOCK_API) return {\n                data_points: []\n            };\n            const response = await fetch(`/api/market-trends/city/${city}?period_months=${periodMonths}`);\n            if (!response.ok) throw new Error(`Failed to fetch trends for ${city}`);\n            return response.json();\n        },\n        async getInsights (city) {\n            if (USE_MOCK_API) return [];\n            const response = await fetch(`/api/market-trends/insights/${city}`);\n            if (!response.ok) throw new Error(`Failed to fetch insights for ${city}`);\n            return response.json();\n        }\n    }\n};\nconst apiBaseUrl = API_BASE_URL;\nconst apiVersion = API_VERSION;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixFQUFFdUUsTUFBTTtZQUNsRSxJQUFJLENBQUN4RSxTQUFTRSxFQUFFLEVBQUUsTUFBTSxJQUFJM0MsTUFBTSxDQUFDLDZCQUE2QixFQUFFaUgsTUFBTTtZQUN4RSxPQUFPeEUsU0FBU3dCLElBQUk7UUFDdEI7SUFDRjtBQUNGLEVBQUM7QUFFTSxNQUFNcU4sYUFBYXpTLGFBQVk7QUFDL0IsTUFBTTBTLGFBQWFoUyxZQUFXIiwic291cmNlcyI6WyIvaG9tZS9tZWRnbS92c2MvUHJvamV0IEpFRS9kZXJlbnQtbWFpbi9saWIvc2VydmljZXMvYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQVBJIFNlcnZpY2UgTGF5ZXJcbiAqXG4gKiBDZW50cmFsaXplZCBBUEkgY29tbXVuaWNhdGlvbiBzZXJ2aWNlIHRoYXQgaGFuZGxlczpcbiAqIC0gQmFzZSBVUkwgY29uZmlndXJhdGlvbiBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogLSBBdXRoZW50aWNhdGlvbiBoZWFkZXJzIChYLVVzZXItSWQsIFgtVXNlci1Sb2xlcylcbiAqIC0gUmVxdWVzdC9yZXNwb25zZSBpbnRlcmNlcHRvcnNcbiAqIC0gRXJyb3IgaGFuZGxpbmdcbiAqXG4gKiBVc2FnZTpcbiAqIGltcG9ydCB7IGFwaUNsaWVudCB9IGZyb20gJ0AvbGliL3NlcnZpY2VzL2FwaSdcbiAqIGNvbnN0IHByb3BlcnRpZXMgPSBhd2FpdCBhcGlDbGllbnQucHJvcGVydGllcy5nZXRBbGwoKVxuICpcbiAqIEVudmlyb25tZW50IFZhcmlhYmxlcyAoaW4gLmVudi5sb2NhbCk6XG4gKiAtIE5FWFRfUFVCTElDX0FQSV9CQVNFX1VSTDogQmFja2VuZCBBUEkgYmFzZSBVUkwgKGUuZy4sIGh0dHA6Ly9sb2NhbGhvc3Q6ODA4MClcbiAqIC0gTkVYVF9QVUJMSUNfQVBJX1ZFUlNJT046IEFQSSB2ZXJzaW9uIHBhdGggKGRlZmF1bHQ6IHYxKVxuICovXG5cbmltcG9ydCB0eXBlIHtcbiAgUHJvcGVydHksXG4gIENyZWF0ZVByb3BlcnR5UmVxdWVzdCxcbiAgVXBkYXRlUHJvcGVydHlSZXF1ZXN0LFxuICBBcHByb3ZlUHJvcGVydHlSZXF1ZXN0LFxuICBQcm9wZXJ0eVR5cGUsXG4gIFVzZXIsXG4gIFZlcmlmaWNhdGlvblJlcXVlc3QsXG4gIFRlbmFudFJpc2tSZXNwb25zZSxcbn0gZnJvbSBcIkAvbGliL3R5cGVzXCJcblxuLy8gQ29uZmlndXJhdGlvbiBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlc1xuLy8gVXNlIEFQSSBHYXRld2F5IChwb3J0IDgwOTApIGFzIHRoZSBzaW5nbGUgZW50cnkgcG9pbnQgZm9yIGFsbCBzZXJ2aWNlc1xuLy8gSWYgR0FURVdBWV9VUkwgaXMgbm90IHNldCwgZmFsbCBiYWNrIHRvIGluZGl2aWR1YWwgc2VydmljZSBVUkxzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5jb25zdCBHQVRFV0FZX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dBVEVXQVlfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo4MDkwXCJcbmNvbnN0IFVTRV9HQVRFV0FZID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfVVNFX0dBVEVXQVkgIT09IFwiZmFsc2VcIiAvLyBEZWZhdWx0IHRvIHRydWVcblxuLy8gRmFsbGJhY2sgVVJMcyBmb3IgaW5kaXZpZHVhbCBzZXJ2aWNlcyAodXNlZCBpZiBVU0VfR0FURVdBWSBpcyBmYWxzZSlcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9CQVNFX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6ODA4MlwiXG5jb25zdCBQUk9QRVJUWV9BUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19QUk9QRVJUWV9BUElfQkFTRV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjgwODFcIlxuY29uc3QgQk9PS0lOR19BUElfQkFTRV9VUkwgPSBVU0VfR0FURVdBWVxuICA/IEdBVEVXQVlfVVJMXG4gIDogKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0JPT0tJTkdfQVBJX0JBU0VfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo4MDgzXCIpXG5jb25zdCBQQVlNRU5UX0FQSV9CQVNFX1VSTCA9IFVTRV9HQVRFV0FZXG4gID8gR0FURVdBWV9VUkxcbiAgOiAocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfUEFZTUVOVF9BUElfQkFTRV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjgwODVcIilcbmNvbnN0IFJFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6ODA5MVwiXG5jb25zdCBBUElfVkVSU0lPTiA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9WRVJTSU9OIHx8IFwidjFcIlxuY29uc3QgQVVUSF9UT0tFTl9LRVkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BVVRIX1NUT1JBR0VfS0VZIHx8IFwiZGVyZW50NV9hdXRoX3Rva2VuXCJcbmNvbnN0IFVTRVJfREFUQV9LRVkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19VU0VSX1NUT1JBR0VfS0VZIHx8IFwiZGVyZW50NV91c2VyX2RhdGFcIlxuLy8gVVNFX01PQ0tfQVBJIGlzIHRydWUgaWYgZXhwbGljaXRseSBzZXQgdG8gXCJ0cnVlXCIsIG90aGVyd2lzZSBmYWxzZSAodXNlIHJlYWwgQVBJKVxuY29uc3QgVVNFX01PQ0tfQVBJID0gZmFsc2UgLy8gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfVVNFX01PQ0tfQVBJID09PSBcInRydWVcIlxuXG4vLyBPbmx5IGltcG9ydCBtb2NrIEFQSSBpZiBuZWVkZWQgKHRyZWUtc2hha2Ugd2hlbiBub3QgdXNlZClcbi8vIE9ubHkgaW1wb3J0IG1vY2sgQVBJIGlmIG5lZWRlZCAodHJlZS1zaGFrZSB3aGVuIG5vdCB1c2VkKVxubGV0IG1vY2tBcGlDbGllbnQ6IGFueSA9IG51bGxcblxuYXN5bmMgZnVuY3Rpb24gZ2V0TW9ja0FwaSgpIHtcbiAgaWYgKCFtb2NrQXBpQ2xpZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTW9jayBBUEkgaGFzIGJlZW4gcmVtb3ZlZFwiKVxuICB9XG4gIHJldHVybiBtb2NrQXBpQ2xpZW50XG59XG5cbi8qKlxuICogRGVjb2RlIEpXVCB0b2tlbiB0byBleHRyYWN0IHVzZXJJZCBmcm9tIHN1YmplY3RcbiAqL1xuZnVuY3Rpb24gZGVjb2RlSldUKHRva2VuOiBzdHJpbmcpOiB7IHVzZXJJZD86IHN0cmluZzsgcm9sZXM/OiBzdHJpbmdbXSB9IHwgbnVsbCB7XG4gIHRyeSB7XG4gICAgLy8gSldUIGZvcm1hdDogaGVhZGVyLnBheWxvYWQuc2lnbmF0dXJlXG4gICAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdChcIi5cIilcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbFxuXG4gICAgLy8gRGVjb2RlIHBheWxvYWQgKGJhc2U2NHVybClcbiAgICBjb25zdCBwYXlsb2FkID0gcGFydHNbMV1cbiAgICBjb25zdCBkZWNvZGVkID0gSlNPTi5wYXJzZShhdG9iKHBheWxvYWQucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIikpKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXJJZDogZGVjb2RlZC5zdWIgfHwgZGVjb2RlZC5zdWJqZWN0LCAvLyBKV1Qgc3ViamVjdCBjb250YWlucyB1c2VySWRcbiAgICAgIHJvbGVzOiBkZWNvZGVkLnJvbGVzIHx8IFtdLFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogR2V0IGF1dGhlbnRpY2F0aW9uIGhlYWRlcnMgZnJvbSBsb2NhbFN0b3JhZ2VcbiAqIFVzZWQgZm9yIGFsbCBBUEkgcmVxdWVzdHMgdGhhdCByZXF1aXJlIHVzZXIgY29udGV4dFxuICovXG5mdW5jdGlvbiBnZXRBdXRoSGVhZGVycygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgLy8gT25seSBydW4gaW4gYnJvd3NlclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB7fVxuICB9XG5cbiAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShBVVRIX1RPS0VOX0tFWSlcbiAgaWYgKCF0b2tlbikge1xuICAgIHJldHVybiB7fVxuICB9XG5cbiAgLy8gVHJ5IHRvIGdldCB1c2VySWQgZnJvbSBKV1QgdG9rZW4gZmlyc3RcbiAgY29uc3QgZGVjb2RlZCA9IGRlY29kZUpXVCh0b2tlbilcbiAgY29uc3QgdXNlcklkID0gZGVjb2RlZD8udXNlcklkXG5cbiAgLy8gRmFsbGJhY2sgdG8gdXNlciBkYXRhIGZyb20gbG9jYWxTdG9yYWdlXG4gIGNvbnN0IHVzZXJEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oVVNFUl9EQVRBX0tFWSlcbiAgbGV0IGZpbmFsVXNlcklkID0gdXNlcklkXG4gIGxldCByb2xlczogc3RyaW5nW10gPSBkZWNvZGVkPy5yb2xlcyB8fCBbXVxuXG4gIGlmICh1c2VyRGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyID0gSlNPTi5wYXJzZSh1c2VyRGF0YSlcbiAgICAgIGZpbmFsVXNlcklkID0gZmluYWxVc2VySWQgfHwgdXNlci5pZCB8fCBcIlwiXG4gICAgICByb2xlcyA9IHJvbGVzLmxlbmd0aCA+IDAgPyByb2xlcyA6ICh1c2VyLnJvbGVzIHx8IFtdKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBGYWlsZWQgdG8gcGFyc2UgdXNlciBkYXRhXG4gICAgfVxuICB9XG5cbiAgLy8gRW5zdXJlIHVzZXJJZCBpcyBhbHdheXMgYSBzdHJpbmcgKGNvbnZlcnQgbnVtYmVyIHRvIHN0cmluZyBpZiBuZWVkZWQpXG4gIGNvbnN0IHVzZXJJZFN0cmluZyA9IGZpbmFsVXNlcklkID8gU3RyaW5nKGZpbmFsVXNlcklkKSA6IFwiXCJcblxuICBjb25zdCBoZWFkZXJzID0ge1xuICAgIFwiWC1Vc2VyLUlkXCI6IHVzZXJJZFN0cmluZyxcbiAgICBcIlgtVXNlci1Sb2xlc1wiOiByb2xlcy5qb2luKFwiLFwiKSxcbiAgICAuLi4odG9rZW4gJiYgeyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9KSxcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzXG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgY29ycmVjdCBiYXNlIFVSTCBmb3IgYSBzZXJ2aWNlXG4gKiBVc2VzIEdhdGV3YXkgaWYgZW5hYmxlZCwgb3RoZXJ3aXNlIGZhbGxzIGJhY2sgdG8gaW5kaXZpZHVhbCBzZXJ2aWNlIFVSTHNcbiAqL1xuZnVuY3Rpb24gZ2V0U2VydmljZVVybChzZXJ2aWNlOiAnYXV0aCcgfCAndXNlcnMnIHwgJ3Byb3BlcnRpZXMnIHwgJ2Jvb2tpbmdzJyB8ICdwYXltZW50cycgfCAncmVjbGFtYXRpb25zJyB8ICdhZG1pbi1yZWNsYW1hdGlvbnMnKTogc3RyaW5nIHtcbiAgaWYgKFVTRV9HQVRFV0FZKSB7XG4gICAgLy8gQWxsIHNlcnZpY2VzIGdvIHRocm91Z2ggdGhlIEdhdGV3YXlcbiAgICByZXR1cm4gR0FURVdBWV9VUkxcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIHRvIGluZGl2aWR1YWwgc2VydmljZSBVUkxzXG4gIHN3aXRjaCAoc2VydmljZSkge1xuICAgIGNhc2UgJ2F1dGgnOlxuICAgIGNhc2UgJ3VzZXJzJzpcbiAgICAgIHJldHVybiBBUElfQkFTRV9VUkxcbiAgICBjYXNlICdwcm9wZXJ0aWVzJzpcbiAgICAgIHJldHVybiBQUk9QRVJUWV9BUElfQkFTRV9VUkxcbiAgICBjYXNlICdib29raW5ncyc6XG4gICAgICByZXR1cm4gQk9PS0lOR19BUElfQkFTRV9VUkxcbiAgICBjYXNlICdwYXltZW50cyc6XG4gICAgICByZXR1cm4gUEFZTUVOVF9BUElfQkFTRV9VUkxcbiAgICBjYXNlICdyZWNsYW1hdGlvbnMnOlxuICAgIGNhc2UgJ2FkbWluLXJlY2xhbWF0aW9ucyc6XG4gICAgICByZXR1cm4gUkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBBUElfQkFTRV9VUkxcbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkIGZ1bGwgVVJMIHdpdGggYmFzZSBhbmQgdmVyc2lvblxuICogRm9yIEdhdGV3YXksIHBhdGggYWxyZWFkeSBpbmNsdWRlcyAvYXBpL3YxLy4uLiwgc28gd2UgZG9uJ3QgYWRkIGl0IGFnYWluXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVXJsKHBhdGg6IHN0cmluZywgc2VydmljZTogJ2F1dGgnIHwgJ3VzZXJzJyB8ICdwcm9wZXJ0aWVzJyB8ICdib29raW5ncycgfCAncGF5bWVudHMnIHwgJ3JlY2xhbWF0aW9ucycgfCAnYWRtaW4tcmVjbGFtYXRpb25zJyA9ICd1c2VycycpOiBzdHJpbmcge1xuICBjb25zdCBiYXNlVXJsID0gZ2V0U2VydmljZVVybChzZXJ2aWNlKVxuXG4gIGlmIChVU0VfR0FURVdBWSkge1xuICAgIC8vIEdhdGV3YXkgcm91dGVzIHByZXNlcnZlIHRoZSBmdWxsIHBhdGhcbiAgICAvLyBQYXRoIHNob3VsZCBhbHJlYWR5IGluY2x1ZGUgL2FwaS92MS8uLi4gb3IgL2FwaS8uLi4gcHJlZml4XG4gICAgLy8gSWYgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggL2FwaSwgYWRkIHRoZSBhcHByb3ByaWF0ZSBwcmVmaXggYmFzZWQgb24gc2VydmljZVxuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJy9hcGkvJykpIHtcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfSR7cGF0aH1gXG4gICAgfVxuXG4gICAgLy8gQWRkIGFwcHJvcHJpYXRlIHByZWZpeCBiYXNlZCBvbiBzZXJ2aWNlXG4gICAgaWYgKHNlcnZpY2UgPT09ICdhdXRoJyB8fCBzZXJ2aWNlID09PSAndXNlcnMnKSB7XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vYXBpL3YxJHtwYXRofWBcbiAgICB9IGVsc2UgaWYgKHNlcnZpY2UgPT09ICdwcm9wZXJ0aWVzJykge1xuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L2FwaS92MSR7cGF0aH1gXG4gICAgfSBlbHNlIGlmIChzZXJ2aWNlID09PSAnYm9va2luZ3MnKSB7XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vYXBpJHtwYXRofWBcbiAgICB9IGVsc2UgaWYgKHNlcnZpY2UgPT09ICdwYXltZW50cycpIHtcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9hcGkke3BhdGh9YFxuICAgIH0gZWxzZSBpZiAoc2VydmljZSA9PT0gJ3JlY2xhbWF0aW9ucycgfHwgc2VydmljZSA9PT0gJ2FkbWluLXJlY2xhbWF0aW9ucycpIHtcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9hcGkke3BhdGh9YFxuICAgIH1cblxuICAgIHJldHVybiBgJHtiYXNlVXJsfSR7cGF0aH1gXG4gIH1cblxuICAvLyBGb3IgZGlyZWN0IHNlcnZpY2UgY2FsbHMsIGFkZCB2ZXJzaW9uIHByZWZpeFxuICBjb25zdCBiYXNlUGF0aCA9IGAvYXBpLyR7QVBJX1ZFUlNJT059YFxuICByZXR1cm4gYCR7YmFzZVVybH0ke2Jhc2VQYXRofSR7cGF0aH1gXG59XG5cbi8qKlxuICogR2VuZXJpYyBmZXRjaCB3cmFwcGVyIHdpdGggZXJyb3IgaGFuZGxpbmdcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdDxUPihcbiAgcGF0aDogc3RyaW5nLFxuICBvcHRpb25zOiBSZXF1ZXN0SW5pdCAmIHsgcmVxdWlyZXNBdXRoPzogYm9vbGVhbjsgc2VydmljZT86ICdhdXRoJyB8ICd1c2VycycgfCAncHJvcGVydGllcycgfCAnYm9va2luZ3MnIHwgJ3BheW1lbnRzJyB8ICdyZWNsYW1hdGlvbnMnIHwgJ2FkbWluLXJlY2xhbWF0aW9ucycgfSA9IHt9XG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgeyByZXF1aXJlc0F1dGggPSB0cnVlLCBzZXJ2aWNlID0gJ3VzZXJzJywgLi4uZmV0Y2hPcHRpb25zIH0gPSBvcHRpb25zXG5cbiAgY29uc3QgaGVhZGVyczogSGVhZGVyc0luaXQgPSB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgLi4uKHJlcXVpcmVzQXV0aCAmJiBnZXRBdXRoSGVhZGVycygpKSxcbiAgICAuLi5mZXRjaE9wdGlvbnMuaGVhZGVycyxcbiAgfVxuXG4gIGNvbnN0IHVybCA9IGJ1aWxkVXJsKHBhdGgsIHNlcnZpY2UpXG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgLi4uZmV0Y2hPcHRpb25zLFxuICAgICAgaGVhZGVycyxcbiAgICB9KVxuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgbGV0IGVycm9yRGF0YTogYW55ID0ge31cbiAgICAgIGxldCByZXNwb25zZVRleHQgPSBcIlwiXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgICBpZiAocmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVycm9yRGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KVxuICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElmIEpTT04gcGFyc2luZyBmYWlscywgdXNlIHRoZSByYXcgdGV4dFxuICAgICAgICAgICAgZXJyb3JEYXRhID0geyBtZXNzYWdlOiByZXNwb25zZVRleHQsIHJhdzogcmVzcG9uc2VUZXh0IH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHRleHRFcnJvcikge1xuICAgICAgICBlcnJvckRhdGEgPSB7IG1lc3NhZ2U6IGBGYWlsZWQgdG8gcmVhZCByZXNwb25zZTogJHt0ZXh0RXJyb3J9YCB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGVycm9yRGF0YSBpcyBzdGlsbCBlbXB0eSwgY3JlYXRlIGEgZGVmYXVsdCBlcnJvclxuICAgICAgaWYgKE9iamVjdC5rZXlzKGVycm9yRGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGVycm9yRGF0YSA9IHtcbiAgICAgICAgICBtZXNzYWdlOiBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLFxuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBFeHRyYWN0IGVycm9yIG1lc3NhZ2UgZnJvbSBFcnJvclJlc3BvbnNlIGZvcm1hdCAodXNlZCBieSB1c2VyLXNlcnZpY2UpXG4gICAgICAvLyBFcnJvclJlc3BvbnNlIGhhczogdGltZXN0YW1wLCBzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBwYXRoXG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPVxuICAgICAgICBlcnJvckRhdGEubWVzc2FnZSB8fCAgICAgICAgICAgLy8gRXJyb3JSZXNwb25zZS5tZXNzYWdlXG4gICAgICAgIGVycm9yRGF0YS5lcnJvciB8fCAgICAgICAgICAgICAvLyBFcnJvclJlc3BvbnNlLmVycm9yIChlcnJvciB0aXRsZSlcbiAgICAgICAgZXJyb3JEYXRhLmRldGFpbCB8fCAgICAgICAgICAgIC8vIFN0YW5kYXJkIFNwcmluZyBlcnJvciBmb3JtYXRcbiAgICAgICAgZXJyb3JEYXRhLnJhdyB8fCAgICAgICAgICAgICAgIC8vIFJhdyByZXNwb25zZSB0ZXh0IGlmIEpTT04gcGFyc2luZyBmYWlsZWRcbiAgICAgICAgKEFycmF5LmlzQXJyYXkoZXJyb3JEYXRhLmVycm9ycykgPyBlcnJvckRhdGEuZXJyb3JzLmpvaW4oXCIsIFwiKSA6IG51bGwpIHx8IC8vIFZhbGlkYXRpb24gZXJyb3JzIGFycmF5XG4gICAgICAgICh0eXBlb2YgZXJyb3JEYXRhID09PSAnc3RyaW5nJyA/IGVycm9yRGF0YSA6IG51bGwpIHx8XG4gICAgICAgIGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuXG4gICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICAgIDsgKGFwaUVycm9yIGFzIGFueSkuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzXG4gICAgICAgIDsgKGFwaUVycm9yIGFzIGFueSkuZXJyb3JEYXRhID0gZXJyb3JEYXRhXG4gICAgICAgIDsgKGFwaUVycm9yIGFzIGFueSkucmVzcG9uc2VUZXh0ID0gcmVzcG9uc2VUZXh0XG4gICAgICB0aHJvdyBhcGlFcnJvclxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHJlc3BvbnNlIGhhcyBjb250ZW50XG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKVxuICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIHJldHVybiBkYXRhIGFzIFRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gSlNPTiBjb250ZW50LCByZXR1cm4gZW1wdHkgb2JqZWN0IGZvciBzdWNjZXNzZnVsIHJlc3BvbnNlc1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIGFzIEpTT04sIGlmIGZhaWxzIHJldHVybiB0ZXh0IGFzIG1lc3NhZ2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KSBhcyBUXG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHRleHQgfSBhcyBUXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7fSBhcyBUXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhIGNvbm5lY3Rpb24gZXJyb3JcbiAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkVSUl9DT05ORUNUSU9OX1JFRlVTRURcIikpIHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25FcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBjb25uZWN0IHRvIGJhY2tlbmQgc2VydmVyIGF0ICR7QVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgIClcbiAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8qKlxuICogTXVsdGlwYXJ0IGZvcm0gZGF0YSByZXF1ZXN0IGZvciBmaWxlIHVwbG9hZHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEZvcm1EYXRhPFQ+KFxuICBwYXRoOiBzdHJpbmcsXG4gIGZvcm1EYXRhOiBGb3JtRGF0YSxcbiAgb3B0aW9uczogT21pdDxSZXF1ZXN0SW5pdCwgXCJib2R5XCI+ICYgeyByZXF1aXJlc0F1dGg/OiBib29sZWFuOyBzZXJ2aWNlPzogJ2F1dGgnIHwgJ3VzZXJzJyB8ICdwcm9wZXJ0aWVzJyB8ICdib29raW5ncycgfCAncGF5bWVudHMnIHwgJ3JlY2xhbWF0aW9ucycgfCAnYWRtaW4tcmVjbGFtYXRpb25zJyB9ID0ge30sXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgeyByZXF1aXJlc0F1dGggPSB0cnVlLCBzZXJ2aWNlID0gJ3VzZXJzJywgLi4uZmV0Y2hPcHRpb25zIH0gPSBvcHRpb25zXG5cbiAgY29uc3QgaGVhZGVyczogSGVhZGVyc0luaXQgPSB7XG4gICAgLi4uKHJlcXVpcmVzQXV0aCAmJiBnZXRBdXRoSGVhZGVycygpKSxcbiAgICAuLi5mZXRjaE9wdGlvbnMuaGVhZGVycyxcbiAgfVxuXG4gIC8vIERvbid0IHNldCBDb250ZW50LVR5cGUgZm9yIEZvcm1EYXRhIC0gYnJvd3NlciB3aWxsIHNldCBpdCB3aXRoIGJvdW5kYXJ5XG4gIGRlbGV0ZSAoaGVhZGVycyBhcyBhbnkpW1wiQ29udGVudC1UeXBlXCJdXG5cbiAgY29uc3QgdXJsID0gYnVpbGRVcmwocGF0aCwgc2VydmljZSlcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgLi4uZmV0Y2hPcHRpb25zLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgIH0pXG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICByZXR1cm4gZGF0YVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBBUEkgQ2xpZW50IC0gT3JnYW5pemVkIGJ5IHJlc291cmNlXG4gKi9cbmV4cG9ydCBjb25zdCBhcGlDbGllbnQgPSB7XG4gIC8vID09PT09PT09PT09PT09PT09PT09IFBST1BFUlRJRVMgPT09PT09PT09PT09PT09PT09PT1cbiAgcHJvcGVydGllczoge1xuICAgIGFzeW5jIGdldEFsbCgpOiBQcm9taXNlPFByb3BlcnR5W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5wcm9wZXJ0aWVzLmdldEFsbCgpXG4gICAgICB9XG4gICAgICAvLyBVc2UgcHJvcGVydHktc2VydmljZSBVUkwgZm9yIHByb3BlcnR5IGVuZHBvaW50c1xuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllc2BcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLCAvLyBJbmNsdWRlIGF1dGggaGVhZGVycyB0byBjaGVjayBpZiB1c2VyIGlzIEFETUlOXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGlmIChlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRVJSX0NPTk5FQ1RJT05fUkVGVVNFRFwiKSkge1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25FcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgY29ubmVjdCB0byBwcm9wZXJ0eS1zZXJ2aWNlIGJhY2tlbmQgYXQgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9LiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBiYWNrZW5kIGlzIHJ1bm5pbmcuYFxuICAgICAgICAgIClcbiAgICAgICAgICAgIDsgKGNvbm5lY3Rpb25FcnJvciBhcyBhbnkpLmlzQ29ubmVjdGlvbkVycm9yID0gdHJ1ZVxuICAgICAgICAgIHRocm93IGNvbm5lY3Rpb25FcnJvclxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGdldEFsbEZvckFkbWluKCk6IFByb21pc2U8UHJvcGVydHlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnRpZXMuZ2V0QWxsKClcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBHYXRld2F5IG9yIHByb3BlcnR5LXNlcnZpY2UgVVJMIGZvciBhZG1pbiBlbmRwb2ludFxuICAgICAgY29uc3QgdXJsID0gYnVpbGRVcmwoXCIvcHJvcGVydGllcy9hZG1pbi9hbGxcIiwgJ3Byb3BlcnRpZXMnKVxuICAgICAgY29uc3QgYXV0aEhlYWRlcnMgPSBnZXRBdXRoSGVhZGVycygpXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uYXV0aEhlYWRlcnMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhLmVycm9yIHx8IGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gICAgICAgIC8vIEVuc3VyZSBkYXRhIGlzIGFuIGFycmF5XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgIC8vIElmIGl0J3MgYW4gZXJyb3Igb2JqZWN0LCB0aHJvdyBpdFxuICAgICAgICAgIGlmIChkYXRhLmVycm9yIHx8IGRhdGEubWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgZGF0YS5tZXNzYWdlIHx8IFwiSW52YWxpZCByZXNwb25zZSBmb3JtYXRcIilcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHJldHVybiBlbXB0eSBhcnJheVxuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpKSB7XG4gICAgICAgICAgY29uc3QgY29ubmVjdGlvbkVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBjb25uZWN0IHRvIHByb3BlcnR5LXNlcnZpY2UgYmFja2VuZCBhdCAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0uIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXMgcnVubmluZy5gXG4gICAgICAgICAgKVxuICAgICAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICAgICAgdGhyb3cgY29ubmVjdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgZ2V0QnlJZChpZDogc3RyaW5nKTogUHJvbWlzZTxQcm9wZXJ0eT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnRpZXMuZ2V0QnlJZChpZClcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBwcm9wZXJ0eS1zZXJ2aWNlIFVSTCBmb3IgcHJvcGVydHkgZW5kcG9pbnRzXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzLyR7aWR9YFxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkNPUlNcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gcHJvcGVydHktc2VydmljZSBiYWNrZW5kIGF0ICR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgICAgICApXG4gICAgICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBnZXRNeVByb3BlcnRpZXMoKTogUHJvbWlzZTxQcm9wZXJ0eVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5nZXRBbGwoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzL215LXByb3BlcnRpZXNgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhLmVycm9yIHx8IGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gICAgICAgIC8vIEVuc3VyZSBkYXRhIGlzIGFuIGFycmF5XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgIC8vIElmIGl0J3MgYW4gZXJyb3Igb2JqZWN0LCB0aHJvdyBpdFxuICAgICAgICAgIGlmIChkYXRhLmVycm9yIHx8IGRhdGEubWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgZGF0YS5tZXNzYWdlIHx8IFwiSW52YWxpZCByZXNwb25zZSBmb3JtYXRcIilcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHJldHVybiBlbXB0eSBhcnJheVxuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkNPUlNcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gcHJvcGVydHktc2VydmljZSBiYWNrZW5kIGF0ICR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgICAgICApXG4gICAgICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGUoZGF0YTogQ3JlYXRlUHJvcGVydHlSZXF1ZXN0LCBpbWFnZXM6IEZpbGVbXSk6IFByb21pc2U8eyBwcm9wZXJ0eUlkOiBzdHJpbmc7IGlkPzogc3RyaW5nIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2NrLnByb3BlcnRpZXMuY3JlYXRlKGRhdGEsIGltYWdlcylcbiAgICAgICAgcmV0dXJuIHsgcHJvcGVydHlJZDogcmVzdWx0LmlkLCBpZDogcmVzdWx0LmlkIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgIC8vIENyZWF0ZSBhIEJsb2Igd2l0aCBKU09OIGNvbnRlbnQgdHlwZSBmb3IgdGhlIGlucHV0IHBhcnRcbiAgICAgIC8vIFNwcmluZydzIEBSZXF1ZXN0UGFydCBleHBlY3RzIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvbiBmb3IgSlNPTiBwYXJ0c1xuICAgICAgY29uc3QgaW5wdXRCbG9iID0gbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KGRhdGEpXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9KVxuICAgICAgZm9ybURhdGEuYXBwZW5kKFwiaW5wdXRcIiwgaW5wdXRCbG9iKVxuXG4gICAgICBpbWFnZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJpbWFnZXNcIiwgZmlsZSlcbiAgICAgIH0pXG5cbiAgICAgIC8vIFVzZSBwcm9wZXJ0eS1zZXJ2aWNlIFVSTCBmb3IgcHJvcGVydHkgZW5kcG9pbnRzXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzYFxuICAgICAgY29uc3QgaGVhZGVyczogSGVhZGVyc0luaXQgPSB7XG4gICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICB9XG4gICAgICAvLyBEb24ndCBzZXQgQ29udGVudC1UeXBlIGhlYWRlciAtIGxldCBicm93c2VyIHNldCBpdCB3aXRoIGJvdW5kYXJ5IGZvciBtdWx0aXBhcnQvZm9ybS1kYXRhXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyB1cGRhdGUoaWQ6IHN0cmluZywgZGF0YTogVXBkYXRlUHJvcGVydHlSZXF1ZXN0KTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnRpZXMudXBkYXRlKGlkLCBkYXRhKVxuICAgICAgfVxuICAgICAgLy8gVXNlIHByb3BlcnR5LXNlcnZpY2UgVVJMIGZvciBwcm9wZXJ0eSBlbmRwb2ludHNcbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXMvJHtpZH1gXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhY2tlbmQgcmV0dXJucyBcIlByb3BlcnR5IHVwZGF0ZWRcIiBhcyBwbGFpbiB0ZXh0LCBub3QgSlNPTlxuICAgICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dClcbiAgICAgICAgICByZXR1cm4gcGFyc2VkXG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIElmIGl0J3Mgbm90IEpTT04sIHJldHVybiBzdWNjZXNzIG9iamVjdFxuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGlmIChlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRVJSX0NPTk5FQ1RJT05fUkVGVVNFRFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJDT1JTXCIpKSB7XG4gICAgICAgICAgY29uc3QgY29ubmVjdGlvbkVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBjb25uZWN0IHRvIHByb3BlcnR5LXNlcnZpY2UgYmFja2VuZCBhdCAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0uIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXMgcnVubmluZy5gXG4gICAgICAgICAgKVxuICAgICAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICAgICAgdGhyb3cgY29ubmVjdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgZGVsZXRlKGlkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5kZWxldGUoaWQpXG4gICAgICB9XG4gICAgICAvLyBVc2UgcHJvcGVydHktc2VydmljZSBVUkwgZm9yIHByb3BlcnR5IGVuZHBvaW50c1xuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllcy8ke2lkfWBcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGlmIChlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRVJSX0NPTk5FQ1RJT05fUkVGVVNFRFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJDT1JTXCIpKSB7XG4gICAgICAgICAgY29uc3QgY29ubmVjdGlvbkVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBjb25uZWN0IHRvIHByb3BlcnR5LXNlcnZpY2UgYmFja2VuZCBhdCAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0uIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXMgcnVubmluZy5gXG4gICAgICAgICAgKVxuICAgICAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICAgICAgdGhyb3cgY29ubmVjdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgYXBwcm92ZShpZDogc3RyaW5nLCBpc0FwcHJvdmVkOiBib29sZWFuKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnRpZXMuYXBwcm92ZShpZCwgaXNBcHByb3ZlZClcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBwcm9wZXJ0eS1zZXJ2aWNlIFVSTCBmb3IgcHJvcGVydHkgZW5kcG9pbnRzXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzLyR7aWR9L2FwcHJvdmVgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaXNBcHByb3ZlZCB9IGFzIEFwcHJvdmVQcm9wZXJ0eVJlcXVlc3QpLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHByb3BlcnR5XG4gICAgICovXG4gICAgYXN5bmMgaGlkZShpZDogc3RyaW5nLCBpc0hpZGRlbjogYm9vbGVhbik6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH1cbiAgICAgIC8vIFVzZSBwcm9wZXJ0eS1zZXJ2aWNlIFVSTCBmb3IgcHJvcGVydHkgZW5kcG9pbnRzXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzLyR7aWR9L2hpZGVgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaXNIaWRkZW4gfSksXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIHN1c3BlbmQoaWQ6IHN0cmluZywgcmVhc29uOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5zdXNwZW5kKGlkLCByZWFzb24pXG4gICAgICB9XG4gICAgICAvLyBVc2UgcHJvcGVydHktc2VydmljZSBVUkwgZm9yIHByb3BlcnR5IGVuZHBvaW50c1xuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllcy8ke2lkfS9zdXNwZW5kYFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHJlYXNvbiB9KSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgcmV2b2tlU3VzcGVuc2lvbihpZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnRpZXMuc3VzcGVuZChpZCwgXCJcIikgLy8gTW9ja1xuICAgICAgfVxuICAgICAgLy8gVXNlIHByb3BlcnR5LXNlcnZpY2UgVVJMIGZvciBwcm9wZXJ0eSBlbmRwb2ludHNcbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXMvJHtpZH0vcmV2b2tlLXN1c3BlbnNpb25gXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBzdWJtaXRGb3JBcHByb3ZhbChpZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnRpZXMuYXBwcm92ZShpZCwgdHJ1ZSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXMvJHtpZH0vc3VibWl0LWZvci1hcHByb3ZhbGBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbEFwcHJvdmFsUmVxdWVzdChpZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfVxuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllcy8ke2lkfS9jYW5jZWwtYXBwcm92YWwtcmVxdWVzdGBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBBSS1wb3dlcmVkIHByaWNlIHN1Z2dlc3Rpb24gZm9yIGEgcHJvcGVydHkgYW5kIGRhdGUgcmFuZ2UuXG4gICAgICogVGhpcyBjYWxscyBwcm9wZXJ0eS1zZXJ2aWNlLCB3aGljaCBmb3J3YXJkcyB0aGUgcmVxdWVzdCB0byB0aGUgcHJpY2luZyBtb2RlbCBBUEkuXG4gICAgICovXG4gICAgYXN5bmMgcHJlZGljdFByaWNlKFxuICAgICAgcHJvcGVydHlJZDogc3RyaW5nLFxuICAgICAgY2hlY2tJbkRhdGU6IHN0cmluZyxcbiAgICAgIGNoZWNrT3V0RGF0ZTogc3RyaW5nLFxuICAgICk6IFByb21pc2U8e1xuICAgICAgcHJlZGljdGVkUHJpY2VNYWQ6IG51bWJlclxuICAgICAgcHJlZGljdGVkUHJpY2VVc2Q6IG51bWJlclxuICAgICAgY29uZmlkZW5jZUludGVydmFsTG93ZXI6IG51bWJlclxuICAgICAgY29uZmlkZW5jZUludGVydmFsVXBwZXI6IG51bWJlclxuICAgICAgY2l0eTogc3RyaW5nXG4gICAgICBzZWFzb246IHN0cmluZ1xuICAgICAgbW9kZWxWZXJzaW9uOiBzdHJpbmdcbiAgICAgIHByZWRpY3Rpb25UaW1lc3RhbXA6IHN0cmluZ1xuICAgICAgY3VycmVudFByaWNlTWFkPzogbnVtYmVyXG4gICAgICBwcmljZURpZmZlcmVuY2VQZXJjZW50PzogbnVtYmVyXG4gICAgICByZWNvbW1lbmRhdGlvbj86IHN0cmluZ1xuICAgIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgLy8gTGlnaHR3ZWlnaHQgbW9jayBmb3IgVUkgZGV2ZWxvcG1lbnRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcmVkaWN0ZWRQcmljZU1hZDogNDMwLFxuICAgICAgICAgIHByZWRpY3RlZFByaWNlVXNkOiA0MyxcbiAgICAgICAgICBjb25maWRlbmNlSW50ZXJ2YWxMb3dlcjogMzgwLFxuICAgICAgICAgIGNvbmZpZGVuY2VJbnRlcnZhbFVwcGVyOiA0ODAsXG4gICAgICAgICAgY2l0eTogXCJjYXNhYmxhbmNhXCIsXG4gICAgICAgICAgc2Vhc29uOiBcInN1bW1lclwiLFxuICAgICAgICAgIG1vZGVsVmVyc2lvbjogXCIxLjBcIixcbiAgICAgICAgICBwcmVkaWN0aW9uVGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgY3VycmVudFByaWNlTWFkOiA0MDAsXG4gICAgICAgICAgcHJpY2VEaWZmZXJlbmNlUGVyY2VudDogNy41LFxuICAgICAgICAgIHJlY29tbWVuZGF0aW9uOiBcIklOQ1JFQVNFXCIsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllcy8ke3Byb3BlcnR5SWR9L3ByZWRpY3QtcHJpY2VgXG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcHJvcGVydHlJZCxcbiAgICAgICAgICBjaGVja0luRGF0ZSxcbiAgICAgICAgICBjaGVja091dERhdGUsXG4gICAgICAgIH0pLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgIGRhdGE/Lm1lc3NhZ2UgfHxcbiAgICAgICAgICBkYXRhPy5lcnJvciB8fFxuICAgICAgICAgICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGRhdGEgOiBudWxsKSB8fFxuICAgICAgICAgIGBGYWlsZWQgdG8gZ2V0IHByaWNlIHN1Z2dlc3Rpb246ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSxcbiAgfSxcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSBURU5BTlQgUklTSyA9PT09PT09PT09PT09PT09PT09PVxuICByaXNrOiB7XG4gICAgZ2V0VGVuYW50Umlza1Njb3JlOiBhc3luYyAodGVuYW50SWQ6IG51bWJlcik6IFByb21pc2U8VGVuYW50Umlza1Jlc3BvbnNlPiA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBVc2UgbG9jYWwgTmV4dC5qcyBwcm94eVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3RlbmFudC1yaXNrLyR7dGVuYW50SWR9YCwge1xuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNTCBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyByaXNrIHNjb3JlOlwiLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuICB9LFxuXG4gIHJlY29tbWVuZGF0aW9uczoge1xuICAgIGdldEZvclRlbmFudDogYXN5bmMgKHRlbmFudElkOiBudW1iZXIsIG1heFJlc3VsdHM6IG51bWJlciA9IDMpOiBQcm9taXNlPGFueT4gPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9yZWNvbW1lbmRhdGlvbnMvdGVuYW50LyR7dGVuYW50SWR9P21heF9yZXN1bHRzPSR7bWF4UmVzdWx0c31gKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIHJlY29tbWVuZGF0aW9uc1wiKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyByZWNvbW1lbmRhdGlvbnM6XCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRTaW1pbGFyOiBhc3luYyAocHJvcGVydHlJZDogc3RyaW5nLCBtYXhSZXN1bHRzOiBudW1iZXIgPSAzKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvcmVjb21tZW5kYXRpb25zL3NpbWlsYXIvJHtwcm9wZXJ0eUlkfT9tYXhfcmVzdWx0cz0ke21heFJlc3VsdHN9YCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBzaW1pbGFyIHByb3BlcnRpZXNcIik7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgc2ltaWxhciBwcm9wZXJ0aWVzOlwiLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSBWRVJJRklDQVRJT04gUkVRVUVTVFMgPT09PT09PT09PT09PT09PT09PT1cbiAgdmVyaWZpY2F0aW9uUmVxdWVzdHM6IHtcbiAgICBhc3luYyBnZXRBbGwoKTogUHJvbWlzZTxWZXJpZmljYXRpb25SZXF1ZXN0W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay52ZXJpZmljYXRpb25SZXF1ZXN0cy5nZXRBbGwoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvdmVyaWZpY2F0aW9uLXJlcXVlc3RzXCIpXG4gICAgfSxcblxuICAgIGFzeW5jIGdldEJ5U3RhdHVzKHN0YXR1czogc3RyaW5nKTogUHJvbWlzZTxWZXJpZmljYXRpb25SZXF1ZXN0W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay52ZXJpZmljYXRpb25SZXF1ZXN0cy5nZXRCeVN0YXR1cyhzdGF0dXMpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3ZlcmlmaWNhdGlvbi1yZXF1ZXN0cy9ieS1zdGF0dXMvJHtzdGF0dXN9YClcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlKHByb3BlcnR5SWQ6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZyk6IFByb21pc2U8eyBpZDogbnVtYmVyIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay52ZXJpZmljYXRpb25SZXF1ZXN0cy5jcmVhdGUocHJvcGVydHlJZCwgZGVzY3JpcHRpb24pXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi92ZXJpZmljYXRpb24tcmVxdWVzdHNcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHByb3BlcnR5SWQsIGRlc2NyaXB0aW9uIH0pLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgYXBwcm92ZShpZDogbnVtYmVyKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnZlcmlmaWNhdGlvblJlcXVlc3RzLmFwcHJvdmUoaWQpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3ZlcmlmaWNhdGlvbi1yZXF1ZXN0cy8ke2lkfS9hcHByb3ZlYCwge1xuICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIHJlamVjdChpZDogbnVtYmVyLCByZWFzb246IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay52ZXJpZmljYXRpb25SZXF1ZXN0cy5yZWplY3QoaWQsIHJlYXNvbilcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KGAvdmVyaWZpY2F0aW9uLXJlcXVlc3RzLyR7aWR9L3JlamVjdGAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcmVhc29uIH0pLFxuICAgICAgfSlcbiAgICB9LFxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IFBST1BFUlRZIFRZUEVTID09PT09PT09PT09PT09PT09PT09XG4gIHByb3BlcnR5VHlwZXM6IHtcbiAgICBhc3luYyBnZXRBbGwoKTogUHJvbWlzZTxQcm9wZXJ0eVR5cGVbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnR5VHlwZXMuZ2V0QWxsKClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL3Byb3BlcnR5LXR5cGVzXCIsIHsgcmVxdWlyZXNBdXRoOiBmYWxzZSB9KVxuICAgIH0sXG5cbiAgICBhc3luYyBnZXRCeUlkKGlkOiBudW1iZXIpOiBQcm9taXNlPFByb3BlcnR5VHlwZT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnR5VHlwZXMuZ2V0QnlJZChpZClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KGAvcHJvcGVydHktdHlwZXMvJHtpZH1gLCB7IHJlcXVpcmVzQXV0aDogZmFsc2UgfSlcbiAgICB9LFxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IFVTRVJTID09PT09PT09PT09PT09PT09PT09XG4gIHVzZXJzOiB7XG4gICAgYXN5bmMgZ2V0TWUoKTogUHJvbWlzZTx7XG4gICAgICBmaXJzdE5hbWU6IHN0cmluZ1xuICAgICAgbGFzdE5hbWU6IHN0cmluZ1xuICAgICAgZW1haWw6IHN0cmluZ1xuICAgICAgcHJvZmlsZVBpY3R1cmU/OiBzdHJpbmdcbiAgICAgIGJpcnRoZGF5Pzogc3RyaW5nXG4gICAgICBwaG9uZU51bWJlcj86IG51bWJlclxuICAgICAgd2FsbGV0QWRkcmVzcz86IHN0cmluZ1xuICAgICAgcm9sZXM/OiBzdHJpbmdbXVxuICAgIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgLy8gTW9jayB1c2VyIGRhdGEgZm9yIGRldmVsb3BtZW50XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZmlyc3ROYW1lOiBcIk1vY2tcIixcbiAgICAgICAgICBsYXN0TmFtZTogXCJVc2VyXCIsXG4gICAgICAgICAgZW1haWw6IFwibW9ja0BleGFtcGxlLmNvbVwiLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi91c2Vycy9tZVwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgaW5mb3JtYXRpb24gYnkgSUQgKGZvciBnZXR0aW5nIHBob25lIG51bWJlciwgZXRjLilcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCeUlkKHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTx7XG4gICAgICBmaXJzdE5hbWU6IHN0cmluZ1xuICAgICAgbGFzdE5hbWU6IHN0cmluZ1xuICAgICAgZW1haWw6IHN0cmluZ1xuICAgICAgcHJvZmlsZVBpY3R1cmU/OiBzdHJpbmdcbiAgICAgIGJpcnRoZGF5Pzogc3RyaW5nXG4gICAgICBwaG9uZU51bWJlcj86IG51bWJlclxuICAgICAgd2FsbGV0QWRkcmVzcz86IHN0cmluZ1xuICAgICAgcm9sZXM/OiBzdHJpbmdbXVxuICAgICAgc2NvcmU/OiBudW1iZXJcbiAgICAgIHJhdGluZz86IG51bWJlclxuICAgICAgZW5hYmxlZD86IGJvb2xlYW5cbiAgICB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZmlyc3ROYW1lOiBcIk1vY2tcIixcbiAgICAgICAgICBsYXN0TmFtZTogXCJVc2VyXCIsXG4gICAgICAgICAgZW1haWw6IFwibW9ja0BleGFtcGxlLmNvbVwiLFxuICAgICAgICAgIHBob25lTnVtYmVyOiAxMjM0NTY3ODkwLFxuICAgICAgICAgIHNjb3JlOiAxMDAsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRyeSB0byBnZXQgZnJvbSBhZG1pbiBlbmRwb2ludCBmaXJzdCAoaWYgdXNlciBpcyBhZG1pbikgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWxsVXNlcnMgPSBhd2FpdCB0aGlzLmdldEFsbEZvckFkbWluKClcbiAgICAgICAgY29uc3QgdXNlciA9IGFsbFVzZXJzLmZpbmQodSA9PiBTdHJpbmcodS5pZCkgPT09IFN0cmluZyh1c2VySWQpKVxuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaXJzdE5hbWU6IHVzZXIuZmlyc3ROYW1lLFxuICAgICAgICAgICAgbGFzdE5hbWU6IHVzZXIubGFzdE5hbWUsXG4gICAgICAgICAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICAgICAgICAgIHByb2ZpbGVQaWN0dXJlOiB1c2VyLnByb2ZpbGVQaWN0dXJlLFxuICAgICAgICAgICAgYmlydGhkYXk6IHVzZXIuYmlydGhkYXksXG4gICAgICAgICAgICBwaG9uZU51bWJlcjogdXNlci5waG9uZU51bWJlcixcbiAgICAgICAgICAgIHdhbGxldEFkZHJlc3M6IHVzZXIud2FsbGV0QWRkcmVzcyxcbiAgICAgICAgICAgIHJvbGVzOiB1c2VyLnJvbGVzLFxuICAgICAgICAgICAgc2NvcmU6IHVzZXIuc2NvcmUsXG4gICAgICAgICAgICBlbmFibGVkOiB1c2VyLmVuYWJsZWQsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gSWYgYWRtaW4gZW5kcG9pbnQgZmFpbHMsIGZhbGxiYWNrIHRvIHJlZ3VsYXIgZW5kcG9pbnRcbiAgICAgIH1cblxuICAgICAgLy8gRmFsbGJhY2sgdG8gcmVndWxhciBlbmRwb2ludFxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC91c2Vycy8ke3VzZXJJZH1gLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgdXBkYXRlTWUoZGF0YToge1xuICAgICAgZmlyc3ROYW1lPzogc3RyaW5nXG4gICAgICBsYXN0TmFtZT86IHN0cmluZ1xuICAgICAgYmlydGhkYXk/OiBzdHJpbmcgLy8gWVlZWS1NTS1ERCBmb3JtYXRcbiAgICAgIHBob25lTnVtYmVyPzogc3RyaW5nIC8vIDEwLTE1IGRpZ2l0c1xuICAgICAgd2FsbGV0QWRkcmVzcz86IHN0cmluZyAvLyBFdGhlcmV1bSBhZGRyZXNzXG4gICAgfSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICAvLyBNb2NrIHVwZGF0ZVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL3VzZXJzL21lXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgdXBkYXRlUHJvZmlsZVBpY3R1cmUoZmlsZTogRmlsZSk6IFByb21pc2U8eyB1cmw6IHN0cmluZyB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7IHVybDogXCIvcGxhY2Vob2xkZXItdXNlci5qcGdcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgZmlsZSlcblxuICAgICAgY29uc3QgaGVhZGVycyA9IGdldEF1dGhIZWFkZXJzKClcbiAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaGVhZGVyIHRvIGxldCBicm93c2VyIHNldCBpdCB3aXRoIGJvdW5kYXJ5IGZvciBtdWx0aXBhcnQvZm9ybS1kYXRhXG4gICAgICBkZWxldGUgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXVxuXG4gICAgICBjb25zdCB1cmwgPSBidWlsZFVybChcIi91c2Vycy9tZS9wcm9maWxlLXBpY3R1cmVcIilcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgbGV0IGVycm9yRGF0YTogYW55ID0ge31cbiAgICAgICAgbGV0IHJlc3BvbnNlVGV4dCA9IFwiXCJcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgICAgIGlmIChyZXNwb25zZVRleHQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGVycm9yRGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KVxuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIGVycm9yRGF0YSA9IHsgbWVzc2FnZTogcmVzcG9uc2VUZXh0LCByYXc6IHJlc3BvbnNlVGV4dCB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBlcnJvckRhdGEgPSB7IG1lc3NhZ2U6IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICBlcnJvckRhdGEubWVzc2FnZSB8fFxuICAgICAgICAgIGVycm9yRGF0YS5lcnJvciB8fFxuICAgICAgICAgIGVycm9yRGF0YS5yYXcgfHxcbiAgICAgICAgICBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcblxuICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICAgICAgOyAoYXBpRXJyb3IgYXMgYW55KS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICA7IChhcGlFcnJvciBhcyBhbnkpLmVycm9yRGF0YSA9IGVycm9yRGF0YVxuICAgICAgICB0aHJvdyBhcGlFcnJvclxuICAgICAgfVxuXG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICByZXR1cm4geyB1cmw6IHRleHQgfSAvLyBCYWNrZW5kIHJldHVybnMgVVJMIGFzIHBsYWluIHRleHRcbiAgICB9LFxuXG4gICAgYXN5bmMgY2hhbmdlUGFzc3dvcmQoY3VycmVudFBhc3N3b3JkOiBzdHJpbmcsIG5ld1Bhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHsgbWVzc2FnZTogc3RyaW5nIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJQYXNzd29yZCBjaGFuZ2VkIHN1Y2Nlc3NmdWxseVwiIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL3VzZXJzL21lL2NoYW5nZS1wYXNzd29yZFwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY3VycmVudFBhc3N3b3JkLCBuZXdQYXNzd29yZCB9KSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIGRlbGV0ZVByb2ZpbGVQaWN0dXJlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL3VzZXJzL21lL3Byb2ZpbGUtcGljdHVyZVwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgYmVjb21lSG9zdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi91c2Vycy9tZS9iZWNvbWUtaG9zdFwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIHJlcXVpcmVzQXV0aDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIGdldEFsbEZvckFkbWluKCk6IFByb21pc2U8QXJyYXk8e1xuICAgICAgaWQ6IG51bWJlclxuICAgICAgZmlyc3ROYW1lOiBzdHJpbmdcbiAgICAgIGxhc3ROYW1lOiBzdHJpbmdcbiAgICAgIGVtYWlsOiBzdHJpbmdcbiAgICAgIHByb2ZpbGVQaWN0dXJlPzogc3RyaW5nXG4gICAgICBiaXJ0aGRheT86IHN0cmluZ1xuICAgICAgcGhvbmVOdW1iZXI/OiBudW1iZXJcbiAgICAgIHdhbGxldEFkZHJlc3M/OiBzdHJpbmdcbiAgICAgIHJvbGVzPzogc3RyaW5nW11cbiAgICAgIGVuYWJsZWQ6IGJvb2xlYW5cbiAgICAgIHNjb3JlOiBudW1iZXJcbiAgICAgIHJhdGluZz86IG51bWJlclxuICAgIH0+PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvdXNlcnMvYWRtaW4vYWxsXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyBlbmFibGVVc2VyKHVzZXJJZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC91c2Vycy9hZG1pbi8ke3VzZXJJZH0vZW5hYmxlYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7fSksXG4gICAgICAgIHJlcXVpcmVzQXV0aDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIGRpc2FibGVVc2VyKHVzZXJJZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC91c2Vycy9hZG1pbi8ke3VzZXJJZH0vZGlzYWJsZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe30pLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyBhZGRBZG1pblJvbGUodXNlcklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3VzZXJzL2FkbWluLyR7dXNlcklkfS9hZGQtYWRtaW4tcm9sZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVtb3ZlQWRtaW5Sb2xlKHVzZXJJZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC91c2Vycy9hZG1pbi8ke3VzZXJJZH0vcmVtb3ZlLWFkbWluLXJvbGVgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIHJlcXVpcmVzQXV0aDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIGFkZEhvc3RSb2xlQnlBZG1pbih1c2VySWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KGAvdXNlcnMvYWRtaW4vJHt1c2VySWR9L2FkZC1ob3N0LXJvbGVgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIHJlcXVpcmVzQXV0aDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIHJlbW92ZUhvc3RSb2xlKHVzZXJJZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC91c2Vycy9hZG1pbi8ke3VzZXJJZH0vcmVtb3ZlLWhvc3Qtcm9sZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IEFVVEhFTlRJQ0FUSU9OID09PT09PT09PT09PT09PT09PT09XG4gIGF1dGg6IHtcbiAgICBhc3luYyByZWdpc3RlcihkYXRhOiB7XG4gICAgICBmaXJzdE5hbWU6IHN0cmluZ1xuICAgICAgbGFzdE5hbWU6IHN0cmluZ1xuICAgICAgZW1haWw6IHN0cmluZ1xuICAgICAgcGFzc3dvcmQ6IHN0cmluZ1xuICAgICAgYmlydGhkYXk6IHN0cmluZyAvLyBZWVlZLU1NLUREIGZvcm1hdFxuICAgICAgcGhvbmVOdW1iZXI6IHN0cmluZ1xuICAgICAgcm9sZT86IHN0cmluZ1xuICAgIH0pOiBQcm9taXNlPHsgbWVzc2FnZTogc3RyaW5nIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICAvLyBNb2NrIHJlZ2lzdHJhdGlvbiAtIHNpbXVsYXRlIGRlbGF5XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIlVzZXIgcmVnaXN0ZXJlZCBzdWNjZXNzZnVsbHlcIiB9XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgICAgIGZpcnN0TmFtZTogZGF0YS5maXJzdE5hbWUsXG4gICAgICAgICAgbGFzdE5hbWU6IGRhdGEubGFzdE5hbWUsXG4gICAgICAgICAgZW1haWw6IGRhdGEuZW1haWwsXG4gICAgICAgICAgcGFzc3dvcmQ6IGRhdGEucGFzc3dvcmQsXG4gICAgICAgICAgYmlydGhkYXk6IGRhdGEuYmlydGhkYXksIC8vIFNob3VsZCBiZSBZWVlZLU1NLUREIGZvcm1hdCBmb3IgTG9jYWxEYXRlXG4gICAgICAgICAgcGhvbmVOdW1iZXI6IGRhdGEucGhvbmVOdW1iZXIsIC8vIFNob3VsZCBiZSAxMC0xNSBkaWdpdHMgb25seVxuICAgICAgICAgIC4uLihkYXRhLnJvbGUgJiYgeyByb2xlOiBkYXRhLnJvbGUgfSksXG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCByZXF1ZXN0KFwiL2F1dGgvcmVnaXN0ZXJcIiwge1xuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgICAgICAgIHJlcXVpcmVzQXV0aDogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIC8vIElmIGNvbm5lY3Rpb24gZmFpbHMsIHRocm93IHdpdGggaGVscGZ1bCBtZXNzYWdlXG4gICAgICAgIGlmIChlcnJvcj8uaXNDb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkJhY2tlbmQgc2VydmVyIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIHVzZXItc2VydmljZSBpcyBydW5uaW5nIG9uIHBvcnQgODA4MC5cIlxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBsb2dpbihlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTx7IHRva2VuOiBzdHJpbmc7IGp3dEV4cGlyYXRpb246IG51bWJlciB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgLy8gTW9jayBsb2dpbiAtIHdvdWxkIHVzZSBtb2NrIGRhdGFcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9jayBsb2dpbiBub3QgaW1wbGVtZW50ZWQgLSB1c2UgdXNlQXV0aCBob29rXCIpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi9hdXRoL2xvZ2luXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCwgcGFzc3dvcmQgfSksXG4gICAgICAgIHJlcXVpcmVzQXV0aDogZmFsc2UsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBzZXRBdXRoKHRva2VuOiBzdHJpbmcsIHVzZXI6IFVzZXIpOiB2b2lkIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFVVEhfVE9LRU5fS0VZLCB0b2tlbilcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oVVNFUl9EQVRBX0tFWSwgSlNPTi5zdHJpbmdpZnkodXNlcikpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldFRva2VuKCk6IHN0cmluZyB8IG51bGwge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oQVVUSF9UT0tFTl9LRVkpXG4gICAgfSxcblxuICAgIGdldFVzZXIoKTogVXNlciB8IG51bGwge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBudWxsXG4gICAgICBjb25zdCB1c2VyRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFVTRVJfREFUQV9LRVkpXG4gICAgICByZXR1cm4gdXNlckRhdGEgPyBKU09OLnBhcnNlKHVzZXJEYXRhKSA6IG51bGxcbiAgICB9LFxuXG4gICAgY2xlYXJBdXRoKCk6IHZvaWQge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oQVVUSF9UT0tFTl9LRVkpXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFVTRVJfREFUQV9LRVkpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhc1JvbGUocm9sZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICBjb25zdCB1c2VyID0gdGhpcy5nZXRVc2VyKClcbiAgICAgIHJldHVybiB1c2VyPy5yb2xlcy5pbmNsdWRlcyhyb2xlIGFzIGFueSkgPz8gZmFsc2VcbiAgICB9LFxuXG4gICAgYXN5bmMgdmVyaWZ5KGVtYWlsOiBzdHJpbmcsIHZlcmlmaWNhdGlvbkNvZGU6IHN0cmluZyk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJVc2VyIHZlcmlmaWVkIHN1Y2Nlc3NmdWxseVwiIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL2F1dGgvdmVyaWZ5XCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCwgdmVyaWZpY2F0aW9uQ29kZSB9KSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIHJlc2VuZFZlcmlmaWNhdGlvbkNvZGUoZW1haWw6IHN0cmluZyk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJWZXJpZmljYXRpb24gQ29kZSByZXNlbnQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC9hdXRoL3Jlc2VuZD9lbWFpbD0ke2VuY29kZVVSSUNvbXBvbmVudChlbWFpbCl9YCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICByZXF1aXJlc0F1dGg6IGZhbHNlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgZm9yZ290UGFzc3dvcmQoZW1haWw6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi9hdXRoL2ZvcmdvdC1wYXNzd29yZFwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwgfSksXG4gICAgICAgIHJlcXVpcmVzQXV0aDogZmFsc2UsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyB2ZXJpZnlSZXNldFRva2VuKHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHsgdmFsaWQ6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvYXV0aC92ZXJpZnktcmVzZXQtdG9rZW5cIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHRva2VuIH0pLFxuICAgICAgICByZXF1aXJlc0F1dGg6IGZhbHNlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVzZXRQYXNzd29yZCh0b2tlbjogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL2F1dGgvcmVzZXQtcGFzc3dvcmRcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHRva2VuLCBwYXNzd29yZCB9KSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIHZlcmlmeVJlc2V0Q29kZShlbWFpbDogc3RyaW5nLCBjb2RlOiBzdHJpbmcpOiBQcm9taXNlPHsgdmFsaWQ6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvYXV0aC92ZXJpZnktcmVzZXQtY29kZVwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwsIGNvZGUgfSksXG4gICAgICAgIHJlcXVpcmVzQXV0aDogZmFsc2UsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyByZXNldFBhc3N3b3JkV2l0aENvZGUoZW1haWw6IHN0cmluZywgY29kZTogc3RyaW5nLCBuZXdQYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIlBhc3N3b3JkIHJlc2V0IHN1Y2Nlc3NmdWxseVwiIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL2F1dGgvcmVzZXQtcGFzc3dvcmQtd2l0aC1jb2RlXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCwgY29kZSwgbmV3UGFzc3dvcmQgfSksXG4gICAgICAgIHJlcXVpcmVzQXV0aDogZmFsc2UsXG4gICAgICB9KVxuICAgIH0sXG4gIH0sXG5cbiAgYm9va2luZ3M6IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGJvb2tpbmdzIGZvciBhZG1pblxuICAgICAqL1xuICAgIGFzeW5jIGdldEFsbEZvckFkbWluKCk6IFByb21pc2U8QXJyYXk8e1xuICAgICAgaWQ6IG51bWJlclxuICAgICAgdXNlcklkOiBudW1iZXJcbiAgICAgIHByb3BlcnR5SWQ6IHN0cmluZ1xuICAgICAgcHJvcGVydHlUaXRsZTogc3RyaW5nXG4gICAgICBwcm9wZXJ0eUFkZHJlc3M6IHN0cmluZ1xuICAgICAgb3duZXJJZDogbnVtYmVyIHwgbnVsbFxuICAgICAgdGVuYW50TmFtZTogc3RyaW5nXG4gICAgICB0ZW5hbnRFbWFpbDogc3RyaW5nXG4gICAgICBob3N0TmFtZTogc3RyaW5nXG4gICAgICBob3N0RW1haWw6IHN0cmluZ1xuICAgICAgY2hlY2tJbkRhdGU6IHN0cmluZ1xuICAgICAgY2hlY2tPdXREYXRlOiBzdHJpbmdcbiAgICAgIG51bWJlck9mTmlnaHRzOiBudW1iZXIgfCBudWxsXG4gICAgICB0b3RhbFByaWNlOiBudW1iZXIgfCBudWxsXG4gICAgICBsb25nU3RheURpc2NvdW50UGVyY2VudDogbnVtYmVyIHwgbnVsbFxuICAgICAgcmVxdWVzdGVkTmVnb3RpYXRpb25QZXJjZW50OiBudW1iZXIgfCBudWxsXG4gICAgICBzdGF0dXM6IHN0cmluZ1xuICAgICAgb25DaGFpblR4SGFzaDogc3RyaW5nIHwgbnVsbFxuICAgICAgbmVnb3RpYXRpb25FeHBpcmVzQXQ6IHN0cmluZyB8IG51bGxcbiAgICAgIGNyZWF0ZWRBdDogc3RyaW5nXG4gICAgICB1cGRhdGVkQXQ6IHN0cmluZyB8IG51bGxcbiAgICB9Pj4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvYWRtaW4vYWxsYFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGJvb2tpbmdzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkVSUl9DT05ORUNUSU9OX1JFRlVTRURcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gYm9va2luZy1zZXJ2aWNlIGJhY2tlbmQgYXQgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0uIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXMgcnVubmluZy5gXG4gICAgICAgICAgKVxuICAgICAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICAgICAgdGhyb3cgY29ubmVjdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgYm9va2luZyByZXF1ZXN0XG4gICAgICogU2VuZHMgYm9va2luZyBkYXRhIHRvIGJvb2tpbmctc2VydmljZSB2aWEgUmFiYml0TVFcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUoZGF0YToge1xuICAgICAgdXNlcklkOiBzdHJpbmcgfCBudW1iZXJcbiAgICAgIHByb3BlcnR5SWQ6IHN0cmluZyB8IG51bWJlclxuICAgICAgY2hlY2tJbkRhdGU6IHN0cmluZ1xuICAgICAgY2hlY2tPdXREYXRlOiBzdHJpbmdcbiAgICAgIG51bWJlck9mR3Vlc3RzOiBudW1iZXJcbiAgICAgIHJlcXVlc3RlZFByaWNlPzogbnVtYmVyXG4gICAgfSk6IFByb21pc2U8eyBzdGF0dXM6IHN0cmluZzsgbWVzc2FnZTogc3RyaW5nOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2suYm9va2luZ3M/LmNyZWF0ZT8uKGRhdGEpIHx8IHsgc3RhdHVzOiBcImFjY2VwdGVkXCIsIG1lc3NhZ2U6IFwiQm9va2luZyByZXF1ZXN0IHNlbnRcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvcmVxdWVzdGBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdXNlcklkOiB0eXBlb2YgZGF0YS51c2VySWQgPT09IFwic3RyaW5nXCIgPyBwYXJzZUludChkYXRhLnVzZXJJZCkgOiBkYXRhLnVzZXJJZCxcbiAgICAgICAgICBwcm9wZXJ0eUlkOiBkYXRhLnByb3BlcnR5SWQsIC8vIEtlZXAgYXMgU3RyaW5nIChVVUlEIGZyb20gcHJvcGVydHktc2VydmljZSlcbiAgICAgICAgICBjaGVja0luRGF0ZTogZGF0YS5jaGVja0luRGF0ZSxcbiAgICAgICAgICBjaGVja091dERhdGU6IGRhdGEuY2hlY2tPdXREYXRlLFxuICAgICAgICAgIG51bWJlck9mR3Vlc3RzOiBkYXRhLm51bWJlck9mR3Vlc3RzLFxuICAgICAgICAgIHJlcXVlc3RlZFByaWNlOiBkYXRhLnJlcXVlc3RlZFByaWNlLFxuICAgICAgICB9KSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIC8vIElmIHN0YXR1cyBpcyBcInJlamVjdGVkXCIsIHJldHVybiB0aGUgcmVzcG9uc2UgZGF0YSBpbnN0ZWFkIG9mIHRocm93aW5nXG4gICAgICAgIGlmIChyZXNwb25zZURhdGEuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2VEYXRhXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gY3JlYXRlIGJvb2tpbmc6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZURhdGFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJvb2tpbmcgYnkgSURcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCeUlkKGlkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLmJvb2tpbmdzPy5nZXRCeUlkPy4oaWQpIHx8IG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy8ke2lkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGJvb2tpbmc6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJvb2tpbmdzIGJ5IHRlbmFudCBJRFxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5VGVuYW50SWQodGVuYW50SWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5ib29raW5ncz8uZ2V0QnlUZW5hbnRJZD8uKHRlbmFudElkKSB8fCBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzP3RlbmFudElkPSR7dGVuYW50SWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGJvb2tpbmdzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IGJvb2tpbmcgZm9yIGEgdXNlclxuICAgICAqL1xuICAgIGFzeW5jIGdldEN1cnJlbnRCb29raW5nKHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnkgfCBudWxsPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIC8vIE1vY2s6IHJldHVybiBudWxsIGZvciBub3cgKG5vIGN1cnJlbnQgYm9va2luZylcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9jdXJyZW50P3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0IHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGN1cnJlbnQgYm9va2luZzogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGVuZGluZyBib29raW5ncyAobmVnb3RpYXRpb25zKSBmb3IgYSB1c2VyXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UGVuZGluZ0Jvb2tpbmdzKHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICAvLyBNb2NrOiByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvcGVuZGluZz91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHBlbmRpbmcgYm9va2luZ3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGF3YWl0aW5nIHBheW1lbnQgYm9va2luZ3MgZm9yIGEgdXNlclxuICAgICAqL1xuICAgIGFzeW5jIGdldEF3YWl0aW5nUGF5bWVudEJvb2tpbmdzKHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICAvLyBNb2NrOiByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvcGF5bWVudD91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGF3YWl0aW5nIHBheW1lbnQgYm9va2luZ3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHByb3BlcnR5IGluZm8gZm9yIGJvb2tpbmcgKHByaWNlLCBkaXNjb3VudCwgbmVnb3RpYXRpb24pXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJvcGVydHlJbmZvKHByb3BlcnR5SWQ6IHN0cmluZyk6IFByb21pc2U8e1xuICAgICAgaWQ6IHN0cmluZ1xuICAgICAgb3duZXJJZDogbnVtYmVyXG4gICAgICBwcmljZVBlck5pZ2h0OiBudW1iZXIgfCBzdHJpbmcgLy8gQ2FuIGJlIG51bWJlciBvciBzdHJpbmcgKEJpZ0RlY2ltYWwgZnJvbSBiYWNrZW5kKVxuICAgICAgaXNOZWdvdGlhYmxlOiBib29sZWFuXG4gICAgICBkaXNjb3VudEVuYWJsZWQ6IGJvb2xlYW5cbiAgICAgIG1heE5lZ290aWF0aW9uUGVyY2VudD86IG51bWJlclxuICAgIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgLy8gTW9jayBwcm9wZXJ0eSBpbmZvXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IHByb3BlcnR5SWQsXG4gICAgICAgICAgb3duZXJJZDogMSxcbiAgICAgICAgICBwcmljZVBlck5pZ2h0OiAxMDAsXG4gICAgICAgICAgaXNOZWdvdGlhYmxlOiBmYWxzZSxcbiAgICAgICAgICBkaXNjb3VudEVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvcHJvcGVydHkvJHtwcm9wZXJ0eUlkfWBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkNPUlNcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gYm9va2luZy1zZXJ2aWNlIGJhY2tlbmQgYXQgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0uIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXMgcnVubmluZy5gXG4gICAgICAgICAgKVxuICAgICAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICAgICAgdGhyb3cgY29ubmVjdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxhc3QgYm9va2luZyBJRCAoZm9yIHBvbGxpbmcgYWZ0ZXIgY3JlYXRpb24pXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TGFzdEJvb2tpbmdJZCgpOiBQcm9taXNlPHsgYm9va2luZ0lkOiBudW1iZXIgfSB8IG51bGw+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgYm9va2luZ0lkOiAxIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9ib29raW5nLWlkYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIGJvb2tpbmdcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUoaWQ6IHN0cmluZyB8IG51bWJlciwgZGF0YToge1xuICAgICAgY2hlY2tJbkRhdGU/OiBzdHJpbmdcbiAgICAgIGNoZWNrT3V0RGF0ZT86IHN0cmluZ1xuICAgICAgbnVtYmVyT2ZHdWVzdHM/OiBudW1iZXJcbiAgICAgIHJlcXVlc3RlZFByaWNlPzogbnVtYmVyXG4gICAgfSk6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2suYm9va2luZ3M/LnVwZGF0ZT8uKGlkLCBkYXRhKSB8fCBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvJHtpZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGNoZWNrSW5EYXRlOiBkYXRhLmNoZWNrSW5EYXRlLFxuICAgICAgICAgIGNoZWNrT3V0RGF0ZTogZGF0YS5jaGVja091dERhdGUsXG4gICAgICAgICAgbnVtYmVyT2ZHdWVzdHM6IGRhdGEubnVtYmVyT2ZHdWVzdHMsXG4gICAgICAgICAgcmVxdWVzdGVkUHJpY2U6IGRhdGEucmVxdWVzdGVkUHJpY2UsXG4gICAgICAgIH0pLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gdXBkYXRlIGJvb2tpbmc6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKVxuICAgICAgICAgIC8vIEFkZCBzdGF0dXMgYW5kIGVycm9yIGNvZGUgZm9yIGJldHRlciBlcnJvciBoYW5kbGluZ1xuICAgICAgICAgIDsgKGVycm9yIGFzIGFueSkuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzXG4gICAgICAgICAgOyAoZXJyb3IgYXMgYW55KS5lcnJvckNvZGUgPSBlcnJvckRhdGEuZXJyb3JcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZS9DYW5jZWwgYSBib29raW5nIChieSB0ZW5hbnQpXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKGlkOiBzdHJpbmcgfCBudW1iZXIsIHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5ib29raW5ncz8uZGVsZXRlPy4oaWQsIHVzZXJJZClcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy8ke2lkfT91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuZXJyb3IgfHwgYEZhaWxlZCB0byBjYW5jZWwgYm9va2luZzogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUZW5hbnQgY2hlY2tvdXQgKGNoYW5nZXMgc3RhdHVzIHRvIFRFTkFOVF9DSEVDS0VEX09VVClcbiAgICAgKi9cbiAgICBhc3luYyB0ZW5hbnRDaGVja291dChpZDogc3RyaW5nIHwgbnVtYmVyLCB0ZW5hbnRJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJUZW5hbnQgY2hlY2tlZCBvdXQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7aWR9L2NoZWNrb3V0L3RlbmFudD91c2VySWQ9JHt0ZW5hbnRJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuZXJyb3IgfHwgYEZhaWxlZCB0byBjaGVja291dDogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPd25lciBjb25maXJtIGNoZWNrb3V0IChjaGFuZ2VzIHN0YXR1cyB0byBDT01QTEVURUQpXG4gICAgICovXG4gICAgYXN5bmMgb3duZXJDb25maXJtQ2hlY2tvdXQoaWQ6IHN0cmluZyB8IG51bWJlciwgb3duZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJDaGVja291dCBjb25maXJtZWQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7aWR9L2NoZWNrb3V0L293bmVyP3VzZXJJZD0ke293bmVySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gY29uZmlybSBjaGVja291dDogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdGVuYW50Q2hlY2tvdXQoKSBvciBvd25lckNvbmZpcm1DaGVja291dCgpIGluc3RlYWRcbiAgICAgKi9cbiAgICBhc3luYyBtYXJrQXNDaGVja2VkT3V0KGlkOiBzdHJpbmcgfCBudW1iZXIsIHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5ib29raW5ncz8ubWFya0FzQ2hlY2tlZE91dD8uKGlkLCB1c2VySWQpIHx8IG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy8ke2lkfS9jaGVja291dD91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gbWFyayBhcyBjaGVja2VkIG91dDogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBib29raW5ncyBieSBvd25lciAoaG9zdClcbiAgICAgKi9cbiAgICBhc3luYyBnZXRDdXJyZW50Qm9va2luZ3NCeU93bmVyKG93bmVySWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvY3VycmVudC9vd25lcj9vd25lcklkPSR7b3duZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggY3VycmVudCBib29raW5nczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGVuZGluZyBuZWdvdGlhdGlvbnMgYnkgb3duZXIgKGhvc3QpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UGVuZGluZ05lZ290aWF0aW9ucyhvd25lcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzL25lZ290aWF0aW9ucz9vd25lcklkPSR7b3duZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggcGVuZGluZyBuZWdvdGlhdGlvbnM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWNjZXB0IG5lZ290aWF0aW9uIChob3N0KVxuICAgICAqL1xuICAgIGFzeW5jIGFjY2VwdE5lZ290aWF0aW9uKGJvb2tpbmdJZDogc3RyaW5nIHwgbnVtYmVyLCBvd25lcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIk5lZ290aWF0aW9uIGFjY2VwdGVkXCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7Ym9va2luZ0lkfS9hY2NlcHQ/b3duZXJJZD0ke293bmVySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gYWNjZXB0IG5lZ290aWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlamVjdCBuZWdvdGlhdGlvbiAoaG9zdClcbiAgICAgKi9cbiAgICBhc3luYyByZWplY3ROZWdvdGlhdGlvbihib29raW5nSWQ6IHN0cmluZyB8IG51bWJlciwgb3duZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJOZWdvdGlhdGlvbiByZWplY3RlZFwiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy8ke2Jvb2tpbmdJZH0vcmVqZWN0P293bmVySWQ9JHtvd25lcklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGVycm9yRGF0YS5lcnJvciB8fCBgRmFpbGVkIHRvIHJlamVjdCBuZWdvdGlhdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGJvb2tpbmdzIGJ5IG93bmVyIChob3N0KVxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5T3duZXJJZChvd25lcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzP293bmVySWQ9JHtvd25lcklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBib29raW5nczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29uZmlybWVkIGJvb2tpbmdzIGJ5IG93bmVyIChob3N0KVxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbmZpcm1lZEJvb2tpbmdzQnlPd25lcihvd25lcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzL2NvbmZpcm1lZC9vd25lcj9vd25lcklkPSR7b3duZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggY29uZmlybWVkIGJvb2tpbmdzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb25maXJtZWQgYm9va2luZ3MgYnkgcHJvcGVydHkgSURcbiAgICAgKi9cbiAgICBhc3luYyBnZXRDb25maXJtZWRCb29raW5nc0J5UHJvcGVydHkocHJvcGVydHlJZDogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9jb25maXJtZWQvcHJvcGVydHkvJHtwcm9wZXJ0eUlkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBjb25maXJtZWQgYm9va2luZ3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwb3J0IGRpc3B1dGUgKGhvc3Qgb3IgdGVuYW50KVxuICAgICAqL1xuICAgIGFzeW5jIHJlcG9ydERpc3B1dGUoYm9va2luZ0lkOiBzdHJpbmcgfCBudW1iZXIsIHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJEaXNwdXRlIHJlcG9ydGVkXCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7Ym9va2luZ0lkfS9kaXNwdXRlP3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gcmVwb3J0IGRpc3B1dGU6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBQYXltZW50IFNlcnZpY2UgQVBJXG4gICAqL1xuICBwYXltZW50czoge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBwYXltZW50IGludGVudFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUludGVudChib29raW5nSWQ6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVmZXJlbmNlSWQ6IFwibW9jay1yZWYtaWRcIixcbiAgICAgICAgICB0bzogXCIweDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBcIixcbiAgICAgICAgICB2YWx1ZTogXCIxMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICBjaGFpbklkOiAzMTMzNyxcbiAgICAgICAgICB0b3RhbEFtb3VudFdlaTogXCIxMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UEFZTUVOVF9BUElfQkFTRV9VUkx9L2FwaS9wYXltZW50cy9pbnRlbnRgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBib29raW5nSWQgfSksXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBjcmVhdGUgcGF5bWVudCBpbnRlbnQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJvb2tpbmcgZGV0YWlscyBmb3IgcGF5bWVudFxuICAgICAqL1xuICAgIGFzeW5jIGdldEJvb2tpbmdEZXRhaWxzKGJvb2tpbmdJZDogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBib29raW5nSWQsXG4gICAgICAgICAgc3RhdHVzOiBcIlBFTkRJTkdfUEFZTUVOVFwiLFxuICAgICAgICAgIHRvdGFsUHJpY2U6IDEwMC4wLFxuICAgICAgICAgIGNoZWNrSW5EYXRlOiBcIjIwMjUtMTItMDFcIixcbiAgICAgICAgICBjaGVja091dERhdGU6IFwiMjAyNS0xMi0wNVwiLFxuICAgICAgICAgIHByb3BlcnR5SWQ6IDEsXG4gICAgICAgICAgcHJvcGVydHlUaXRsZTogXCJNb2NrIFByb3BlcnR5XCIsXG4gICAgICAgICAgcHJvcGVydHlQcmljZTogMjAuMCxcbiAgICAgICAgICBvd25lcldhbGxldEFkZHJlc3M6IFwiMHgxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwXCIsXG4gICAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICAgIGN1cnJlbnRVc2VySWQ6IDEsXG4gICAgICAgICAgdXNlckZpcnN0TmFtZTogXCJKb2huXCIsXG4gICAgICAgICAgdXNlckxhc3ROYW1lOiBcIkRvZVwiLFxuICAgICAgICAgIHVzZXJFbWFpbDogXCJqb2huQGV4YW1wbGUuY29tXCIsXG4gICAgICAgICAgdXNlcldhbGxldEFkZHJlc3M6IG51bGwsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UEFZTUVOVF9BUElfQkFTRV9VUkx9L2FwaS9wYXltZW50cy9ib29raW5nLyR7Ym9va2luZ0lkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgRmFpbGVkIHRvIGZldGNoIGJvb2tpbmcgZGV0YWlsczogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICAgIC8vIEJhY2tlbmQgcmV0dXJucyB7IGNvZGUsIG1lc3NhZ2UgfSBmb3JtYXRcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuY29kZSB8fCBlcnJvck1lc3NhZ2VcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIElmIHJlc3BvbnNlIGlzIG5vdCBKU09OLCB1c2Ugc3RhdHVzIHRleHRcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSByZXNwb25zZS5zdGF0dXNUZXh0IHx8IGVycm9yTWVzc2FnZVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHdhbGxldCBhZGRyZXNzXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlV2FsbGV0QWRkcmVzcyh1c2VySWQ6IG51bWJlciwgd2FsbGV0QWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtQQVlNRU5UX0FQSV9CQVNFX1VSTH0vYXBpL3BheW1lbnRzL3dhbGxldC1hZGRyZXNzYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1c2VySWQsIHdhbGxldEFkZHJlc3MgfSksXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byB1cGRhdGUgd2FsbGV0IGFkZHJlc3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVHJhbnNhY3Rpb25IYXNoKGJvb2tpbmdJZDogbnVtYmVyLCB0eEhhc2g6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UEFZTUVOVF9BUElfQkFTRV9VUkx9L2FwaS9wYXltZW50cy9ib29raW5nLyR7Ym9va2luZ0lkfS90eC1oYXNoYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB0eEhhc2ggfSksXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byB1cGRhdGUgdHJhbnNhY3Rpb24gaGFzaDogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gRGF0ZSBtb2RpZmljYXRpb24gcmVtb3ZlZCAtIGRhdGVzIGNhbiBvbmx5IGJlIGNoYW5nZWQgZnJvbSBib29raW5nLXNlcnZpY2VcblxuICAgIC8qKlxuICAgICAqIEdldCB0cmFuc2FjdGlvbiBzdGF0dXNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblN0YXR1cyh0eEhhc2g6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHhIYXNoLFxuICAgICAgICAgIHN0YXR1czogXCJQRU5ESU5HXCIsXG4gICAgICAgICAgYmxvY2tOdW1iZXI6IG51bGwsXG4gICAgICAgICAgYm9va2luZ0lkOiBudWxsLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1BBWU1FTlRfQVBJX0JBU0VfVVJMfS9hcGkvcGF5bWVudHMvdHgvJHt0eEhhc2h9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHRyYW5zYWN0aW9uIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZSBib29raW5nIG9uIGJsb2NrY2hhaW4gKGNhbGxlZCBieSBob3N0IHdoZW4gY29uZmlybWluZyBjaGVja291dClcbiAgICAgKi9cbiAgICBhc3luYyBjb21wbGV0ZUJvb2tpbmcoYm9va2luZ0lkOiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWVzc2FnZTogXCJCb29raW5nIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkgb24gYmxvY2tjaGFpblwiLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1BBWU1FTlRfQVBJX0JBU0VfVVJMfS9hcGkvcGF5bWVudHMvYm9va2luZy8ke2Jvb2tpbmdJZH0vY29tcGxldGVgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgbGV0IGVycm9yRGF0YTogYW55ID0ge31cbiAgICAgICAgbGV0IGVycm9yVGV4dCA9IFwiXCJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgICAgICBpZiAoZXJyb3JUZXh0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBlcnJvckRhdGEgPSBKU09OLnBhcnNlKGVycm9yVGV4dClcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICBlcnJvckRhdGEgPSB7IG1lc3NhZ2U6IGVycm9yVGV4dCB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSWYgcmVzcG9uc2UgaXMgbm90IEpTT04sIHVzZSBzdGF0dXMgdGV4dFxuICAgICAgICAgIGVycm9yRGF0YSA9IHsgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCB8fCBgU2VydmVyIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yRGF0YS5tZXNzYWdlIHx8IGVycm9yRGF0YS5lcnJvciB8fCBlcnJvclRleHQgfHwgYEZhaWxlZCB0byBjb21wbGV0ZSBib29raW5nOiAke3Jlc3BvbnNlLnN0YXR1c31gXG5cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcbiAgfSxcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSBSRUNMQU1BVElPTlMgPT09PT09PT09PT09PT09PT09PT1cbiAgcmVjbGFtYXRpb25zOiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcmVjbGFtYXRpb24gZm9yIGEgYm9va2luZ1xuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShcbiAgICAgIGJvb2tpbmdJZDogc3RyaW5nIHwgbnVtYmVyLFxuICAgICAgdXNlcklkOiBzdHJpbmcgfCBudW1iZXIsXG4gICAgICBjb21wbGFpbmFudFJvbGU6IFwiR1VFU1RcIiB8IFwiSE9TVFwiLFxuICAgICAgcmVjbGFtYXRpb25UeXBlOiBzdHJpbmcsXG4gICAgICB0aXRsZT86IHN0cmluZyxcbiAgICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nLFxuICAgICAgaW1hZ2VzPzogRmlsZVtdXG4gICAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiwgbWVzc2FnZTogXCJSZWNsYW1hdGlvbiBjcmVhdGVkIHN1Y2Nlc3NmdWxseVwiIH1cbiAgICAgIH1cblxuICAgICAgLy8gVXNlIHJlY2xhbWF0aW9uLXNlcnZpY2UgZGlyZWN0bHkgdG8gc3VwcG9ydCBpbWFnZXNcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcImJvb2tpbmdJZFwiLCBTdHJpbmcoYm9va2luZ0lkKSlcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcInVzZXJJZFwiLCBTdHJpbmcodXNlcklkKSlcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcImNvbXBsYWluYW50Um9sZVwiLCBjb21wbGFpbmFudFJvbGUpXG4gICAgICBmb3JtRGF0YS5hcHBlbmQoXCJyZWNsYW1hdGlvblR5cGVcIiwgcmVjbGFtYXRpb25UeXBlKVxuICAgICAgaWYgKHRpdGxlKSBmb3JtRGF0YS5hcHBlbmQoXCJ0aXRsZVwiLCB0aXRsZSlcbiAgICAgIGlmIChkZXNjcmlwdGlvbikgZm9ybURhdGEuYXBwZW5kKFwiZGVzY3JpcHRpb25cIiwgZGVzY3JpcHRpb24pXG4gICAgICBpZiAoaW1hZ2VzICYmIGltYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGltYWdlcy5mb3JFYWNoKChpbWFnZSkgPT4ge1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVzXCIsIGltYWdlKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9yZWNsYW1hdGlvbnMvY3JlYXRlYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gY3JlYXRlIHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcmVjbGFtYXRpb25zIGJ5IGNvbXBsYWluYW50IElEIChteSBjb21wbGFpbnRzKVxuICAgICAqL1xuICAgIGFzeW5jIGdldE15Q29tcGxhaW50cyh1c2VySWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy9teS1jb21wbGFpbnRzP3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggY29tcGxhaW50czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHJlY2xhbWF0aW9ucyBhZ2FpbnN0IGEgdXNlciAoY29tcGxhaW50cyBhZ2FpbnN0IG1lKVxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbXBsYWludHNBZ2FpbnN0TWUodXNlcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9yZWNsYW1hdGlvbnMvYWdhaW5zdC1tZT91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGNvbXBsYWludHM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBsb2FkIGF0dGFjaG1lbnRzIChpbWFnZXMpIGZvciBhIHJlY2xhbWF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkQXR0YWNobWVudHMocmVjbGFtYXRpb25JZDogbnVtYmVyLCBmaWxlczogRmlsZVtdKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgIGZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZXNcIiwgZmlsZSlcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9L2F0dGFjaG1lbnRzYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gdXBsb2FkIGF0dGFjaG1lbnRzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZWNsYW1hdGlvbiBieSBib29raW5nIElEIGFuZCBjb21wbGFpbmFudCBJRFxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5Qm9va2luZ0lkQW5kQ29tcGxhaW5hbnQoXG4gICAgICBib29raW5nSWQ6IHN0cmluZyB8IG51bWJlcixcbiAgICAgIGNvbXBsYWluYW50SWQ6IHN0cmluZyB8IG51bWJlclxuICAgICk6IFByb21pc2U8YW55IHwgbnVsbD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9yZWNsYW1hdGlvbnMvYm9va2luZy8ke2Jvb2tpbmdJZH0vY29tcGxhaW5hbnQvJHtjb21wbGFpbmFudElkfWBcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gNDA0IGlzIGV4cGVjdGVkIHdoZW4gbm8gcmVjbGFtYXRpb24gZXhpc3RzIC0gcmV0dXJuIG51bGwgc2lsZW50bHlcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgLy8gU2lsZW50bHkgaGFuZGxlIDQwNCBlcnJvcnMgKG5vIHJlY2xhbWF0aW9uIGV4aXN0cyAtIHRoaXMgaXMgbm9ybWFsKVxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoXCI0MDRcIikgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoXCJOb3QgRm91bmRcIikpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZWNsYW1hdGlvbiBieSBJRFxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5SWQocmVjbGFtYXRpb25JZDogbnVtYmVyKTogUHJvbWlzZTxhbnkgfCBudWxsPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVjbGFtYXRpb24gYXR0YWNobWVudHMgKGltYWdlcylcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBdHRhY2htZW50cyhyZWNsYW1hdGlvbklkOiBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9yZWNsYW1hdGlvbnMvJHtyZWNsYW1hdGlvbklkfS9hdHRhY2htZW50c2BcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBhdHRhY2htZW50czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSByZWNsYW1hdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShyZWNsYW1hdGlvbklkOiBzdHJpbmcgfCBudW1iZXIsIHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9yZWNsYW1hdGlvbnMvJHtyZWNsYW1hdGlvbklkfT91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGRlbGV0ZSByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgcmVjbGFtYXRpb24gKHRpdGxlLCBkZXNjcmlwdGlvbiwgaW1hZ2VzKVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShcbiAgICAgIHJlY2xhbWF0aW9uSWQ6IHN0cmluZyB8IG51bWJlcixcbiAgICAgIHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyLFxuICAgICAgdGl0bGU/OiBzdHJpbmcsXG4gICAgICBkZXNjcmlwdGlvbj86IHN0cmluZyxcbiAgICAgIGltYWdlcz86IEZpbGVbXVxuICAgICk6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJzdWNjZXNzXCIsIG1lc3NhZ2U6IFwiUmVjbGFtYXRpb24gdXBkYXRlZCBzdWNjZXNzZnVsbHlcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcInVzZXJJZFwiLCBTdHJpbmcodXNlcklkKSlcbiAgICAgIGlmICh0aXRsZSkgZm9ybURhdGEuYXBwZW5kKFwidGl0bGVcIiwgdGl0bGUpXG4gICAgICBpZiAoZGVzY3JpcHRpb24pIGZvcm1EYXRhLmFwcGVuZChcImRlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uKVxuICAgICAgaWYgKGltYWdlcyAmJiBpbWFnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpbWFnZXMuZm9yRWFjaCgoaW1hZ2UpID0+IHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlc1wiLCBpbWFnZSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvcmVjbGFtYXRpb25zLyR7cmVjbGFtYXRpb25JZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIHVwZGF0ZSByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBwaG9uZSBudW1iZXJcbiAgICAgKi9cbiAgICBhc3luYyBnZXRVc2VyUGhvbmVOdW1iZXIodXNlcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvcmVjbGFtYXRpb25zL3VzZXIvJHt1c2VySWR9L3Bob25lYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHBob25lIG51bWJlcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgcmV0dXJuIGRhdGEucGhvbmVOdW1iZXIgfHwgbnVsbFxuICAgIH0sXG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gQURNSU4gUkVDTEFNQVRJT05TID09PT09PT09PT09PT09PT09PT09XG4gIGFkbWluUmVjbGFtYXRpb25zOiB7XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCByZWNsYW1hdGlvbnMgKGFkbWluIG9ubHkpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsKCk6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL2FkbWluL3JlY2xhbWF0aW9uc2BcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCByZWNsYW1hdGlvbnM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJlY2xhbWF0aW9ucyBieSBzdGF0dXNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCeVN0YXR1cyhzdGF0dXM6IFwiT1BFTlwiIHwgXCJJTl9SRVZJRVdcIiB8IFwiUkVTT0xWRURcIiB8IFwiUkVKRUNURURcIik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL2FkbWluL3JlY2xhbWF0aW9ucy9zdGF0dXMvJHtzdGF0dXN9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHJlY2xhbWF0aW9uczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVjbGFtYXRpb24gYnkgSURcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCeUlkKHJlY2xhbWF0aW9uSWQ6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcmVjbGFtYXRpb24gc2V2ZXJpdHlcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVTZXZlcml0eShyZWNsYW1hdGlvbklkOiBudW1iZXIsIHNldmVyaXR5OiBcIkxPV1wiIHwgXCJNRURJVU1cIiB8IFwiSElHSFwiIHwgXCJDUklUSUNBTFwiKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL2FkbWluL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9L3NldmVyaXR5P3NldmVyaXR5PSR7c2V2ZXJpdHl9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIHVwZGF0ZSBzZXZlcml0eTogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXZpZXcgcmVjbGFtYXRpb24gKG1vdmUgdG8gSU5fUkVWSUVXKVxuICAgICAqL1xuICAgIGFzeW5jIHJldmlldyhyZWNsYW1hdGlvbklkOiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvYWRtaW4vcmVjbGFtYXRpb25zLyR7cmVjbGFtYXRpb25JZH0vcmV2aWV3YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIHJldmlldyByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIHJlY2xhbWF0aW9uIHdpdGggcGVuYWx0eVxuICAgICAqL1xuICAgIGFzeW5jIHJlc29sdmUocmVjbGFtYXRpb25JZDogbnVtYmVyLCByZXNvbHV0aW9uTm90ZXM6IHN0cmluZywgYXBwcm92ZWQ6IGJvb2xlYW4pOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvYWRtaW4vcmVjbGFtYXRpb25zLyR7cmVjbGFtYXRpb25JZH0vcmVzb2x2ZWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcmVzb2x1dGlvbk5vdGVzLFxuICAgICAgICAgIGFwcHJvdmVkLFxuICAgICAgICB9KSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIHJlc29sdmUgcmVjbGFtYXRpb246ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVqZWN0IHJlY2xhbWF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgcmVqZWN0KHJlY2xhbWF0aW9uSWQ6IG51bWJlciwgcmVqZWN0aW9uTm90ZXM6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJzdWNjZXNzXCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9hZG1pbi9yZWNsYW1hdGlvbnMvJHtyZWNsYW1hdGlvbklkfS9yZWplY3RgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHJlamVjdGlvbk5vdGVzLFxuICAgICAgICB9KSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIHJlamVjdCByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVjbGFtYXRpb24gYXR0YWNobWVudHMgKGltYWdlcylcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBdHRhY2htZW50cyhyZWNsYW1hdGlvbklkOiBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9hZG1pbi9yZWNsYW1hdGlvbnMvJHtyZWNsYW1hdGlvbklkfS9hdHRhY2htZW50c2BcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBhdHRhY2htZW50czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVjbGFtYXRpb24gc3RhdGlzdGljc1xuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXRpc3RpY3MoKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICBvcGVuOiAwLFxuICAgICAgICAgIGluUmV2aWV3OiAwLFxuICAgICAgICAgIHJlc29sdmVkOiAwLFxuICAgICAgICAgIHJlamVjdGVkOiAwLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL2FkbWluL3JlY2xhbWF0aW9ucy9zdGF0aXN0aWNzYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHN0YXRpc3RpY3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuICB9LFxuXG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSBNQVJLRVQgVFJFTkRTID09PT09PT09PT09PT09PT09PT09XG4gIG1hcmtldFRyZW5kczoge1xuICAgIGFzeW5jIGdldEFsbENpdGllcyhwZXJpb2RNb250aHM6IG51bWJlciA9IDEyKSB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSByZXR1cm4geyB0cmVuZHM6IFtdLCBpbnNpZ2h0czogW10gfTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvbWFya2V0LXRyZW5kcy9hbGwtY2l0aWVzP3BlcmlvZF9tb250aHM9JHtwZXJpb2RNb250aHN9YCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0IHRyZW5kc1wiKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSxcbiAgICBhc3luYyBnZXRDaXR5VHJlbmRzKGNpdHk6IHN0cmluZywgcGVyaW9kTW9udGhzOiBudW1iZXIgPSAxMikge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkgcmV0dXJuIHsgZGF0YV9wb2ludHM6IFtdIH07XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL21hcmtldC10cmVuZHMvY2l0eS8ke2NpdHl9P3BlcmlvZF9tb250aHM9JHtwZXJpb2RNb250aHN9YCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCB0cmVuZHMgZm9yICR7Y2l0eX1gKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSxcbiAgICBhc3luYyBnZXRJbnNpZ2h0cyhjaXR5OiBzdHJpbmcpIHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHJldHVybiBbXTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvbWFya2V0LXRyZW5kcy9pbnNpZ2h0cy8ke2NpdHl9YCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBpbnNpZ2h0cyBmb3IgJHtjaXR5fWApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBjb25zdCBhcGlCYXNlVXJsID0gQVBJX0JBU0VfVVJMXG5leHBvcnQgY29uc3QgYXBpVmVyc2lvbiA9IEFQSV9WRVJTSU9OXG4iXSwibmFtZXMiOlsiR0FURVdBWV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfR0FURVdBWV9VUkwiLCJVU0VfR0FURVdBWSIsIk5FWFRfUFVCTElDX1VTRV9HQVRFV0FZIiwiQVBJX0JBU0VfVVJMIiwiTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMIiwiUFJPUEVSVFlfQVBJX0JBU0VfVVJMIiwiTkVYVF9QVUJMSUNfUFJPUEVSVFlfQVBJX0JBU0VfVVJMIiwiQk9PS0lOR19BUElfQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19CT09LSU5HX0FQSV9CQVNFX1VSTCIsIlBBWU1FTlRfQVBJX0JBU0VfVVJMIiwiTkVYVF9QVUJMSUNfUEFZTUVOVF9BUElfQkFTRV9VUkwiLCJSRUNMQU1BVElPTl9BUElfQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19SRUNMQU1BVElPTl9BUElfQkFTRV9VUkwiLCJBUElfVkVSU0lPTiIsIk5FWFRfUFVCTElDX0FQSV9WRVJTSU9OIiwiQVVUSF9UT0tFTl9LRVkiLCJORVhUX1BVQkxJQ19BVVRIX1NUT1JBR0VfS0VZIiwiVVNFUl9EQVRBX0tFWSIsIk5FWFRfUFVCTElDX1VTRVJfU1RPUkFHRV9LRVkiLCJVU0VfTU9DS19BUEkiLCJtb2NrQXBpQ2xpZW50IiwiZ2V0TW9ja0FwaSIsIkVycm9yIiwiZGVjb2RlSldUIiwidG9rZW4iLCJwYXJ0cyIsInNwbGl0IiwibGVuZ3RoIiwicGF5bG9hZCIsImRlY29kZWQiLCJKU09OIiwicGFyc2UiLCJhdG9iIiwicmVwbGFjZSIsInVzZXJJZCIsInN1YiIsInN1YmplY3QiLCJyb2xlcyIsImVycm9yIiwiZ2V0QXV0aEhlYWRlcnMiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidXNlckRhdGEiLCJmaW5hbFVzZXJJZCIsInVzZXIiLCJpZCIsInVzZXJJZFN0cmluZyIsIlN0cmluZyIsImhlYWRlcnMiLCJqb2luIiwiQXV0aG9yaXphdGlvbiIsImdldFNlcnZpY2VVcmwiLCJzZXJ2aWNlIiwiYnVpbGRVcmwiLCJwYXRoIiwiYmFzZVVybCIsInN0YXJ0c1dpdGgiLCJiYXNlUGF0aCIsInJlcXVlc3QiLCJvcHRpb25zIiwicmVxdWlyZXNBdXRoIiwiZmV0Y2hPcHRpb25zIiwidXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiZXJyb3JEYXRhIiwicmVzcG9uc2VUZXh0IiwidGV4dCIsInBhcnNlRXJyb3IiLCJtZXNzYWdlIiwicmF3IiwidGV4dEVycm9yIiwiT2JqZWN0Iiwia2V5cyIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJlcnJvck1lc3NhZ2UiLCJkZXRhaWwiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvcnMiLCJhcGlFcnJvciIsImNvbnRlbnRUeXBlIiwiZ2V0IiwiaW5jbHVkZXMiLCJkYXRhIiwianNvbiIsImNvbm5lY3Rpb25FcnJvciIsImlzQ29ubmVjdGlvbkVycm9yIiwicmVxdWVzdEZvcm1EYXRhIiwiZm9ybURhdGEiLCJtZXRob2QiLCJib2R5IiwiY2F0Y2giLCJhcGlDbGllbnQiLCJwcm9wZXJ0aWVzIiwiZ2V0QWxsIiwibW9jayIsImdldEFsbEZvckFkbWluIiwiYXV0aEhlYWRlcnMiLCJnZXRCeUlkIiwiZ2V0TXlQcm9wZXJ0aWVzIiwiY3JlYXRlIiwiaW1hZ2VzIiwicmVzdWx0IiwicHJvcGVydHlJZCIsIkZvcm1EYXRhIiwiaW5wdXRCbG9iIiwiQmxvYiIsInN0cmluZ2lmeSIsInR5cGUiLCJhcHBlbmQiLCJmb3JFYWNoIiwiZmlsZSIsInVwZGF0ZSIsInBhcnNlZCIsInN1Y2Nlc3MiLCJkZWxldGUiLCJhcHByb3ZlIiwiaXNBcHByb3ZlZCIsImhpZGUiLCJpc0hpZGRlbiIsInN1c3BlbmQiLCJyZWFzb24iLCJyZXZva2VTdXNwZW5zaW9uIiwic3VibWl0Rm9yQXBwcm92YWwiLCJjYW5jZWxBcHByb3ZhbFJlcXVlc3QiLCJwcmVkaWN0UHJpY2UiLCJjaGVja0luRGF0ZSIsImNoZWNrT3V0RGF0ZSIsInByZWRpY3RlZFByaWNlTWFkIiwicHJlZGljdGVkUHJpY2VVc2QiLCJjb25maWRlbmNlSW50ZXJ2YWxMb3dlciIsImNvbmZpZGVuY2VJbnRlcnZhbFVwcGVyIiwiY2l0eSIsInNlYXNvbiIsIm1vZGVsVmVyc2lvbiIsInByZWRpY3Rpb25UaW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjdXJyZW50UHJpY2VNYWQiLCJwcmljZURpZmZlcmVuY2VQZXJjZW50IiwicmVjb21tZW5kYXRpb24iLCJyaXNrIiwiZ2V0VGVuYW50Umlza1Njb3JlIiwidGVuYW50SWQiLCJjb25zb2xlIiwicmVjb21tZW5kYXRpb25zIiwiZ2V0Rm9yVGVuYW50IiwibWF4UmVzdWx0cyIsImdldFNpbWlsYXIiLCJ2ZXJpZmljYXRpb25SZXF1ZXN0cyIsImdldEJ5U3RhdHVzIiwiZGVzY3JpcHRpb24iLCJyZWplY3QiLCJwcm9wZXJ0eVR5cGVzIiwidXNlcnMiLCJnZXRNZSIsImZpcnN0TmFtZSIsImxhc3ROYW1lIiwiZW1haWwiLCJwaG9uZU51bWJlciIsInNjb3JlIiwiYWxsVXNlcnMiLCJmaW5kIiwidSIsInByb2ZpbGVQaWN0dXJlIiwiYmlydGhkYXkiLCJ3YWxsZXRBZGRyZXNzIiwiZW5hYmxlZCIsImVyciIsInVwZGF0ZU1lIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ1cGRhdGVQcm9maWxlUGljdHVyZSIsImNoYW5nZVBhc3N3b3JkIiwiY3VycmVudFBhc3N3b3JkIiwibmV3UGFzc3dvcmQiLCJkZWxldGVQcm9maWxlUGljdHVyZSIsImJlY29tZUhvc3QiLCJlbmFibGVVc2VyIiwiZGlzYWJsZVVzZXIiLCJhZGRBZG1pblJvbGUiLCJyZW1vdmVBZG1pblJvbGUiLCJhZGRIb3N0Um9sZUJ5QWRtaW4iLCJyZW1vdmVIb3N0Um9sZSIsImF1dGgiLCJyZWdpc3RlciIsInNldFRpbWVvdXQiLCJyZXF1ZXN0Qm9keSIsInBhc3N3b3JkIiwicm9sZSIsImxvZ2luIiwic2V0QXV0aCIsInNldEl0ZW0iLCJnZXRUb2tlbiIsImdldFVzZXIiLCJjbGVhckF1dGgiLCJyZW1vdmVJdGVtIiwiaGFzUm9sZSIsInZlcmlmeSIsInZlcmlmaWNhdGlvbkNvZGUiLCJyZXNlbmRWZXJpZmljYXRpb25Db2RlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZm9yZ290UGFzc3dvcmQiLCJ2ZXJpZnlSZXNldFRva2VuIiwidmFsaWQiLCJyZXNldFBhc3N3b3JkIiwidmVyaWZ5UmVzZXRDb2RlIiwiY29kZSIsInJlc2V0UGFzc3dvcmRXaXRoQ29kZSIsImJvb2tpbmdzIiwicGFyc2VJbnQiLCJudW1iZXJPZkd1ZXN0cyIsInJlcXVlc3RlZFByaWNlIiwicmVzcG9uc2VEYXRhIiwiZ2V0QnlUZW5hbnRJZCIsImdldEN1cnJlbnRCb29raW5nIiwiZ2V0UGVuZGluZ0Jvb2tpbmdzIiwiZ2V0QXdhaXRpbmdQYXltZW50Qm9va2luZ3MiLCJnZXRQcm9wZXJ0eUluZm8iLCJvd25lcklkIiwicHJpY2VQZXJOaWdodCIsImlzTmVnb3RpYWJsZSIsImRpc2NvdW50RW5hYmxlZCIsImdldExhc3RCb29raW5nSWQiLCJib29raW5nSWQiLCJlcnJvckNvZGUiLCJ0ZW5hbnRDaGVja291dCIsIm93bmVyQ29uZmlybUNoZWNrb3V0IiwibWFya0FzQ2hlY2tlZE91dCIsImdldEN1cnJlbnRCb29raW5nc0J5T3duZXIiLCJnZXRQZW5kaW5nTmVnb3RpYXRpb25zIiwiYWNjZXB0TmVnb3RpYXRpb24iLCJyZWplY3ROZWdvdGlhdGlvbiIsImdldEJ5T3duZXJJZCIsImdldENvbmZpcm1lZEJvb2tpbmdzQnlPd25lciIsImdldENvbmZpcm1lZEJvb2tpbmdzQnlQcm9wZXJ0eSIsInJlcG9ydERpc3B1dGUiLCJwYXltZW50cyIsImNyZWF0ZUludGVudCIsInJlZmVyZW5jZUlkIiwidG8iLCJ2YWx1ZSIsImNoYWluSWQiLCJ0b3RhbEFtb3VudFdlaSIsImdldEJvb2tpbmdEZXRhaWxzIiwidG90YWxQcmljZSIsInByb3BlcnR5VGl0bGUiLCJwcm9wZXJ0eVByaWNlIiwib3duZXJXYWxsZXRBZGRyZXNzIiwiY3VycmVudFVzZXJJZCIsInVzZXJGaXJzdE5hbWUiLCJ1c2VyTGFzdE5hbWUiLCJ1c2VyRW1haWwiLCJ1c2VyV2FsbGV0QWRkcmVzcyIsImUiLCJ1cGRhdGVXYWxsZXRBZGRyZXNzIiwidXBkYXRlVHJhbnNhY3Rpb25IYXNoIiwidHhIYXNoIiwiZ2V0VHJhbnNhY3Rpb25TdGF0dXMiLCJibG9ja051bWJlciIsImNvbXBsZXRlQm9va2luZyIsImVycm9yVGV4dCIsInJlY2xhbWF0aW9ucyIsImNvbXBsYWluYW50Um9sZSIsInJlY2xhbWF0aW9uVHlwZSIsInRpdGxlIiwiaW1hZ2UiLCJnZXRNeUNvbXBsYWludHMiLCJnZXRDb21wbGFpbnRzQWdhaW5zdE1lIiwidXBsb2FkQXR0YWNobWVudHMiLCJyZWNsYW1hdGlvbklkIiwiZmlsZXMiLCJnZXRCeUJvb2tpbmdJZEFuZENvbXBsYWluYW50IiwiY29tcGxhaW5hbnRJZCIsImdldEF0dGFjaG1lbnRzIiwiZ2V0VXNlclBob25lTnVtYmVyIiwiYWRtaW5SZWNsYW1hdGlvbnMiLCJ1cGRhdGVTZXZlcml0eSIsInNldmVyaXR5IiwicmV2aWV3IiwicmVzb2x1dGlvbk5vdGVzIiwiYXBwcm92ZWQiLCJyZWplY3Rpb25Ob3RlcyIsImdldFN0YXRpc3RpY3MiLCJ0b3RhbCIsIm9wZW4iLCJpblJldmlldyIsInJlc29sdmVkIiwicmVqZWN0ZWQiLCJtYXJrZXRUcmVuZHMiLCJnZXRBbGxDaXRpZXMiLCJwZXJpb2RNb250aHMiLCJ0cmVuZHMiLCJpbnNpZ2h0cyIsImdldENpdHlUcmVuZHMiLCJkYXRhX3BvaW50cyIsImdldEluc2lnaHRzIiwiYXBpQmFzZVVybCIsImFwaVZlcnNpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/services/api.ts\n"));

/***/ })

});