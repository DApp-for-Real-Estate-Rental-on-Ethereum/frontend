"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./lib/services/api.ts":
/*!*****************************!*\
  !*** ./lib/services/api.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiBaseUrl: () => (/* binding */ apiBaseUrl),\n/* harmony export */   apiClient: () => (/* binding */ apiClient),\n/* harmony export */   apiVersion: () => (/* binding */ apiVersion)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n/**\n * API Service Layer\n *\n * Centralized API communication service that handles:\n * - Base URL configuration from environment variables\n * - Authentication headers (X-User-Id, X-User-Roles)\n * - Request/response interceptors\n * - Error handling\n *\n * Usage:\n * import { apiClient } from '@/lib/services/api'\n * const properties = await apiClient.properties.getAll()\n *\n * Environment Variables (in .env.local):\n * - NEXT_PUBLIC_API_BASE_URL: Backend API base URL (e.g., http://localhost:8080)\n * - NEXT_PUBLIC_API_VERSION: API version path (default: v1)\n */ // Configuration from environment variables\n// Use API Gateway (port 8090) as the single entry point for all services\n// If GATEWAY_URL is not set, fall back to individual service URLs for backward compatibility\nconst GATEWAY_URL = process.env.NEXT_PUBLIC_GATEWAY_URL || \"http://localhost:8090\";\nconst USE_GATEWAY = process.env.NEXT_PUBLIC_USE_GATEWAY !== \"false\" // Default to true\n;\n// Fallback URLs for individual services (used if USE_GATEWAY is false)\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || \"http://localhost:8082\";\nconst PROPERTY_API_BASE_URL = process.env.NEXT_PUBLIC_PROPERTY_API_BASE_URL || \"http://localhost:8081\";\nconst BOOKING_API_BASE_URL = USE_GATEWAY ? GATEWAY_URL : process.env.NEXT_PUBLIC_BOOKING_API_BASE_URL || \"http://localhost:8083\";\nconst PAYMENT_API_BASE_URL = USE_GATEWAY ? GATEWAY_URL : process.env.NEXT_PUBLIC_PAYMENT_API_BASE_URL || \"http://localhost:8085\";\nconst RECLAMATION_API_BASE_URL = process.env.NEXT_PUBLIC_RECLAMATION_API_BASE_URL || \"http://localhost:8091\";\nconst API_VERSION = process.env.NEXT_PUBLIC_API_VERSION || \"v1\";\nconst AUTH_TOKEN_KEY = process.env.NEXT_PUBLIC_AUTH_STORAGE_KEY || \"derent5_auth_token\";\nconst USER_DATA_KEY = process.env.NEXT_PUBLIC_USER_STORAGE_KEY || \"derent5_user_data\";\n// USE_MOCK_API is true if explicitly set to \"true\", otherwise false (use real API)\nconst USE_MOCK_API = false // process.env.NEXT_PUBLIC_USE_MOCK_API === \"true\"\n;\n// Only import mock API if needed (tree-shake when not used)\n// let mockApiClient: any = null\nasync function getMockApi() {\n    if (!mockApiClient) {\n        throw new Error(\"Mock API has been removed\");\n    }\n    return mockApiClient;\n}\n/**\n * Decode JWT token to extract userId from subject\n */ function decodeJWT(token) {\n    try {\n        // JWT format: header.payload.signature\n        const parts = token.split(\".\");\n        if (parts.length !== 3) return null;\n        // Decode payload (base64url)\n        const payload = parts[1];\n        const decoded = JSON.parse(atob(payload.replace(/-/g, \"+\").replace(/_/g, \"/\")));\n        return {\n            userId: decoded.sub || decoded.subject,\n            roles: decoded.roles || []\n        };\n    } catch (error) {\n        return null;\n    }\n}\n/**\n * Get authentication headers from localStorage\n * Used for all API requests that require user context\n */ function getAuthHeaders() {\n    // Only run in browser\n    if (false) {}\n    const token = localStorage.getItem(AUTH_TOKEN_KEY);\n    if (!token) {\n        return {};\n    }\n    // Try to get userId from JWT token first\n    const decoded = decodeJWT(token);\n    const userId = decoded?.userId;\n    // Fallback to user data from localStorage\n    const userData = localStorage.getItem(USER_DATA_KEY);\n    let finalUserId = userId;\n    let roles = decoded?.roles || [];\n    if (userData) {\n        try {\n            const user = JSON.parse(userData);\n            finalUserId = finalUserId || user.id || \"\";\n            roles = roles.length > 0 ? roles : user.roles || [];\n        } catch (error) {\n        // Failed to parse user data\n        }\n    }\n    // Ensure userId is always a string (convert number to string if needed)\n    const userIdString = finalUserId ? String(finalUserId) : \"\";\n    const headers = {\n        \"X-User-Id\": userIdString,\n        \"X-User-Roles\": roles.join(\",\"),\n        ...token && {\n            Authorization: `Bearer ${token}`\n        }\n    };\n    return headers;\n}\n/**\n * Helper function to get the correct base URL for a service\n * Uses Gateway if enabled, otherwise falls back to individual service URLs\n */ function getServiceUrl(service) {\n    if (USE_GATEWAY) {\n        // All services go through the Gateway\n        return GATEWAY_URL;\n    }\n    // Fallback to individual service URLs\n    switch(service){\n        case 'auth':\n        case 'users':\n            return API_BASE_URL;\n        case 'properties':\n            return PROPERTY_API_BASE_URL;\n        case 'bookings':\n            return BOOKING_API_BASE_URL;\n        case 'payments':\n            return PAYMENT_API_BASE_URL;\n        case 'reclamations':\n        case 'admin-reclamations':\n            return RECLAMATION_API_BASE_URL;\n        default:\n            return API_BASE_URL;\n    }\n}\n/**\n * Build full URL with base and version\n * For Gateway, path already includes /api/v1/..., so we don't add it again\n */ function buildUrl(path, service = 'users') {\n    const baseUrl = getServiceUrl(service);\n    if (USE_GATEWAY) {\n        // Gateway routes preserve the full path\n        // Path should already include /api/v1/... or /api/... prefix\n        // If path doesn't start with /api, add the appropriate prefix based on service\n        if (path.startsWith('/api/')) {\n            return `${baseUrl}${path}`;\n        }\n        // Add appropriate prefix based on service\n        if (service === 'auth' || service === 'users') {\n            return `${baseUrl}/api/v1${path}`;\n        } else if (service === 'properties') {\n            return `${baseUrl}/api/v1${path}`;\n        } else if (service === 'bookings') {\n            return `${baseUrl}/api${path}`;\n        } else if (service === 'payments') {\n            return `${baseUrl}/api${path}`;\n        } else if (service === 'reclamations' || service === 'admin-reclamations') {\n            return `${baseUrl}/api${path}`;\n        }\n        return `${baseUrl}${path}`;\n    }\n    // For direct service calls, add version prefix\n    const basePath = `/api/${API_VERSION}`;\n    return `${baseUrl}${basePath}${path}`;\n}\n/**\n * Generic fetch wrapper with error handling\n */ async function request(path, options = {}) {\n    const { requiresAuth = true, service = 'users', ...fetchOptions } = options;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        ...requiresAuth && getAuthHeaders(),\n        ...fetchOptions.headers\n    };\n    const url = buildUrl(path, service);\n    try {\n        const response = await fetch(url, {\n            ...fetchOptions,\n            headers\n        });\n        if (!response.ok) {\n            let errorData = {};\n            let responseText = \"\";\n            try {\n                responseText = await response.text();\n                if (responseText) {\n                    try {\n                        errorData = JSON.parse(responseText);\n                    } catch (parseError) {\n                        // If JSON parsing fails, use the raw text\n                        errorData = {\n                            message: responseText,\n                            raw: responseText\n                        };\n                    }\n                }\n            } catch (textError) {\n                errorData = {\n                    message: `Failed to read response: ${textError}`\n                };\n            }\n            // If errorData is still empty, create a default error\n            if (Object.keys(errorData).length === 0) {\n                errorData = {\n                    message: `HTTP ${response.status}: ${response.statusText}`,\n                    status: response.status,\n                    statusText: response.statusText\n                };\n            }\n            // Extract error message from ErrorResponse format (used by user-service)\n            // ErrorResponse has: timestamp, status, error, message, path\n            const errorMessage = errorData.message || // ErrorResponse.message\n            errorData.error || // ErrorResponse.error (error title)\n            errorData.detail || // Standard Spring error format\n            errorData.raw || // Raw response text if JSON parsing failed\n            (Array.isArray(errorData.errors) ? errorData.errors.join(\", \") : null) || // Validation errors array\n            (typeof errorData === 'string' ? errorData : null) || `API Error: ${response.status} ${response.statusText}`;\n            const apiError = new Error(errorMessage);\n            apiError.status = response.status;\n            apiError.errorData = errorData;\n            apiError.responseText = responseText;\n            throw apiError;\n        }\n        // Check if response has content\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.includes(\"application/json\")) {\n            const data = await response.json();\n            return data;\n        } else {\n            // If no JSON content, return empty object for successful responses\n            const text = await response.text();\n            if (text) {\n                // Try to parse as JSON, if fails return text as message\n                try {\n                    return JSON.parse(text);\n                } catch  {\n                    return {\n                        message: text\n                    };\n                }\n            }\n            return {};\n        }\n    } catch (error) {\n        // Check if it's a connection error\n        if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n            const connectionError = new Error(`Cannot connect to backend server at ${API_BASE_URL}. Please make sure the backend is running.`);\n            connectionError.isConnectionError = true;\n            throw connectionError;\n        }\n        throw error;\n    }\n}\n/**\n * Multipart form data request for file uploads\n */ async function requestFormData(path, formData, options = {}) {\n    const { requiresAuth = true, service = 'users', ...fetchOptions } = options;\n    const headers = {\n        ...requiresAuth && getAuthHeaders(),\n        ...fetchOptions.headers\n    };\n    // Don't set Content-Type for FormData - browser will set it with boundary\n    delete headers[\"Content-Type\"];\n    const url = buildUrl(path, service);\n    try {\n        const response = await fetch(url, {\n            method: \"POST\",\n            ...fetchOptions,\n            headers,\n            body: formData\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(errorData.message || `API Error: ${response.status}`);\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        throw error;\n    }\n}\n/**\n * API Client - Organized by resource\n */ const apiClient = {\n    // ==================== PROPERTIES ====================\n    properties: {\n        async getAll () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getAll();\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async getAllForAdmin () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getAll();\n            }\n            // Use Gateway or property-service URL for admin endpoint\n            const url = buildUrl(\"/properties/admin/all\", 'properties');\n            const authHeaders = getAuthHeaders();\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...authHeaders\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    const errorMessage = errorData.error || errorData.message || `API Error: ${response.status}`;\n                    throw new Error(errorMessage);\n                }\n                const data = await response.json();\n                // Ensure data is an array\n                if (!Array.isArray(data)) {\n                    // If it's an error object, throw it\n                    if (data.error || data.message) {\n                        throw new Error(data.error || data.message || \"Invalid response format\");\n                    }\n                    // Otherwise return empty array\n                    return [];\n                }\n                return data;\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async getById (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getById(id);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async getMyProperties () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getAll();\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/my-properties`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    const errorMessage = errorData.error || errorData.message || `API Error: ${response.status}`;\n                    throw new Error(errorMessage);\n                }\n                const data = await response.json();\n                // Ensure data is an array\n                if (!Array.isArray(data)) {\n                    // If it's an error object, throw it\n                    if (data.error || data.message) {\n                        throw new Error(data.error || data.message || \"Invalid response format\");\n                    }\n                    // Otherwise return empty array\n                    return [];\n                }\n                return data;\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async create (data, images) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                const result = await mock.properties.create(data, images);\n                return {\n                    propertyId: result.id,\n                    id: result.id\n                };\n            }\n            const formData = new FormData();\n            // Create a Blob with JSON content type for the input part\n            // Spring's @RequestPart expects Content-Type: application/json for JSON parts\n            const inputBlob = new Blob([\n                JSON.stringify(data)\n            ], {\n                type: \"application/json\"\n            });\n            formData.append(\"input\", inputBlob);\n            images.forEach((file)=>{\n                formData.append(\"images\", file);\n            });\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties`;\n            const headers = {\n                ...getAuthHeaders()\n            };\n            // Don't set Content-Type header - let browser set it with boundary for multipart/form-data\n            try {\n                const response = await fetch(url, {\n                    method: \"POST\",\n                    headers,\n                    body: formData\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                const result = await response.json();\n                return result;\n            } catch (error) {\n                throw error;\n            }\n        },\n        async update (id, data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.update(id, data);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PUT\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify(data)\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                // Backend returns \"Property updated\" as plain text, not JSON\n                const responseText = await response.text();\n                try {\n                    const parsed = JSON.parse(responseText);\n                    return parsed;\n                } catch  {\n                    // If it's not JSON, return success object\n                    return {\n                        success: true\n                    };\n                }\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async delete (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.delete(id);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"DELETE\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async approve (id, isApproved) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.approve(id, isApproved);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/approve`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify({\n                        isApproved\n                    })\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        /**\n     * Hide property\n     */ async hide (id, isHidden) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return {\n                    success: true\n                };\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/hide`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify({\n                        isHidden\n                    })\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async suspend (id, reason) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.suspend(id, reason);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/suspend`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify({\n                        reason\n                    })\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async revokeSuspension (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.suspend(id, \"\") // Mock\n                ;\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/revoke-suspension`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async submitForApproval (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.approve(id, true);\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/submit-for-approval`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async cancelApprovalRequest (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return {\n                    success: true\n                };\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/cancel-approval-request`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        /**\n     * Get AI-powered price suggestion for a property and date range.\n     * This calls property-service, which forwards the request to the pricing model API.\n     */ async predictPrice (propertyId, checkInDate, checkOutDate) {\n            if (USE_MOCK_API) {\n                // Lightweight mock for UI development\n                return {\n                    predictedPriceMad: 430,\n                    predictedPriceUsd: 43,\n                    confidenceIntervalLower: 380,\n                    confidenceIntervalUpper: 480,\n                    city: \"casablanca\",\n                    season: \"summer\",\n                    modelVersion: \"1.0\",\n                    predictionTimestamp: new Date().toISOString(),\n                    currentPriceMad: 400,\n                    priceDifferencePercent: 7.5,\n                    recommendation: \"INCREASE\"\n                };\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${propertyId}/predict-price`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    propertyId,\n                    checkInDate,\n                    checkOutDate\n                })\n            });\n            const data = await response.json().catch(()=>({}));\n            if (!response.ok) {\n                const message = data?.message || data?.error || (typeof data === \"string\" ? data : null) || `Failed to get price suggestion: ${response.status}`;\n                throw new Error(message);\n            }\n            return data;\n        }\n    },\n    // ==================== TENANT RISK ====================\n    risk: {\n        getTenantRiskScore: async (tenantId)=>{\n            try {\n                // Use local Next.js proxy\n                const response = await fetch(`/api/tenant-risk/${tenantId}`, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    }\n                });\n                if (!response.ok) {\n                    throw new Error(`ML API Error: ${response.status} ${response.statusText}`);\n                }\n                return response.json();\n            } catch (error) {\n                console.error(\"Error fetching risk score:\", error);\n                throw error;\n            }\n        }\n    },\n    recommendations: {\n        getForTenant: async (tenantId, maxResults = 3)=>{\n            try {\n                const response = await fetch(`/api/recommendations/tenant/${tenantId}?max_results=${maxResults}`);\n                if (!response.ok) throw new Error(\"Failed to fetch recommendations\");\n                return response.json();\n            } catch (error) {\n                console.error(\"Error fetching recommendations:\", error);\n                throw error;\n            }\n        },\n        getSimilar: async (propertyId, maxResults = 3)=>{\n            try {\n                const response = await fetch(`/api/recommendations/similar/${propertyId}?max_results=${maxResults}`);\n                if (!response.ok) throw new Error(\"Failed to fetch similar properties\");\n                return response.json();\n            } catch (error) {\n                console.error(\"Error fetching similar properties:\", error);\n                throw error;\n            }\n        }\n    },\n    // ==================== VERIFICATION REQUESTS ====================\n    verificationRequests: {\n        async getAll () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.getAll();\n            }\n            return request(\"/verification-requests\");\n        },\n        async getByStatus (status) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.getByStatus(status);\n            }\n            return request(`/verification-requests/by-status/${status}`);\n        },\n        async create (propertyId, description) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.create(propertyId, description);\n            }\n            return request(\"/verification-requests\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    propertyId,\n                    description\n                })\n            });\n        },\n        async approve (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.approve(id);\n            }\n            return request(`/verification-requests/${id}/approve`, {\n                method: \"PATCH\"\n            });\n        },\n        async reject (id, reason) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.reject(id, reason);\n            }\n            return request(`/verification-requests/${id}/reject`, {\n                method: \"PATCH\",\n                body: JSON.stringify({\n                    reason\n                })\n            });\n        }\n    },\n    // ==================== PROPERTY TYPES ====================\n    propertyTypes: {\n        async getAll () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.propertyTypes.getAll();\n            }\n            return request(\"/property-types\", {\n                requiresAuth: false\n            });\n        },\n        async getById (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.propertyTypes.getById(id);\n            }\n            return request(`/property-types/${id}`, {\n                requiresAuth: false\n            });\n        }\n    },\n    // ==================== USERS ====================\n    users: {\n        async getMe () {\n            if (USE_MOCK_API) {\n                // Mock user data for development\n                return {\n                    firstName: \"Mock\",\n                    lastName: \"User\",\n                    email: \"mock@example.com\"\n                };\n            }\n            return request(\"/users/me\", {\n                method: \"GET\",\n                requiresAuth: true\n            });\n        },\n        /**\n     * Get user information by ID (for getting phone number, etc.)\n     */ async getById (userId) {\n            if (USE_MOCK_API) {\n                return {\n                    firstName: \"Mock\",\n                    lastName: \"User\",\n                    email: \"mock@example.com\",\n                    phoneNumber: 1234567890,\n                    score: 100\n                };\n            }\n            // Try to get from admin endpoint first (if user is admin) for more details\n            try {\n                const allUsers = await this.getAllForAdmin();\n                const user = allUsers.find((u)=>String(u.id) === String(userId));\n                if (user) {\n                    return {\n                        firstName: user.firstName,\n                        lastName: user.lastName,\n                        email: user.email,\n                        profilePicture: user.profilePicture,\n                        birthday: user.birthday,\n                        phoneNumber: user.phoneNumber,\n                        walletAddress: user.walletAddress,\n                        roles: user.roles,\n                        score: user.score,\n                        enabled: user.enabled\n                    };\n                }\n            } catch (err) {\n            // If admin endpoint fails, fallback to regular endpoint\n            }\n            // Fallback to regular endpoint\n            return request(`/users/${userId}`, {\n                method: \"GET\",\n                requiresAuth: true\n            });\n        },\n        async updateMe (data) {\n            if (USE_MOCK_API) {\n                // Mock update\n                return Promise.resolve();\n            }\n            return request(\"/users/me\", {\n                method: \"PUT\",\n                body: JSON.stringify(data),\n                requiresAuth: true\n            });\n        },\n        async updateProfilePicture (file) {\n            if (USE_MOCK_API) {\n                return {\n                    url: \"/placeholder-user.jpg\"\n                };\n            }\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            const headers = getAuthHeaders();\n            // Remove Content-Type header to let browser set it with boundary for multipart/form-data\n            delete headers[\"Content-Type\"];\n            const url = buildUrl(\"/users/me/profile-picture\");\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers,\n                body: formData\n            });\n            if (!response.ok) {\n                let errorData = {};\n                let responseText = \"\";\n                try {\n                    responseText = await response.text();\n                    if (responseText) {\n                        try {\n                            errorData = JSON.parse(responseText);\n                        } catch  {\n                            errorData = {\n                                message: responseText,\n                                raw: responseText\n                            };\n                        }\n                    }\n                } catch  {\n                    errorData = {\n                        message: `HTTP ${response.status}: ${response.statusText}`\n                    };\n                }\n                const errorMessage = errorData.message || errorData.error || errorData.raw || `API Error: ${response.status} ${response.statusText}`;\n                const apiError = new Error(errorMessage);\n                apiError.status = response.status;\n                apiError.errorData = errorData;\n                throw apiError;\n            }\n            const text = await response.text();\n            return {\n                url: text\n            } // Backend returns URL as plain text\n            ;\n        },\n        async changePassword (currentPassword, newPassword) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Password changed successfully\"\n                };\n            }\n            return request(\"/users/me/change-password\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    currentPassword,\n                    newPassword\n                })\n            });\n        },\n        async deleteProfilePicture () {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(\"/users/me/profile-picture\", {\n                method: \"DELETE\",\n                requiresAuth: true\n            });\n        },\n        async becomeHost () {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(\"/users/me/become-host\", {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async getAllForAdmin () {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            return request(\"/users/admin/all\", {\n                method: \"GET\",\n                requiresAuth: true\n            });\n        },\n        async enableUser (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/enable`, {\n                method: \"POST\",\n                body: JSON.stringify({}),\n                requiresAuth: true\n            });\n        },\n        async disableUser (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/disable`, {\n                method: \"POST\",\n                body: JSON.stringify({}),\n                requiresAuth: true\n            });\n        },\n        async addAdminRole (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/add-admin-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async removeAdminRole (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/remove-admin-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async addHostRoleByAdmin (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/add-host-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async removeHostRole (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/remove-host-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        }\n    },\n    // ==================== AUTHENTICATION ====================\n    auth: {\n        async register (data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                // Mock registration - simulate delay\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"User registered successfully\"\n                };\n            }\n            try {\n                const requestBody = {\n                    firstName: data.firstName,\n                    lastName: data.lastName,\n                    email: data.email,\n                    password: data.password,\n                    birthday: data.birthday,\n                    phoneNumber: data.phoneNumber,\n                    ...data.role && {\n                        role: data.role\n                    }\n                };\n                return await request(\"/auth/register\", {\n                    method: \"POST\",\n                    body: JSON.stringify(requestBody),\n                    requiresAuth: false\n                });\n            } catch (error) {\n                // If connection fails, throw with helpful message\n                if (error?.isConnectionError) {\n                    throw new Error(\"Backend server is not available. Please make sure the user-service is running on port 8080.\");\n                }\n                throw error;\n            }\n        },\n        async login (email, password) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                // Mock login - would use mock data\n                throw new Error(\"Mock login not implemented - use useAuth hook\");\n            }\n            return request(\"/auth/login\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    password\n                }),\n                requiresAuth: false\n            });\n        },\n        setAuth (token, user) {\n            if (true) {\n                localStorage.setItem(AUTH_TOKEN_KEY, token);\n                localStorage.setItem(USER_DATA_KEY, JSON.stringify(user));\n            }\n        },\n        getToken () {\n            if (false) {}\n            return localStorage.getItem(AUTH_TOKEN_KEY);\n        },\n        getUser () {\n            if (false) {}\n            const userData = localStorage.getItem(USER_DATA_KEY);\n            return userData ? JSON.parse(userData) : null;\n        },\n        clearAuth () {\n            if (true) {\n                localStorage.removeItem(AUTH_TOKEN_KEY);\n                localStorage.removeItem(USER_DATA_KEY);\n            }\n        },\n        hasRole (role) {\n            const user = this.getUser();\n            return user?.roles.includes(role) ?? false;\n        },\n        async verify (email, verificationCode) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"User verified successfully\"\n                };\n            }\n            return request(\"/auth/verify\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    verificationCode\n                }),\n                requiresAuth: false\n            });\n        },\n        async resendVerificationCode (email) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"Verification Code resent successfully\"\n                };\n            }\n            return request(`/auth/resend?email=${encodeURIComponent(email)}`, {\n                method: \"POST\",\n                requiresAuth: false\n            });\n        },\n        async forgotPassword (email) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return;\n            }\n            return request(\"/auth/forgot-password\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email\n                }),\n                requiresAuth: false\n            });\n        },\n        async verifyResetToken (token) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    valid: true\n                };\n            }\n            return request(\"/auth/verify-reset-token\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    token\n                }),\n                requiresAuth: false\n            });\n        },\n        async resetPassword (token, password) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return;\n            }\n            return request(\"/auth/reset-password\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    token,\n                    password\n                }),\n                requiresAuth: false\n            });\n        },\n        async verifyResetCode (email, code) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    valid: true\n                };\n            }\n            return request(\"/auth/verify-reset-code\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    code\n                }),\n                requiresAuth: false\n            });\n        },\n        async resetPasswordWithCode (email, code, newPassword) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"Password reset successfully\"\n                };\n            }\n            return request(\"/auth/reset-password-with-code\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    code,\n                    newPassword\n                }),\n                requiresAuth: false\n            });\n        }\n    },\n    bookings: {\n        /**\n     * Get all bookings for admin\n     */ async getAllForAdmin () {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/admin/all`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `Failed to fetch bookings: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n                    const connectionError = new Error(`Cannot connect to booking-service backend at ${BOOKING_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        /**\n     * Create a booking request\n     * Sends booking data to booking-service via RabbitMQ\n     */ async create (data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.create?.(data) || {\n                    status: \"accepted\",\n                    message: \"Booking request sent\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/request`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    userId: typeof data.userId === \"string\" ? parseInt(data.userId) : data.userId,\n                    propertyId: data.propertyId,\n                    checkInDate: data.checkInDate,\n                    checkOutDate: data.checkOutDate,\n                    numberOfGuests: data.numberOfGuests,\n                    requestedPrice: data.requestedPrice\n                })\n            });\n            const responseData = await response.json();\n            if (!response.ok) {\n                // If status is \"rejected\", return the response data instead of throwing\n                if (responseData.status === \"rejected\") {\n                    return responseData;\n                }\n                throw new Error(responseData.message || `Failed to create booking: ${response.status}`);\n            }\n            return responseData;\n        },\n        /**\n     * Get booking by ID\n     */ async getById (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.getById?.(id) || null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                if (response.status === 404) {\n                    return null;\n                }\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch booking: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get bookings by tenant ID\n     */ async getByTenantId (tenantId) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.getByTenantId?.(tenantId) || [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings?tenantId=${tenantId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get current booking for a user\n     */ async getCurrentBooking (userId) {\n            if (USE_MOCK_API) {\n                // Mock: return null for now (no current booking)\n                return null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/current?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (response.status === 204 || response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch current booking: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get pending bookings (negotiations) for a user\n     */ async getPendingBookings (userId) {\n            if (USE_MOCK_API) {\n                // Mock: return empty array\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/pending?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch pending bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get awaiting payment bookings for a user\n     */ async getAwaitingPaymentBookings (userId) {\n            if (USE_MOCK_API) {\n                // Mock: return empty array\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/payment?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch awaiting payment bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get property info for booking (price, discount, negotiation)\n     */ async getPropertyInfo (propertyId) {\n            if (USE_MOCK_API) {\n                // Mock property info\n                return {\n                    id: propertyId,\n                    ownerId: 1,\n                    pricePerNight: 100,\n                    isNegotiable: false,\n                    discountEnabled: false\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/property/${propertyId}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to booking-service backend at ${BOOKING_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        /**\n     * Get last booking ID (for polling after creation)\n     */ async getLastBookingId () {\n            if (USE_MOCK_API) {\n                return {\n                    bookingId: 1\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/booking-id`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n            if (response.status === 204 || response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                return null;\n            }\n            return response.json();\n        },\n        /**\n     * Update a booking\n     */ async update (id, data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.update?.(id, data) || null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    checkInDate: data.checkInDate,\n                    checkOutDate: data.checkOutDate,\n                    numberOfGuests: data.numberOfGuests,\n                    requestedPrice: data.requestedPrice\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                const errorMessage = errorData.message || errorData.error || `Failed to update booking: ${response.status}`;\n                const error = new Error(errorMessage);\n                error.status = response.status;\n                error.errorCode = errorData.error;\n                throw error;\n            }\n            const result = await response.json();\n            return result;\n        },\n        /**\n     * Delete/Cancel a booking (by tenant)\n     */ async delete (id, userId) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.delete?.(id, userId);\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"DELETE\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to cancel booking: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Tenant checkout (changes status to TENANT_CHECKED_OUT)\n     */ async tenantCheckout (id, tenantId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Tenant checked out successfully\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}/checkout/tenant?userId=${tenantId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to checkout: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Owner confirm checkout (changes status to COMPLETED)\n     */ async ownerConfirmCheckout (id, ownerId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Checkout confirmed successfully\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}/checkout/owner?userId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to confirm checkout: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * @deprecated Use tenantCheckout() or ownerConfirmCheckout() instead\n     */ async markAsCheckedOut (id, userId) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.markAsCheckedOut?.(id, userId) || null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}/checkout?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to mark as checked out: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get current bookings by owner (host)\n     */ async getCurrentBookingsByOwner (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/current/owner?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch current bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get pending negotiations by owner (host)\n     */ async getPendingNegotiations (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/negotiations?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch pending negotiations: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Accept negotiation (host)\n     */ async acceptNegotiation (bookingId, ownerId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Negotiation accepted\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${bookingId}/accept?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to accept negotiation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Reject negotiation (host)\n     */ async rejectNegotiation (bookingId, ownerId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Negotiation rejected\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${bookingId}/reject?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to reject negotiation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get all bookings by owner (host)\n     */ async getByOwnerId (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get confirmed bookings by owner (host)\n     */ async getConfirmedBookingsByOwner (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/confirmed/owner?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch confirmed bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get confirmed bookings by property ID\n     */ async getConfirmedBookingsByProperty (propertyId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/confirmed/property/${propertyId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch confirmed bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Report dispute (host or tenant)\n     */ async reportDispute (bookingId, userId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Dispute reported\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${bookingId}/dispute?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to report dispute: ${response.status}`);\n            }\n            return response.json();\n        }\n    },\n    /**\n   * Payment Service API\n   */ payments: {\n        /**\n     * Create payment intent\n     */ async createIntent (bookingId) {\n            if (USE_MOCK_API) {\n                return {\n                    referenceId: \"mock-ref-id\",\n                    to: \"0x1234567890123456789012345678901234567890\",\n                    value: \"1000000000000000000\",\n                    data: null,\n                    chainId: 31337,\n                    totalAmountWei: \"1000000000000000000\"\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/intent`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    bookingId\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to create payment intent: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get booking details for payment\n     */ async getBookingDetails (bookingId) {\n            if (USE_MOCK_API) {\n                return {\n                    bookingId,\n                    status: \"PENDING_PAYMENT\",\n                    totalPrice: 100.0,\n                    checkInDate: \"2025-12-01\",\n                    checkOutDate: \"2025-12-05\",\n                    propertyId: 1,\n                    propertyTitle: \"Mock Property\",\n                    propertyPrice: 20.0,\n                    ownerWalletAddress: \"0x1234567890123456789012345678901234567890\",\n                    userId: 1,\n                    currentUserId: 1,\n                    userFirstName: \"John\",\n                    userLastName: \"Doe\",\n                    userEmail: \"john@example.com\",\n                    userWalletAddress: null\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/booking/${bookingId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                let errorMessage = `Failed to fetch booking details: ${response.status}`;\n                try {\n                    const errorData = await response.json();\n                    // Backend returns { code, message } format\n                    errorMessage = errorData.message || errorData.code || errorMessage;\n                } catch (e) {\n                    // If response is not JSON, use status text\n                    errorMessage = response.statusText || errorMessage;\n                }\n                throw new Error(errorMessage);\n            }\n            return response.json();\n        },\n        /**\n     * Update wallet address\n     */ async updateWalletAddress (userId, walletAddress) {\n            if (USE_MOCK_API) {\n                return;\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/wallet-address`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    userId,\n                    walletAddress\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update wallet address: ${response.status}`);\n            }\n        },\n        /**\n     * Update transaction hash\n     */ async updateTransactionHash (bookingId, txHash) {\n            if (USE_MOCK_API) {\n                return;\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/booking/${bookingId}/tx-hash`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    txHash\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update transaction hash: ${response.status}`);\n            }\n        },\n        // Date modification removed - dates can only be changed from booking-service\n        /**\n     * Get transaction status\n     */ async getTransactionStatus (txHash) {\n            if (USE_MOCK_API) {\n                return {\n                    txHash,\n                    status: \"PENDING\",\n                    blockNumber: null,\n                    bookingId: null\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/tx/${txHash}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch transaction status: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Complete booking on blockchain (called by host when confirming checkout)\n     */ async completeBooking (bookingId) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\",\n                    message: \"Booking completed successfully on blockchain\"\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/booking/${bookingId}/complete`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                let errorData = {};\n                let errorText = \"\";\n                try {\n                    errorText = await response.text();\n                    if (errorText) {\n                        try {\n                            errorData = JSON.parse(errorText);\n                        } catch  {\n                            errorData = {\n                                message: errorText\n                            };\n                        }\n                    }\n                } catch (e) {\n                    // If response is not JSON, use status text\n                    errorData = {\n                        message: response.statusText || `Server error: ${response.status}`\n                    };\n                }\n                const errorMessage = errorData.message || errorData.error || errorText || `Failed to complete booking: ${response.status}`;\n                throw new Error(errorMessage);\n            }\n            return response.json();\n        }\n    },\n    // ==================== RECLAMATIONS ====================\n    reclamations: {\n        /**\n     * Create a reclamation for a booking\n     */ async create (bookingId, userId, complainantRole, reclamationType, title, description, images) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\",\n                    message: \"Reclamation created successfully\"\n                };\n            }\n            // Use reclamation-service directly to support images\n            const formData = new FormData();\n            formData.append(\"bookingId\", String(bookingId));\n            formData.append(\"userId\", String(userId));\n            formData.append(\"complainantRole\", complainantRole);\n            formData.append(\"reclamationType\", reclamationType);\n            if (title) formData.append(\"title\", title);\n            if (description) formData.append(\"description\", description);\n            if (images && images.length > 0) {\n                images.forEach((image)=>{\n                    formData.append(\"files\", image);\n                });\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/create`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    ...getAuthHeaders()\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to create reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get all reclamations by complainant ID (my complaints)\n     */ async getMyComplaints (userId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/my-complaints?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch complaints: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get all reclamations against a user (complaints against me)\n     */ async getComplaintsAgainstMe (userId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/against-me?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch complaints: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Upload attachments (images) for a reclamation\n     */ async uploadAttachments (reclamationId, files) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const formData = new FormData();\n            files.forEach((file)=>{\n                formData.append(\"files\", file);\n            });\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}/attachments`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    ...getAuthHeaders()\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to upload attachments: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation by booking ID and complainant ID\n     */ async getByBookingIdAndComplainant (bookingId, complainantId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/booking/${bookingId}/complainant/${complainantId}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                // 404 is expected when no reclamation exists - return null silently\n                if (response.status === 404) {\n                    return null;\n                }\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `Failed to fetch reclamation: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                // Silently handle 404 errors (no reclamation exists - this is normal)\n                if (error.message?.includes(\"404\") || error.message?.includes(\"Not Found\")) {\n                    return null;\n                }\n                throw error;\n            }\n        },\n        /**\n     * Get reclamation by ID\n     */ async getById (reclamationId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation attachments (images)\n     */ async getAttachments (reclamationId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}/attachments`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch attachments: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Delete a reclamation\n     */ async delete (reclamationId, userId) {\n            if (USE_MOCK_API) {\n                return;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"DELETE\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to delete reclamation: ${response.status}`);\n            }\n        },\n        /**\n     * Update a reclamation (title, description, images)\n     */ async update (reclamationId, userId, title, description, images) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\",\n                    message: \"Reclamation updated successfully\"\n                };\n            }\n            const formData = new FormData();\n            formData.append(\"userId\", String(userId));\n            if (title) formData.append(\"title\", title);\n            if (description) formData.append(\"description\", description);\n            if (images && images.length > 0) {\n                images.forEach((image)=>{\n                    formData.append(\"files\", image);\n                });\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    ...getAuthHeaders()\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get user phone number\n     */ async getUserPhoneNumber (userId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/user/${userId}/phone`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch phone number: ${response.status}`);\n            }\n            const data = await response.json();\n            return data.phoneNumber || null;\n        }\n    },\n    // ==================== ADMIN RECLAMATIONS ====================\n    adminReclamations: {\n        /**\n     * Get all reclamations (admin only)\n     */ async getAll () {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamations: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamations by status\n     */ async getByStatus (status) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/status/${status}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamations: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation by ID\n     */ async getById (reclamationId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Update reclamation severity\n     */ async updateSeverity (reclamationId, severity) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/severity?severity=${severity}`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update severity: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Review reclamation (move to IN_REVIEW)\n     */ async review (reclamationId) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/review`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to review reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Resolve reclamation with penalty\n     */ async resolve (reclamationId, resolutionNotes, approved) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/resolve`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    resolutionNotes,\n                    approved\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to resolve reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Reject reclamation\n     */ async reject (reclamationId, rejectionNotes) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/reject`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    rejectionNotes\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to reject reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation attachments (images)\n     */ async getAttachments (reclamationId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/attachments`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch attachments: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation statistics\n     */ async getStatistics () {\n            if (USE_MOCK_API) {\n                return {\n                    total: 0,\n                    open: 0,\n                    inReview: 0,\n                    resolved: 0,\n                    rejected: 0\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/statistics`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch statistics: ${response.status}`);\n            }\n            return response.json();\n        }\n    },\n    // ==================== MARKET TRENDS ====================\n    marketTrends: {\n        async getAllCities (periodMonths = 12) {\n            if (USE_MOCK_API) return {\n                trends: [],\n                insights: []\n            };\n            const response = await fetch(`/api/market-trends/all-cities?period_months=${periodMonths}`);\n            if (!response.ok) throw new Error(\"Failed to fetch market trends\");\n            return response.json();\n        },\n        async getCityTrends (city, periodMonths = 12) {\n            if (USE_MOCK_API) return {\n                data_points: []\n            };\n            const response = await fetch(`/api/market-trends/city/${city}?period_months=${periodMonths}`);\n            if (!response.ok) throw new Error(`Failed to fetch trends for ${city}`);\n            return response.json();\n        },\n        async getInsights (city) {\n            if (USE_MOCK_API) return [];\n            const response = await fetch(`/api/market-trends/insights/${city}`);\n            if (!response.ok) throw new Error(`Failed to fetch insights for ${city}`);\n            return response.json();\n        }\n    }\n};\nconst apiBaseUrl = API_BASE_URL;\nconst apiVersion = API_VERSION;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zZXJ2aWNlcy9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBYUQsMkNBQTJDO0FBQzNDLHlFQUF5RTtBQUN6RSw2RkFBNkY7QUFDN0YsTUFBTUEsY0FBY0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyx1QkFBdUIsSUFBSTtBQUMzRCxNQUFNQyxjQUFjSCxPQUFPQSxDQUFDQyxHQUFHLENBQUNHLHVCQUF1QixLQUFLLFFBQVEsa0JBQWtCOztBQUV0Rix1RUFBdUU7QUFDdkUsTUFBTUMsZUFBZUwsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDSyx3QkFBd0IsSUFBSTtBQUM3RCxNQUFNQyx3QkFBd0JQLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ08saUNBQWlDLElBQUk7QUFDL0UsTUFBTUMsdUJBQXVCTixjQUN6QkosY0FDQ0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDUyxnQ0FBZ0MsSUFBSTtBQUNyRCxNQUFNQyx1QkFBdUJSLGNBQ3pCSixjQUNDQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNXLGdDQUFnQyxJQUFJO0FBQ3JELE1BQU1DLDJCQUEyQmIsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDYSxvQ0FBb0MsSUFBSTtBQUNyRixNQUFNQyxjQUFjZixPQUFPQSxDQUFDQyxHQUFHLENBQUNlLHVCQUF1QixJQUFJO0FBQzNELE1BQU1DLGlCQUFpQmpCLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ2lCLDRCQUE0QixJQUFJO0FBQ25FLE1BQU1DLGdCQUFnQm5CLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ21CLDRCQUE0QixJQUFJO0FBQ2xFLG1GQUFtRjtBQUNuRixNQUFNQyxlQUFlLE1BQU0sa0RBQWtEOztBQUU3RSw0REFBNEQ7QUFDNUQsZ0NBQWdDO0FBRWhDLGVBQWVDO0lBQ2IsSUFBSSxDQUFDQyxlQUFlO1FBQ2xCLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUNBLE9BQU9EO0FBQ1Q7QUFFQTs7Q0FF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LElBQUksQ0FBQ3hFLFNBQVNFLEVBQUUsRUFBRSxNQUFNLElBQUkzQyxNQUFNLENBQUMsNkJBQTZCLEVBQUVpSCxNQUFNO1lBQ3hFLE9BQU94RSxTQUFTd0IsSUFBSTtRQUN0QjtJQUNGO0FBQ0YsRUFBQztBQUVNLE1BQU1xTixhQUFhelMsYUFBWTtBQUMvQixNQUFNMFMsYUFBYWhTLFlBQVciLCJzb3VyY2VzIjpbIi9ob21lL21lZGdtL3ZzYy9Qcm9qZXQgSkVFL2RlcmVudC1tYWluL2xpYi9zZXJ2aWNlcy9hcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBUEkgU2VydmljZSBMYXllclxuICpcbiAqIENlbnRyYWxpemVkIEFQSSBjb21tdW5pY2F0aW9uIHNlcnZpY2UgdGhhdCBoYW5kbGVzOlxuICogLSBCYXNlIFVSTCBjb25maWd1cmF0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKiAtIEF1dGhlbnRpY2F0aW9uIGhlYWRlcnMgKFgtVXNlci1JZCwgWC1Vc2VyLVJvbGVzKVxuICogLSBSZXF1ZXN0L3Jlc3BvbnNlIGludGVyY2VwdG9yc1xuICogLSBFcnJvciBoYW5kbGluZ1xuICpcbiAqIFVzYWdlOlxuICogaW1wb3J0IHsgYXBpQ2xpZW50IH0gZnJvbSAnQC9saWIvc2VydmljZXMvYXBpJ1xuICogY29uc3QgcHJvcGVydGllcyA9IGF3YWl0IGFwaUNsaWVudC5wcm9wZXJ0aWVzLmdldEFsbCgpXG4gKlxuICogRW52aXJvbm1lbnQgVmFyaWFibGVzIChpbiAuZW52LmxvY2FsKTpcbiAqIC0gTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMOiBCYWNrZW5kIEFQSSBiYXNlIFVSTCAoZS5nLiwgaHR0cDovL2xvY2FsaG9zdDo4MDgwKVxuICogLSBORVhUX1BVQkxJQ19BUElfVkVSU0lPTjogQVBJIHZlcnNpb24gcGF0aCAoZGVmYXVsdDogdjEpXG4gKi9cblxuaW1wb3J0IHR5cGUge1xuICBQcm9wZXJ0eSxcbiAgQ3JlYXRlUHJvcGVydHlSZXF1ZXN0LFxuICBVcGRhdGVQcm9wZXJ0eVJlcXVlc3QsXG4gIEFwcHJvdmVQcm9wZXJ0eVJlcXVlc3QsXG4gIFByb3BlcnR5VHlwZSxcbiAgVXNlcixcbiAgVmVyaWZpY2F0aW9uUmVxdWVzdCxcbiAgVGVuYW50Umlza1Jlc3BvbnNlLFxufSBmcm9tIFwiQC9saWIvdHlwZXNcIlxuXG4vLyBDb25maWd1cmF0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4vLyBVc2UgQVBJIEdhdGV3YXkgKHBvcnQgODA5MCkgYXMgdGhlIHNpbmdsZSBlbnRyeSBwb2ludCBmb3IgYWxsIHNlcnZpY2VzXG4vLyBJZiBHQVRFV0FZX1VSTCBpcyBub3Qgc2V0LCBmYWxsIGJhY2sgdG8gaW5kaXZpZHVhbCBzZXJ2aWNlIFVSTHMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmNvbnN0IEdBVEVXQVlfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR0FURVdBWV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjgwOTBcIlxuY29uc3QgVVNFX0dBVEVXQVkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19VU0VfR0FURVdBWSAhPT0gXCJmYWxzZVwiIC8vIERlZmF1bHQgdG8gdHJ1ZVxuXG4vLyBGYWxsYmFjayBVUkxzIGZvciBpbmRpdmlkdWFsIHNlcnZpY2VzICh1c2VkIGlmIFVTRV9HQVRFV0FZIGlzIGZhbHNlKVxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo4MDgyXCJcbmNvbnN0IFBST1BFUlRZX0FQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1BST1BFUlRZX0FQSV9CQVNFX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6ODA4MVwiXG5jb25zdCBCT09LSU5HX0FQSV9CQVNFX1VSTCA9IFVTRV9HQVRFV0FZXG4gID8gR0FURVdBWV9VUkxcbiAgOiAocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQk9PS0lOR19BUElfQkFTRV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjgwODNcIilcbmNvbnN0IFBBWU1FTlRfQVBJX0JBU0VfVVJMID0gVVNFX0dBVEVXQVlcbiAgPyBHQVRFV0FZX1VSTFxuICA6IChwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19QQVlNRU5UX0FQSV9CQVNFX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6ODA4NVwiKVxuY29uc3QgUkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfUkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo4MDkxXCJcbmNvbnN0IEFQSV9WRVJTSU9OID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1ZFUlNJT04gfHwgXCJ2MVwiXG5jb25zdCBBVVRIX1RPS0VOX0tFWSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FVVEhfU1RPUkFHRV9LRVkgfHwgXCJkZXJlbnQ1X2F1dGhfdG9rZW5cIlxuY29uc3QgVVNFUl9EQVRBX0tFWSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1VTRVJfU1RPUkFHRV9LRVkgfHwgXCJkZXJlbnQ1X3VzZXJfZGF0YVwiXG4vLyBVU0VfTU9DS19BUEkgaXMgdHJ1ZSBpZiBleHBsaWNpdGx5IHNldCB0byBcInRydWVcIiwgb3RoZXJ3aXNlIGZhbHNlICh1c2UgcmVhbCBBUEkpXG5jb25zdCBVU0VfTU9DS19BUEkgPSBmYWxzZSAvLyBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19VU0VfTU9DS19BUEkgPT09IFwidHJ1ZVwiXG5cbi8vIE9ubHkgaW1wb3J0IG1vY2sgQVBJIGlmIG5lZWRlZCAodHJlZS1zaGFrZSB3aGVuIG5vdCB1c2VkKVxuLy8gbGV0IG1vY2tBcGlDbGllbnQ6IGFueSA9IG51bGxcblxuYXN5bmMgZnVuY3Rpb24gZ2V0TW9ja0FwaSgpIHtcbiAgaWYgKCFtb2NrQXBpQ2xpZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTW9jayBBUEkgaGFzIGJlZW4gcmVtb3ZlZFwiKVxuICB9XG4gIHJldHVybiBtb2NrQXBpQ2xpZW50XG59XG5cbi8qKlxuICogRGVjb2RlIEpXVCB0b2tlbiB0byBleHRyYWN0IHVzZXJJZCBmcm9tIHN1YmplY3RcbiAqL1xuZnVuY3Rpb24gZGVjb2RlSldUKHRva2VuOiBzdHJpbmcpOiB7IHVzZXJJZD86IHN0cmluZzsgcm9sZXM/OiBzdHJpbmdbXSB9IHwgbnVsbCB7XG4gIHRyeSB7XG4gICAgLy8gSldUIGZvcm1hdDogaGVhZGVyLnBheWxvYWQuc2lnbmF0dXJlXG4gICAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdChcIi5cIilcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbFxuXG4gICAgLy8gRGVjb2RlIHBheWxvYWQgKGJhc2U2NHVybClcbiAgICBjb25zdCBwYXlsb2FkID0gcGFydHNbMV1cbiAgICBjb25zdCBkZWNvZGVkID0gSlNPTi5wYXJzZShhdG9iKHBheWxvYWQucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIikpKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXJJZDogZGVjb2RlZC5zdWIgfHwgZGVjb2RlZC5zdWJqZWN0LCAvLyBKV1Qgc3ViamVjdCBjb250YWlucyB1c2VySWRcbiAgICAgIHJvbGVzOiBkZWNvZGVkLnJvbGVzIHx8IFtdLFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogR2V0IGF1dGhlbnRpY2F0aW9uIGhlYWRlcnMgZnJvbSBsb2NhbFN0b3JhZ2VcbiAqIFVzZWQgZm9yIGFsbCBBUEkgcmVxdWVzdHMgdGhhdCByZXF1aXJlIHVzZXIgY29udGV4dFxuICovXG5mdW5jdGlvbiBnZXRBdXRoSGVhZGVycygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgLy8gT25seSBydW4gaW4gYnJvd3NlclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB7fVxuICB9XG5cbiAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShBVVRIX1RPS0VOX0tFWSlcbiAgaWYgKCF0b2tlbikge1xuICAgIHJldHVybiB7fVxuICB9XG5cbiAgLy8gVHJ5IHRvIGdldCB1c2VySWQgZnJvbSBKV1QgdG9rZW4gZmlyc3RcbiAgY29uc3QgZGVjb2RlZCA9IGRlY29kZUpXVCh0b2tlbilcbiAgY29uc3QgdXNlcklkID0gZGVjb2RlZD8udXNlcklkXG5cbiAgLy8gRmFsbGJhY2sgdG8gdXNlciBkYXRhIGZyb20gbG9jYWxTdG9yYWdlXG4gIGNvbnN0IHVzZXJEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oVVNFUl9EQVRBX0tFWSlcbiAgbGV0IGZpbmFsVXNlcklkID0gdXNlcklkXG4gIGxldCByb2xlczogc3RyaW5nW10gPSBkZWNvZGVkPy5yb2xlcyB8fCBbXVxuXG4gIGlmICh1c2VyRGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyID0gSlNPTi5wYXJzZSh1c2VyRGF0YSlcbiAgICAgIGZpbmFsVXNlcklkID0gZmluYWxVc2VySWQgfHwgdXNlci5pZCB8fCBcIlwiXG4gICAgICByb2xlcyA9IHJvbGVzLmxlbmd0aCA+IDAgPyByb2xlcyA6ICh1c2VyLnJvbGVzIHx8IFtdKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBGYWlsZWQgdG8gcGFyc2UgdXNlciBkYXRhXG4gICAgfVxuICB9XG5cbiAgLy8gRW5zdXJlIHVzZXJJZCBpcyBhbHdheXMgYSBzdHJpbmcgKGNvbnZlcnQgbnVtYmVyIHRvIHN0cmluZyBpZiBuZWVkZWQpXG4gIGNvbnN0IHVzZXJJZFN0cmluZyA9IGZpbmFsVXNlcklkID8gU3RyaW5nKGZpbmFsVXNlcklkKSA6IFwiXCJcblxuICBjb25zdCBoZWFkZXJzID0ge1xuICAgIFwiWC1Vc2VyLUlkXCI6IHVzZXJJZFN0cmluZyxcbiAgICBcIlgtVXNlci1Sb2xlc1wiOiByb2xlcy5qb2luKFwiLFwiKSxcbiAgICAuLi4odG9rZW4gJiYgeyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9KSxcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzXG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgY29ycmVjdCBiYXNlIFVSTCBmb3IgYSBzZXJ2aWNlXG4gKiBVc2VzIEdhdGV3YXkgaWYgZW5hYmxlZCwgb3RoZXJ3aXNlIGZhbGxzIGJhY2sgdG8gaW5kaXZpZHVhbCBzZXJ2aWNlIFVSTHNcbiAqL1xuZnVuY3Rpb24gZ2V0U2VydmljZVVybChzZXJ2aWNlOiAnYXV0aCcgfCAndXNlcnMnIHwgJ3Byb3BlcnRpZXMnIHwgJ2Jvb2tpbmdzJyB8ICdwYXltZW50cycgfCAncmVjbGFtYXRpb25zJyB8ICdhZG1pbi1yZWNsYW1hdGlvbnMnKTogc3RyaW5nIHtcbiAgaWYgKFVTRV9HQVRFV0FZKSB7XG4gICAgLy8gQWxsIHNlcnZpY2VzIGdvIHRocm91Z2ggdGhlIEdhdGV3YXlcbiAgICByZXR1cm4gR0FURVdBWV9VUkxcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIHRvIGluZGl2aWR1YWwgc2VydmljZSBVUkxzXG4gIHN3aXRjaCAoc2VydmljZSkge1xuICAgIGNhc2UgJ2F1dGgnOlxuICAgIGNhc2UgJ3VzZXJzJzpcbiAgICAgIHJldHVybiBBUElfQkFTRV9VUkxcbiAgICBjYXNlICdwcm9wZXJ0aWVzJzpcbiAgICAgIHJldHVybiBQUk9QRVJUWV9BUElfQkFTRV9VUkxcbiAgICBjYXNlICdib29raW5ncyc6XG4gICAgICByZXR1cm4gQk9PS0lOR19BUElfQkFTRV9VUkxcbiAgICBjYXNlICdwYXltZW50cyc6XG4gICAgICByZXR1cm4gUEFZTUVOVF9BUElfQkFTRV9VUkxcbiAgICBjYXNlICdyZWNsYW1hdGlvbnMnOlxuICAgIGNhc2UgJ2FkbWluLXJlY2xhbWF0aW9ucyc6XG4gICAgICByZXR1cm4gUkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBBUElfQkFTRV9VUkxcbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkIGZ1bGwgVVJMIHdpdGggYmFzZSBhbmQgdmVyc2lvblxuICogRm9yIEdhdGV3YXksIHBhdGggYWxyZWFkeSBpbmNsdWRlcyAvYXBpL3YxLy4uLiwgc28gd2UgZG9uJ3QgYWRkIGl0IGFnYWluXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVXJsKHBhdGg6IHN0cmluZywgc2VydmljZTogJ2F1dGgnIHwgJ3VzZXJzJyB8ICdwcm9wZXJ0aWVzJyB8ICdib29raW5ncycgfCAncGF5bWVudHMnIHwgJ3JlY2xhbWF0aW9ucycgfCAnYWRtaW4tcmVjbGFtYXRpb25zJyA9ICd1c2VycycpOiBzdHJpbmcge1xuICBjb25zdCBiYXNlVXJsID0gZ2V0U2VydmljZVVybChzZXJ2aWNlKVxuXG4gIGlmIChVU0VfR0FURVdBWSkge1xuICAgIC8vIEdhdGV3YXkgcm91dGVzIHByZXNlcnZlIHRoZSBmdWxsIHBhdGhcbiAgICAvLyBQYXRoIHNob3VsZCBhbHJlYWR5IGluY2x1ZGUgL2FwaS92MS8uLi4gb3IgL2FwaS8uLi4gcHJlZml4XG4gICAgLy8gSWYgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggL2FwaSwgYWRkIHRoZSBhcHByb3ByaWF0ZSBwcmVmaXggYmFzZWQgb24gc2VydmljZVxuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJy9hcGkvJykpIHtcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfSR7cGF0aH1gXG4gICAgfVxuXG4gICAgLy8gQWRkIGFwcHJvcHJpYXRlIHByZWZpeCBiYXNlZCBvbiBzZXJ2aWNlXG4gICAgaWYgKHNlcnZpY2UgPT09ICdhdXRoJyB8fCBzZXJ2aWNlID09PSAndXNlcnMnKSB7XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vYXBpL3YxJHtwYXRofWBcbiAgICB9IGVsc2UgaWYgKHNlcnZpY2UgPT09ICdwcm9wZXJ0aWVzJykge1xuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L2FwaS92MSR7cGF0aH1gXG4gICAgfSBlbHNlIGlmIChzZXJ2aWNlID09PSAnYm9va2luZ3MnKSB7XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vYXBpJHtwYXRofWBcbiAgICB9IGVsc2UgaWYgKHNlcnZpY2UgPT09ICdwYXltZW50cycpIHtcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9hcGkke3BhdGh9YFxuICAgIH0gZWxzZSBpZiAoc2VydmljZSA9PT0gJ3JlY2xhbWF0aW9ucycgfHwgc2VydmljZSA9PT0gJ2FkbWluLXJlY2xhbWF0aW9ucycpIHtcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9hcGkke3BhdGh9YFxuICAgIH1cblxuICAgIHJldHVybiBgJHtiYXNlVXJsfSR7cGF0aH1gXG4gIH1cblxuICAvLyBGb3IgZGlyZWN0IHNlcnZpY2UgY2FsbHMsIGFkZCB2ZXJzaW9uIHByZWZpeFxuICBjb25zdCBiYXNlUGF0aCA9IGAvYXBpLyR7QVBJX1ZFUlNJT059YFxuICByZXR1cm4gYCR7YmFzZVVybH0ke2Jhc2VQYXRofSR7cGF0aH1gXG59XG5cbi8qKlxuICogR2VuZXJpYyBmZXRjaCB3cmFwcGVyIHdpdGggZXJyb3IgaGFuZGxpbmdcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdDxUPihcbiAgcGF0aDogc3RyaW5nLFxuICBvcHRpb25zOiBSZXF1ZXN0SW5pdCAmIHsgcmVxdWlyZXNBdXRoPzogYm9vbGVhbjsgc2VydmljZT86ICdhdXRoJyB8ICd1c2VycycgfCAncHJvcGVydGllcycgfCAnYm9va2luZ3MnIHwgJ3BheW1lbnRzJyB8ICdyZWNsYW1hdGlvbnMnIHwgJ2FkbWluLXJlY2xhbWF0aW9ucycgfSA9IHt9XG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgeyByZXF1aXJlc0F1dGggPSB0cnVlLCBzZXJ2aWNlID0gJ3VzZXJzJywgLi4uZmV0Y2hPcHRpb25zIH0gPSBvcHRpb25zXG5cbiAgY29uc3QgaGVhZGVyczogSGVhZGVyc0luaXQgPSB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgLi4uKHJlcXVpcmVzQXV0aCAmJiBnZXRBdXRoSGVhZGVycygpKSxcbiAgICAuLi5mZXRjaE9wdGlvbnMuaGVhZGVycyxcbiAgfVxuXG4gIGNvbnN0IHVybCA9IGJ1aWxkVXJsKHBhdGgsIHNlcnZpY2UpXG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgLi4uZmV0Y2hPcHRpb25zLFxuICAgICAgaGVhZGVycyxcbiAgICB9KVxuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgbGV0IGVycm9yRGF0YTogYW55ID0ge31cbiAgICAgIGxldCByZXNwb25zZVRleHQgPSBcIlwiXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgICBpZiAocmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVycm9yRGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KVxuICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElmIEpTT04gcGFyc2luZyBmYWlscywgdXNlIHRoZSByYXcgdGV4dFxuICAgICAgICAgICAgZXJyb3JEYXRhID0geyBtZXNzYWdlOiByZXNwb25zZVRleHQsIHJhdzogcmVzcG9uc2VUZXh0IH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHRleHRFcnJvcikge1xuICAgICAgICBlcnJvckRhdGEgPSB7IG1lc3NhZ2U6IGBGYWlsZWQgdG8gcmVhZCByZXNwb25zZTogJHt0ZXh0RXJyb3J9YCB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGVycm9yRGF0YSBpcyBzdGlsbCBlbXB0eSwgY3JlYXRlIGEgZGVmYXVsdCBlcnJvclxuICAgICAgaWYgKE9iamVjdC5rZXlzKGVycm9yRGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGVycm9yRGF0YSA9IHtcbiAgICAgICAgICBtZXNzYWdlOiBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLFxuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBFeHRyYWN0IGVycm9yIG1lc3NhZ2UgZnJvbSBFcnJvclJlc3BvbnNlIGZvcm1hdCAodXNlZCBieSB1c2VyLXNlcnZpY2UpXG4gICAgICAvLyBFcnJvclJlc3BvbnNlIGhhczogdGltZXN0YW1wLCBzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBwYXRoXG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPVxuICAgICAgICBlcnJvckRhdGEubWVzc2FnZSB8fCAgICAgICAgICAgLy8gRXJyb3JSZXNwb25zZS5tZXNzYWdlXG4gICAgICAgIGVycm9yRGF0YS5lcnJvciB8fCAgICAgICAgICAgICAvLyBFcnJvclJlc3BvbnNlLmVycm9yIChlcnJvciB0aXRsZSlcbiAgICAgICAgZXJyb3JEYXRhLmRldGFpbCB8fCAgICAgICAgICAgIC8vIFN0YW5kYXJkIFNwcmluZyBlcnJvciBmb3JtYXRcbiAgICAgICAgZXJyb3JEYXRhLnJhdyB8fCAgICAgICAgICAgICAgIC8vIFJhdyByZXNwb25zZSB0ZXh0IGlmIEpTT04gcGFyc2luZyBmYWlsZWRcbiAgICAgICAgKEFycmF5LmlzQXJyYXkoZXJyb3JEYXRhLmVycm9ycykgPyBlcnJvckRhdGEuZXJyb3JzLmpvaW4oXCIsIFwiKSA6IG51bGwpIHx8IC8vIFZhbGlkYXRpb24gZXJyb3JzIGFycmF5XG4gICAgICAgICh0eXBlb2YgZXJyb3JEYXRhID09PSAnc3RyaW5nJyA/IGVycm9yRGF0YSA6IG51bGwpIHx8XG4gICAgICAgIGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuXG4gICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICAgIDsgKGFwaUVycm9yIGFzIGFueSkuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzXG4gICAgICAgIDsgKGFwaUVycm9yIGFzIGFueSkuZXJyb3JEYXRhID0gZXJyb3JEYXRhXG4gICAgICAgIDsgKGFwaUVycm9yIGFzIGFueSkucmVzcG9uc2VUZXh0ID0gcmVzcG9uc2VUZXh0XG4gICAgICB0aHJvdyBhcGlFcnJvclxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHJlc3BvbnNlIGhhcyBjb250ZW50XG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKVxuICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIHJldHVybiBkYXRhIGFzIFRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gSlNPTiBjb250ZW50LCByZXR1cm4gZW1wdHkgb2JqZWN0IGZvciBzdWNjZXNzZnVsIHJlc3BvbnNlc1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIGFzIEpTT04sIGlmIGZhaWxzIHJldHVybiB0ZXh0IGFzIG1lc3NhZ2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KSBhcyBUXG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHRleHQgfSBhcyBUXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7fSBhcyBUXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhIGNvbm5lY3Rpb24gZXJyb3JcbiAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkVSUl9DT05ORUNUSU9OX1JFRlVTRURcIikpIHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25FcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBjb25uZWN0IHRvIGJhY2tlbmQgc2VydmVyIGF0ICR7QVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgIClcbiAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8qKlxuICogTXVsdGlwYXJ0IGZvcm0gZGF0YSByZXF1ZXN0IGZvciBmaWxlIHVwbG9hZHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEZvcm1EYXRhPFQ+KFxuICBwYXRoOiBzdHJpbmcsXG4gIGZvcm1EYXRhOiBGb3JtRGF0YSxcbiAgb3B0aW9uczogT21pdDxSZXF1ZXN0SW5pdCwgXCJib2R5XCI+ICYgeyByZXF1aXJlc0F1dGg/OiBib29sZWFuOyBzZXJ2aWNlPzogJ2F1dGgnIHwgJ3VzZXJzJyB8ICdwcm9wZXJ0aWVzJyB8ICdib29raW5ncycgfCAncGF5bWVudHMnIHwgJ3JlY2xhbWF0aW9ucycgfCAnYWRtaW4tcmVjbGFtYXRpb25zJyB9ID0ge30sXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgeyByZXF1aXJlc0F1dGggPSB0cnVlLCBzZXJ2aWNlID0gJ3VzZXJzJywgLi4uZmV0Y2hPcHRpb25zIH0gPSBvcHRpb25zXG5cbiAgY29uc3QgaGVhZGVyczogSGVhZGVyc0luaXQgPSB7XG4gICAgLi4uKHJlcXVpcmVzQXV0aCAmJiBnZXRBdXRoSGVhZGVycygpKSxcbiAgICAuLi5mZXRjaE9wdGlvbnMuaGVhZGVycyxcbiAgfVxuXG4gIC8vIERvbid0IHNldCBDb250ZW50LVR5cGUgZm9yIEZvcm1EYXRhIC0gYnJvd3NlciB3aWxsIHNldCBpdCB3aXRoIGJvdW5kYXJ5XG4gIGRlbGV0ZSAoaGVhZGVycyBhcyBhbnkpW1wiQ29udGVudC1UeXBlXCJdXG5cbiAgY29uc3QgdXJsID0gYnVpbGRVcmwocGF0aCwgc2VydmljZSlcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgLi4uZmV0Y2hPcHRpb25zLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgIH0pXG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICByZXR1cm4gZGF0YVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBBUEkgQ2xpZW50IC0gT3JnYW5pemVkIGJ5IHJlc291cmNlXG4gKi9cbmV4cG9ydCBjb25zdCBhcGlDbGllbnQgPSB7XG4gIC8vID09PT09PT09PT09PT09PT09PT09IFBST1BFUlRJRVMgPT09PT09PT09PT09PT09PT09PT1cbiAgcHJvcGVydGllczoge1xuICAgIGFzeW5jIGdldEFsbCgpOiBQcm9taXNlPFByb3BlcnR5W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5wcm9wZXJ0aWVzLmdldEFsbCgpXG4gICAgICB9XG4gICAgICAvLyBVc2UgcHJvcGVydHktc2VydmljZSBVUkwgZm9yIHByb3BlcnR5IGVuZHBvaW50c1xuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllc2BcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLCAvLyBJbmNsdWRlIGF1dGggaGVhZGVycyB0byBjaGVjayBpZiB1c2VyIGlzIEFETUlOXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGlmIChlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRVJSX0NPTk5FQ1RJT05fUkVGVVNFRFwiKSkge1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25FcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgY29ubmVjdCB0byBwcm9wZXJ0eS1zZXJ2aWNlIGJhY2tlbmQgYXQgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9LiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBiYWNrZW5kIGlzIHJ1bm5pbmcuYFxuICAgICAgICAgIClcbiAgICAgICAgICAgIDsgKGNvbm5lY3Rpb25FcnJvciBhcyBhbnkpLmlzQ29ubmVjdGlvbkVycm9yID0gdHJ1ZVxuICAgICAgICAgIHRocm93IGNvbm5lY3Rpb25FcnJvclxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGdldEFsbEZvckFkbWluKCk6IFByb21pc2U8UHJvcGVydHlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnRpZXMuZ2V0QWxsKClcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBHYXRld2F5IG9yIHByb3BlcnR5LXNlcnZpY2UgVVJMIGZvciBhZG1pbiBlbmRwb2ludFxuICAgICAgY29uc3QgdXJsID0gYnVpbGRVcmwoXCIvcHJvcGVydGllcy9hZG1pbi9hbGxcIiwgJ3Byb3BlcnRpZXMnKVxuICAgICAgY29uc3QgYXV0aEhlYWRlcnMgPSBnZXRBdXRoSGVhZGVycygpXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uYXV0aEhlYWRlcnMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhLmVycm9yIHx8IGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gICAgICAgIC8vIEVuc3VyZSBkYXRhIGlzIGFuIGFycmF5XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgIC8vIElmIGl0J3MgYW4gZXJyb3Igb2JqZWN0LCB0aHJvdyBpdFxuICAgICAgICAgIGlmIChkYXRhLmVycm9yIHx8IGRhdGEubWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgZGF0YS5tZXNzYWdlIHx8IFwiSW52YWxpZCByZXNwb25zZSBmb3JtYXRcIilcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHJldHVybiBlbXB0eSBhcnJheVxuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpKSB7XG4gICAgICAgICAgY29uc3QgY29ubmVjdGlvbkVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBjb25uZWN0IHRvIHByb3BlcnR5LXNlcnZpY2UgYmFja2VuZCBhdCAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0uIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXMgcnVubmluZy5gXG4gICAgICAgICAgKVxuICAgICAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICAgICAgdGhyb3cgY29ubmVjdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgZ2V0QnlJZChpZDogc3RyaW5nKTogUHJvbWlzZTxQcm9wZXJ0eT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnRpZXMuZ2V0QnlJZChpZClcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBwcm9wZXJ0eS1zZXJ2aWNlIFVSTCBmb3IgcHJvcGVydHkgZW5kcG9pbnRzXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzLyR7aWR9YFxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkNPUlNcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gcHJvcGVydHktc2VydmljZSBiYWNrZW5kIGF0ICR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgICAgICApXG4gICAgICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBnZXRNeVByb3BlcnRpZXMoKTogUHJvbWlzZTxQcm9wZXJ0eVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5nZXRBbGwoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzL215LXByb3BlcnRpZXNgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhLmVycm9yIHx8IGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gICAgICAgIC8vIEVuc3VyZSBkYXRhIGlzIGFuIGFycmF5XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgIC8vIElmIGl0J3MgYW4gZXJyb3Igb2JqZWN0LCB0aHJvdyBpdFxuICAgICAgICAgIGlmIChkYXRhLmVycm9yIHx8IGRhdGEubWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgZGF0YS5tZXNzYWdlIHx8IFwiSW52YWxpZCByZXNwb25zZSBmb3JtYXRcIilcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHJldHVybiBlbXB0eSBhcnJheVxuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkNPUlNcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gcHJvcGVydHktc2VydmljZSBiYWNrZW5kIGF0ICR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgICAgICApXG4gICAgICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGUoZGF0YTogQ3JlYXRlUHJvcGVydHlSZXF1ZXN0LCBpbWFnZXM6IEZpbGVbXSk6IFByb21pc2U8eyBwcm9wZXJ0eUlkOiBzdHJpbmc7IGlkPzogc3RyaW5nIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2NrLnByb3BlcnRpZXMuY3JlYXRlKGRhdGEsIGltYWdlcylcbiAgICAgICAgcmV0dXJuIHsgcHJvcGVydHlJZDogcmVzdWx0LmlkLCBpZDogcmVzdWx0LmlkIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgIC8vIENyZWF0ZSBhIEJsb2Igd2l0aCBKU09OIGNvbnRlbnQgdHlwZSBmb3IgdGhlIGlucHV0IHBhcnRcbiAgICAgIC8vIFNwcmluZydzIEBSZXF1ZXN0UGFydCBleHBlY3RzIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvbiBmb3IgSlNPTiBwYXJ0c1xuICAgICAgY29uc3QgaW5wdXRCbG9iID0gbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KGRhdGEpXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9KVxuICAgICAgZm9ybURhdGEuYXBwZW5kKFwiaW5wdXRcIiwgaW5wdXRCbG9iKVxuXG4gICAgICBpbWFnZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJpbWFnZXNcIiwgZmlsZSlcbiAgICAgIH0pXG5cbiAgICAgIC8vIFVzZSBwcm9wZXJ0eS1zZXJ2aWNlIFVSTCBmb3IgcHJvcGVydHkgZW5kcG9pbnRzXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzYFxuICAgICAgY29uc3QgaGVhZGVyczogSGVhZGVyc0luaXQgPSB7XG4gICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICB9XG4gICAgICAvLyBEb24ndCBzZXQgQ29udGVudC1UeXBlIGhlYWRlciAtIGxldCBicm93c2VyIHNldCBpdCB3aXRoIGJvdW5kYXJ5IGZvciBtdWx0aXBhcnQvZm9ybS1kYXRhXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyB1cGRhdGUoaWQ6IHN0cmluZywgZGF0YTogVXBkYXRlUHJvcGVydHlSZXF1ZXN0KTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnRpZXMudXBkYXRlKGlkLCBkYXRhKVxuICAgICAgfVxuICAgICAgLy8gVXNlIHByb3BlcnR5LXNlcnZpY2UgVVJMIGZvciBwcm9wZXJ0eSBlbmRwb2ludHNcbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXMvJHtpZH1gXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhY2tlbmQgcmV0dXJucyBcIlByb3BlcnR5IHVwZGF0ZWRcIiBhcyBwbGFpbiB0ZXh0LCBub3QgSlNPTlxuICAgICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dClcbiAgICAgICAgICByZXR1cm4gcGFyc2VkXG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIElmIGl0J3Mgbm90IEpTT04sIHJldHVybiBzdWNjZXNzIG9iamVjdFxuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGlmIChlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRVJSX0NPTk5FQ1RJT05fUkVGVVNFRFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJDT1JTXCIpKSB7XG4gICAgICAgICAgY29uc3QgY29ubmVjdGlvbkVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBjb25uZWN0IHRvIHByb3BlcnR5LXNlcnZpY2UgYmFja2VuZCBhdCAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0uIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXMgcnVubmluZy5gXG4gICAgICAgICAgKVxuICAgICAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICAgICAgdGhyb3cgY29ubmVjdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgZGVsZXRlKGlkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5kZWxldGUoaWQpXG4gICAgICB9XG4gICAgICAvLyBVc2UgcHJvcGVydHktc2VydmljZSBVUkwgZm9yIHByb3BlcnR5IGVuZHBvaW50c1xuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllcy8ke2lkfWBcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGlmIChlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRVJSX0NPTk5FQ1RJT05fUkVGVVNFRFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJDT1JTXCIpKSB7XG4gICAgICAgICAgY29uc3QgY29ubmVjdGlvbkVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBjb25uZWN0IHRvIHByb3BlcnR5LXNlcnZpY2UgYmFja2VuZCBhdCAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0uIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXMgcnVubmluZy5gXG4gICAgICAgICAgKVxuICAgICAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICAgICAgdGhyb3cgY29ubmVjdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgYXBwcm92ZShpZDogc3RyaW5nLCBpc0FwcHJvdmVkOiBib29sZWFuKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnRpZXMuYXBwcm92ZShpZCwgaXNBcHByb3ZlZClcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBwcm9wZXJ0eS1zZXJ2aWNlIFVSTCBmb3IgcHJvcGVydHkgZW5kcG9pbnRzXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzLyR7aWR9L2FwcHJvdmVgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaXNBcHByb3ZlZCB9IGFzIEFwcHJvdmVQcm9wZXJ0eVJlcXVlc3QpLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHByb3BlcnR5XG4gICAgICovXG4gICAgYXN5bmMgaGlkZShpZDogc3RyaW5nLCBpc0hpZGRlbjogYm9vbGVhbik6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH1cbiAgICAgIC8vIFVzZSBwcm9wZXJ0eS1zZXJ2aWNlIFVSTCBmb3IgcHJvcGVydHkgZW5kcG9pbnRzXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzLyR7aWR9L2hpZGVgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaXNIaWRkZW4gfSksXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIHN1c3BlbmQoaWQ6IHN0cmluZywgcmVhc29uOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5zdXNwZW5kKGlkLCByZWFzb24pXG4gICAgICB9XG4gICAgICAvLyBVc2UgcHJvcGVydHktc2VydmljZSBVUkwgZm9yIHByb3BlcnR5IGVuZHBvaW50c1xuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllcy8ke2lkfS9zdXNwZW5kYFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHJlYXNvbiB9KSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgcmV2b2tlU3VzcGVuc2lvbihpZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnRpZXMuc3VzcGVuZChpZCwgXCJcIikgLy8gTW9ja1xuICAgICAgfVxuICAgICAgLy8gVXNlIHByb3BlcnR5LXNlcnZpY2UgVVJMIGZvciBwcm9wZXJ0eSBlbmRwb2ludHNcbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXMvJHtpZH0vcmV2b2tlLXN1c3BlbnNpb25gXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBzdWJtaXRGb3JBcHByb3ZhbChpZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnRpZXMuYXBwcm92ZShpZCwgdHJ1ZSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXMvJHtpZH0vc3VibWl0LWZvci1hcHByb3ZhbGBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbEFwcHJvdmFsUmVxdWVzdChpZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfVxuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllcy8ke2lkfS9jYW5jZWwtYXBwcm92YWwtcmVxdWVzdGBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBBSS1wb3dlcmVkIHByaWNlIHN1Z2dlc3Rpb24gZm9yIGEgcHJvcGVydHkgYW5kIGRhdGUgcmFuZ2UuXG4gICAgICogVGhpcyBjYWxscyBwcm9wZXJ0eS1zZXJ2aWNlLCB3aGljaCBmb3J3YXJkcyB0aGUgcmVxdWVzdCB0byB0aGUgcHJpY2luZyBtb2RlbCBBUEkuXG4gICAgICovXG4gICAgYXN5bmMgcHJlZGljdFByaWNlKFxuICAgICAgcHJvcGVydHlJZDogc3RyaW5nLFxuICAgICAgY2hlY2tJbkRhdGU6IHN0cmluZyxcbiAgICAgIGNoZWNrT3V0RGF0ZTogc3RyaW5nLFxuICAgICk6IFByb21pc2U8e1xuICAgICAgcHJlZGljdGVkUHJpY2VNYWQ6IG51bWJlclxuICAgICAgcHJlZGljdGVkUHJpY2VVc2Q6IG51bWJlclxuICAgICAgY29uZmlkZW5jZUludGVydmFsTG93ZXI6IG51bWJlclxuICAgICAgY29uZmlkZW5jZUludGVydmFsVXBwZXI6IG51bWJlclxuICAgICAgY2l0eTogc3RyaW5nXG4gICAgICBzZWFzb246IHN0cmluZ1xuICAgICAgbW9kZWxWZXJzaW9uOiBzdHJpbmdcbiAgICAgIHByZWRpY3Rpb25UaW1lc3RhbXA6IHN0cmluZ1xuICAgICAgY3VycmVudFByaWNlTWFkPzogbnVtYmVyXG4gICAgICBwcmljZURpZmZlcmVuY2VQZXJjZW50PzogbnVtYmVyXG4gICAgICByZWNvbW1lbmRhdGlvbj86IHN0cmluZ1xuICAgIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgLy8gTGlnaHR3ZWlnaHQgbW9jayBmb3IgVUkgZGV2ZWxvcG1lbnRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcmVkaWN0ZWRQcmljZU1hZDogNDMwLFxuICAgICAgICAgIHByZWRpY3RlZFByaWNlVXNkOiA0MyxcbiAgICAgICAgICBjb25maWRlbmNlSW50ZXJ2YWxMb3dlcjogMzgwLFxuICAgICAgICAgIGNvbmZpZGVuY2VJbnRlcnZhbFVwcGVyOiA0ODAsXG4gICAgICAgICAgY2l0eTogXCJjYXNhYmxhbmNhXCIsXG4gICAgICAgICAgc2Vhc29uOiBcInN1bW1lclwiLFxuICAgICAgICAgIG1vZGVsVmVyc2lvbjogXCIxLjBcIixcbiAgICAgICAgICBwcmVkaWN0aW9uVGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgY3VycmVudFByaWNlTWFkOiA0MDAsXG4gICAgICAgICAgcHJpY2VEaWZmZXJlbmNlUGVyY2VudDogNy41LFxuICAgICAgICAgIHJlY29tbWVuZGF0aW9uOiBcIklOQ1JFQVNFXCIsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllcy8ke3Byb3BlcnR5SWR9L3ByZWRpY3QtcHJpY2VgXG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcHJvcGVydHlJZCxcbiAgICAgICAgICBjaGVja0luRGF0ZSxcbiAgICAgICAgICBjaGVja091dERhdGUsXG4gICAgICAgIH0pLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgIGRhdGE/Lm1lc3NhZ2UgfHxcbiAgICAgICAgICBkYXRhPy5lcnJvciB8fFxuICAgICAgICAgICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGRhdGEgOiBudWxsKSB8fFxuICAgICAgICAgIGBGYWlsZWQgdG8gZ2V0IHByaWNlIHN1Z2dlc3Rpb246ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSxcbiAgfSxcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSBURU5BTlQgUklTSyA9PT09PT09PT09PT09PT09PT09PVxuICByaXNrOiB7XG4gICAgZ2V0VGVuYW50Umlza1Njb3JlOiBhc3luYyAodGVuYW50SWQ6IG51bWJlcik6IFByb21pc2U8VGVuYW50Umlza1Jlc3BvbnNlPiA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBVc2UgbG9jYWwgTmV4dC5qcyBwcm94eVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3RlbmFudC1yaXNrLyR7dGVuYW50SWR9YCwge1xuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNTCBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyByaXNrIHNjb3JlOlwiLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuICB9LFxuXG4gIHJlY29tbWVuZGF0aW9uczoge1xuICAgIGdldEZvclRlbmFudDogYXN5bmMgKHRlbmFudElkOiBudW1iZXIsIG1heFJlc3VsdHM6IG51bWJlciA9IDMpOiBQcm9taXNlPGFueT4gPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9yZWNvbW1lbmRhdGlvbnMvdGVuYW50LyR7dGVuYW50SWR9P21heF9yZXN1bHRzPSR7bWF4UmVzdWx0c31gKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIHJlY29tbWVuZGF0aW9uc1wiKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyByZWNvbW1lbmRhdGlvbnM6XCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRTaW1pbGFyOiBhc3luYyAocHJvcGVydHlJZDogc3RyaW5nLCBtYXhSZXN1bHRzOiBudW1iZXIgPSAzKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvcmVjb21tZW5kYXRpb25zL3NpbWlsYXIvJHtwcm9wZXJ0eUlkfT9tYXhfcmVzdWx0cz0ke21heFJlc3VsdHN9YCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBzaW1pbGFyIHByb3BlcnRpZXNcIik7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgc2ltaWxhciBwcm9wZXJ0aWVzOlwiLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSBWRVJJRklDQVRJT04gUkVRVUVTVFMgPT09PT09PT09PT09PT09PT09PT1cbiAgdmVyaWZpY2F0aW9uUmVxdWVzdHM6IHtcbiAgICBhc3luYyBnZXRBbGwoKTogUHJvbWlzZTxWZXJpZmljYXRpb25SZXF1ZXN0W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay52ZXJpZmljYXRpb25SZXF1ZXN0cy5nZXRBbGwoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvdmVyaWZpY2F0aW9uLXJlcXVlc3RzXCIpXG4gICAgfSxcblxuICAgIGFzeW5jIGdldEJ5U3RhdHVzKHN0YXR1czogc3RyaW5nKTogUHJvbWlzZTxWZXJpZmljYXRpb25SZXF1ZXN0W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay52ZXJpZmljYXRpb25SZXF1ZXN0cy5nZXRCeVN0YXR1cyhzdGF0dXMpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3ZlcmlmaWNhdGlvbi1yZXF1ZXN0cy9ieS1zdGF0dXMvJHtzdGF0dXN9YClcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlKHByb3BlcnR5SWQ6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZyk6IFByb21pc2U8eyBpZDogbnVtYmVyIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay52ZXJpZmljYXRpb25SZXF1ZXN0cy5jcmVhdGUocHJvcGVydHlJZCwgZGVzY3JpcHRpb24pXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi92ZXJpZmljYXRpb24tcmVxdWVzdHNcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHByb3BlcnR5SWQsIGRlc2NyaXB0aW9uIH0pLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgYXBwcm92ZShpZDogbnVtYmVyKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnZlcmlmaWNhdGlvblJlcXVlc3RzLmFwcHJvdmUoaWQpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3ZlcmlmaWNhdGlvbi1yZXF1ZXN0cy8ke2lkfS9hcHByb3ZlYCwge1xuICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIHJlamVjdChpZDogbnVtYmVyLCByZWFzb246IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay52ZXJpZmljYXRpb25SZXF1ZXN0cy5yZWplY3QoaWQsIHJlYXNvbilcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KGAvdmVyaWZpY2F0aW9uLXJlcXVlc3RzLyR7aWR9L3JlamVjdGAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcmVhc29uIH0pLFxuICAgICAgfSlcbiAgICB9LFxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IFBST1BFUlRZIFRZUEVTID09PT09PT09PT09PT09PT09PT09XG4gIHByb3BlcnR5VHlwZXM6IHtcbiAgICBhc3luYyBnZXRBbGwoKTogUHJvbWlzZTxQcm9wZXJ0eVR5cGVbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnR5VHlwZXMuZ2V0QWxsKClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL3Byb3BlcnR5LXR5cGVzXCIsIHsgcmVxdWlyZXNBdXRoOiBmYWxzZSB9KVxuICAgIH0sXG5cbiAgICBhc3luYyBnZXRCeUlkKGlkOiBudW1iZXIpOiBQcm9taXNlPFByb3BlcnR5VHlwZT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnR5VHlwZXMuZ2V0QnlJZChpZClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KGAvcHJvcGVydHktdHlwZXMvJHtpZH1gLCB7IHJlcXVpcmVzQXV0aDogZmFsc2UgfSlcbiAgICB9LFxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IFVTRVJTID09PT09PT09PT09PT09PT09PT09XG4gIHVzZXJzOiB7XG4gICAgYXN5bmMgZ2V0TWUoKTogUHJvbWlzZTx7XG4gICAgICBmaXJzdE5hbWU6IHN0cmluZ1xuICAgICAgbGFzdE5hbWU6IHN0cmluZ1xuICAgICAgZW1haWw6IHN0cmluZ1xuICAgICAgcHJvZmlsZVBpY3R1cmU/OiBzdHJpbmdcbiAgICAgIGJpcnRoZGF5Pzogc3RyaW5nXG4gICAgICBwaG9uZU51bWJlcj86IG51bWJlclxuICAgICAgd2FsbGV0QWRkcmVzcz86IHN0cmluZ1xuICAgICAgcm9sZXM/OiBzdHJpbmdbXVxuICAgIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgLy8gTW9jayB1c2VyIGRhdGEgZm9yIGRldmVsb3BtZW50XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZmlyc3ROYW1lOiBcIk1vY2tcIixcbiAgICAgICAgICBsYXN0TmFtZTogXCJVc2VyXCIsXG4gICAgICAgICAgZW1haWw6IFwibW9ja0BleGFtcGxlLmNvbVwiLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi91c2Vycy9tZVwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgaW5mb3JtYXRpb24gYnkgSUQgKGZvciBnZXR0aW5nIHBob25lIG51bWJlciwgZXRjLilcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCeUlkKHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTx7XG4gICAgICBmaXJzdE5hbWU6IHN0cmluZ1xuICAgICAgbGFzdE5hbWU6IHN0cmluZ1xuICAgICAgZW1haWw6IHN0cmluZ1xuICAgICAgcHJvZmlsZVBpY3R1cmU/OiBzdHJpbmdcbiAgICAgIGJpcnRoZGF5Pzogc3RyaW5nXG4gICAgICBwaG9uZU51bWJlcj86IG51bWJlclxuICAgICAgd2FsbGV0QWRkcmVzcz86IHN0cmluZ1xuICAgICAgcm9sZXM/OiBzdHJpbmdbXVxuICAgICAgc2NvcmU/OiBudW1iZXJcbiAgICAgIHJhdGluZz86IG51bWJlclxuICAgICAgZW5hYmxlZD86IGJvb2xlYW5cbiAgICB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZmlyc3ROYW1lOiBcIk1vY2tcIixcbiAgICAgICAgICBsYXN0TmFtZTogXCJVc2VyXCIsXG4gICAgICAgICAgZW1haWw6IFwibW9ja0BleGFtcGxlLmNvbVwiLFxuICAgICAgICAgIHBob25lTnVtYmVyOiAxMjM0NTY3ODkwLFxuICAgICAgICAgIHNjb3JlOiAxMDAsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRyeSB0byBnZXQgZnJvbSBhZG1pbiBlbmRwb2ludCBmaXJzdCAoaWYgdXNlciBpcyBhZG1pbikgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWxsVXNlcnMgPSBhd2FpdCB0aGlzLmdldEFsbEZvckFkbWluKClcbiAgICAgICAgY29uc3QgdXNlciA9IGFsbFVzZXJzLmZpbmQodSA9PiBTdHJpbmcodS5pZCkgPT09IFN0cmluZyh1c2VySWQpKVxuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaXJzdE5hbWU6IHVzZXIuZmlyc3ROYW1lLFxuICAgICAgICAgICAgbGFzdE5hbWU6IHVzZXIubGFzdE5hbWUsXG4gICAgICAgICAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICAgICAgICAgIHByb2ZpbGVQaWN0dXJlOiB1c2VyLnByb2ZpbGVQaWN0dXJlLFxuICAgICAgICAgICAgYmlydGhkYXk6IHVzZXIuYmlydGhkYXksXG4gICAgICAgICAgICBwaG9uZU51bWJlcjogdXNlci5waG9uZU51bWJlcixcbiAgICAgICAgICAgIHdhbGxldEFkZHJlc3M6IHVzZXIud2FsbGV0QWRkcmVzcyxcbiAgICAgICAgICAgIHJvbGVzOiB1c2VyLnJvbGVzLFxuICAgICAgICAgICAgc2NvcmU6IHVzZXIuc2NvcmUsXG4gICAgICAgICAgICBlbmFibGVkOiB1c2VyLmVuYWJsZWQsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gSWYgYWRtaW4gZW5kcG9pbnQgZmFpbHMsIGZhbGxiYWNrIHRvIHJlZ3VsYXIgZW5kcG9pbnRcbiAgICAgIH1cblxuICAgICAgLy8gRmFsbGJhY2sgdG8gcmVndWxhciBlbmRwb2ludFxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC91c2Vycy8ke3VzZXJJZH1gLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgdXBkYXRlTWUoZGF0YToge1xuICAgICAgZmlyc3ROYW1lPzogc3RyaW5nXG4gICAgICBsYXN0TmFtZT86IHN0cmluZ1xuICAgICAgYmlydGhkYXk/OiBzdHJpbmcgLy8gWVlZWS1NTS1ERCBmb3JtYXRcbiAgICAgIHBob25lTnVtYmVyPzogc3RyaW5nIC8vIDEwLTE1IGRpZ2l0c1xuICAgICAgd2FsbGV0QWRkcmVzcz86IHN0cmluZyAvLyBFdGhlcmV1bSBhZGRyZXNzXG4gICAgfSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICAvLyBNb2NrIHVwZGF0ZVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL3VzZXJzL21lXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgdXBkYXRlUHJvZmlsZVBpY3R1cmUoZmlsZTogRmlsZSk6IFByb21pc2U8eyB1cmw6IHN0cmluZyB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7IHVybDogXCIvcGxhY2Vob2xkZXItdXNlci5qcGdcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgZmlsZSlcblxuICAgICAgY29uc3QgaGVhZGVycyA9IGdldEF1dGhIZWFkZXJzKClcbiAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaGVhZGVyIHRvIGxldCBicm93c2VyIHNldCBpdCB3aXRoIGJvdW5kYXJ5IGZvciBtdWx0aXBhcnQvZm9ybS1kYXRhXG4gICAgICBkZWxldGUgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXVxuXG4gICAgICBjb25zdCB1cmwgPSBidWlsZFVybChcIi91c2Vycy9tZS9wcm9maWxlLXBpY3R1cmVcIilcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgbGV0IGVycm9yRGF0YTogYW55ID0ge31cbiAgICAgICAgbGV0IHJlc3BvbnNlVGV4dCA9IFwiXCJcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgICAgIGlmIChyZXNwb25zZVRleHQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGVycm9yRGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KVxuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIGVycm9yRGF0YSA9IHsgbWVzc2FnZTogcmVzcG9uc2VUZXh0LCByYXc6IHJlc3BvbnNlVGV4dCB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBlcnJvckRhdGEgPSB7IG1lc3NhZ2U6IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICBlcnJvckRhdGEubWVzc2FnZSB8fFxuICAgICAgICAgIGVycm9yRGF0YS5lcnJvciB8fFxuICAgICAgICAgIGVycm9yRGF0YS5yYXcgfHxcbiAgICAgICAgICBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcblxuICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICAgICAgOyAoYXBpRXJyb3IgYXMgYW55KS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICA7IChhcGlFcnJvciBhcyBhbnkpLmVycm9yRGF0YSA9IGVycm9yRGF0YVxuICAgICAgICB0aHJvdyBhcGlFcnJvclxuICAgICAgfVxuXG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICByZXR1cm4geyB1cmw6IHRleHQgfSAvLyBCYWNrZW5kIHJldHVybnMgVVJMIGFzIHBsYWluIHRleHRcbiAgICB9LFxuXG4gICAgYXN5bmMgY2hhbmdlUGFzc3dvcmQoY3VycmVudFBhc3N3b3JkOiBzdHJpbmcsIG5ld1Bhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHsgbWVzc2FnZTogc3RyaW5nIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJQYXNzd29yZCBjaGFuZ2VkIHN1Y2Nlc3NmdWxseVwiIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL3VzZXJzL21lL2NoYW5nZS1wYXNzd29yZFwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY3VycmVudFBhc3N3b3JkLCBuZXdQYXNzd29yZCB9KSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIGRlbGV0ZVByb2ZpbGVQaWN0dXJlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL3VzZXJzL21lL3Byb2ZpbGUtcGljdHVyZVwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgYmVjb21lSG9zdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi91c2Vycy9tZS9iZWNvbWUtaG9zdFwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIHJlcXVpcmVzQXV0aDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIGdldEFsbEZvckFkbWluKCk6IFByb21pc2U8QXJyYXk8e1xuICAgICAgaWQ6IG51bWJlclxuICAgICAgZmlyc3ROYW1lOiBzdHJpbmdcbiAgICAgIGxhc3ROYW1lOiBzdHJpbmdcbiAgICAgIGVtYWlsOiBzdHJpbmdcbiAgICAgIHByb2ZpbGVQaWN0dXJlPzogc3RyaW5nXG4gICAgICBiaXJ0aGRheT86IHN0cmluZ1xuICAgICAgcGhvbmVOdW1iZXI/OiBudW1iZXJcbiAgICAgIHdhbGxldEFkZHJlc3M/OiBzdHJpbmdcbiAgICAgIHJvbGVzPzogc3RyaW5nW11cbiAgICAgIGVuYWJsZWQ6IGJvb2xlYW5cbiAgICAgIHNjb3JlOiBudW1iZXJcbiAgICAgIHJhdGluZz86IG51bWJlclxuICAgIH0+PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvdXNlcnMvYWRtaW4vYWxsXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyBlbmFibGVVc2VyKHVzZXJJZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC91c2Vycy9hZG1pbi8ke3VzZXJJZH0vZW5hYmxlYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7fSksXG4gICAgICAgIHJlcXVpcmVzQXV0aDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIGRpc2FibGVVc2VyKHVzZXJJZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC91c2Vycy9hZG1pbi8ke3VzZXJJZH0vZGlzYWJsZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe30pLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyBhZGRBZG1pblJvbGUodXNlcklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3VzZXJzL2FkbWluLyR7dXNlcklkfS9hZGQtYWRtaW4tcm9sZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVtb3ZlQWRtaW5Sb2xlKHVzZXJJZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC91c2Vycy9hZG1pbi8ke3VzZXJJZH0vcmVtb3ZlLWFkbWluLXJvbGVgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIHJlcXVpcmVzQXV0aDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIGFkZEhvc3RSb2xlQnlBZG1pbih1c2VySWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KGAvdXNlcnMvYWRtaW4vJHt1c2VySWR9L2FkZC1ob3N0LXJvbGVgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIHJlcXVpcmVzQXV0aDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIHJlbW92ZUhvc3RSb2xlKHVzZXJJZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC91c2Vycy9hZG1pbi8ke3VzZXJJZH0vcmVtb3ZlLWhvc3Qtcm9sZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IEFVVEhFTlRJQ0FUSU9OID09PT09PT09PT09PT09PT09PT09XG4gIGF1dGg6IHtcbiAgICBhc3luYyByZWdpc3RlcihkYXRhOiB7XG4gICAgICBmaXJzdE5hbWU6IHN0cmluZ1xuICAgICAgbGFzdE5hbWU6IHN0cmluZ1xuICAgICAgZW1haWw6IHN0cmluZ1xuICAgICAgcGFzc3dvcmQ6IHN0cmluZ1xuICAgICAgYmlydGhkYXk6IHN0cmluZyAvLyBZWVlZLU1NLUREIGZvcm1hdFxuICAgICAgcGhvbmVOdW1iZXI6IHN0cmluZ1xuICAgICAgcm9sZT86IHN0cmluZ1xuICAgIH0pOiBQcm9taXNlPHsgbWVzc2FnZTogc3RyaW5nIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICAvLyBNb2NrIHJlZ2lzdHJhdGlvbiAtIHNpbXVsYXRlIGRlbGF5XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIlVzZXIgcmVnaXN0ZXJlZCBzdWNjZXNzZnVsbHlcIiB9XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgICAgIGZpcnN0TmFtZTogZGF0YS5maXJzdE5hbWUsXG4gICAgICAgICAgbGFzdE5hbWU6IGRhdGEubGFzdE5hbWUsXG4gICAgICAgICAgZW1haWw6IGRhdGEuZW1haWwsXG4gICAgICAgICAgcGFzc3dvcmQ6IGRhdGEucGFzc3dvcmQsXG4gICAgICAgICAgYmlydGhkYXk6IGRhdGEuYmlydGhkYXksIC8vIFNob3VsZCBiZSBZWVlZLU1NLUREIGZvcm1hdCBmb3IgTG9jYWxEYXRlXG4gICAgICAgICAgcGhvbmVOdW1iZXI6IGRhdGEucGhvbmVOdW1iZXIsIC8vIFNob3VsZCBiZSAxMC0xNSBkaWdpdHMgb25seVxuICAgICAgICAgIC4uLihkYXRhLnJvbGUgJiYgeyByb2xlOiBkYXRhLnJvbGUgfSksXG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBhd2FpdCByZXF1ZXN0KFwiL2F1dGgvcmVnaXN0ZXJcIiwge1xuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgICAgICAgIHJlcXVpcmVzQXV0aDogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIC8vIElmIGNvbm5lY3Rpb24gZmFpbHMsIHRocm93IHdpdGggaGVscGZ1bCBtZXNzYWdlXG4gICAgICAgIGlmIChlcnJvcj8uaXNDb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkJhY2tlbmQgc2VydmVyIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIHVzZXItc2VydmljZSBpcyBydW5uaW5nIG9uIHBvcnQgODA4MC5cIlxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBsb2dpbihlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTx7IHRva2VuOiBzdHJpbmc7IGp3dEV4cGlyYXRpb246IG51bWJlciB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgLy8gTW9jayBsb2dpbiAtIHdvdWxkIHVzZSBtb2NrIGRhdGFcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9jayBsb2dpbiBub3QgaW1wbGVtZW50ZWQgLSB1c2UgdXNlQXV0aCBob29rXCIpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi9hdXRoL2xvZ2luXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCwgcGFzc3dvcmQgfSksXG4gICAgICAgIHJlcXVpcmVzQXV0aDogZmFsc2UsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBzZXRBdXRoKHRva2VuOiBzdHJpbmcsIHVzZXI6IFVzZXIpOiB2b2lkIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFVVEhfVE9LRU5fS0VZLCB0b2tlbilcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oVVNFUl9EQVRBX0tFWSwgSlNPTi5zdHJpbmdpZnkodXNlcikpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldFRva2VuKCk6IHN0cmluZyB8IG51bGwge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oQVVUSF9UT0tFTl9LRVkpXG4gICAgfSxcblxuICAgIGdldFVzZXIoKTogVXNlciB8IG51bGwge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBudWxsXG4gICAgICBjb25zdCB1c2VyRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFVTRVJfREFUQV9LRVkpXG4gICAgICByZXR1cm4gdXNlckRhdGEgPyBKU09OLnBhcnNlKHVzZXJEYXRhKSA6IG51bGxcbiAgICB9LFxuXG4gICAgY2xlYXJBdXRoKCk6IHZvaWQge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oQVVUSF9UT0tFTl9LRVkpXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFVTRVJfREFUQV9LRVkpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhc1JvbGUocm9sZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICBjb25zdCB1c2VyID0gdGhpcy5nZXRVc2VyKClcbiAgICAgIHJldHVybiB1c2VyPy5yb2xlcy5pbmNsdWRlcyhyb2xlIGFzIGFueSkgPz8gZmFsc2VcbiAgICB9LFxuXG4gICAgYXN5bmMgdmVyaWZ5KGVtYWlsOiBzdHJpbmcsIHZlcmlmaWNhdGlvbkNvZGU6IHN0cmluZyk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJVc2VyIHZlcmlmaWVkIHN1Y2Nlc3NmdWxseVwiIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL2F1dGgvdmVyaWZ5XCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCwgdmVyaWZpY2F0aW9uQ29kZSB9KSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIHJlc2VuZFZlcmlmaWNhdGlvbkNvZGUoZW1haWw6IHN0cmluZyk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJWZXJpZmljYXRpb24gQ29kZSByZXNlbnQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC9hdXRoL3Jlc2VuZD9lbWFpbD0ke2VuY29kZVVSSUNvbXBvbmVudChlbWFpbCl9YCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICByZXF1aXJlc0F1dGg6IGZhbHNlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgZm9yZ290UGFzc3dvcmQoZW1haWw6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi9hdXRoL2ZvcmdvdC1wYXNzd29yZFwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwgfSksXG4gICAgICAgIHJlcXVpcmVzQXV0aDogZmFsc2UsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyB2ZXJpZnlSZXNldFRva2VuKHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHsgdmFsaWQ6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvYXV0aC92ZXJpZnktcmVzZXQtdG9rZW5cIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHRva2VuIH0pLFxuICAgICAgICByZXF1aXJlc0F1dGg6IGZhbHNlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVzZXRQYXNzd29yZCh0b2tlbjogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL2F1dGgvcmVzZXQtcGFzc3dvcmRcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHRva2VuLCBwYXNzd29yZCB9KSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIHZlcmlmeVJlc2V0Q29kZShlbWFpbDogc3RyaW5nLCBjb2RlOiBzdHJpbmcpOiBQcm9taXNlPHsgdmFsaWQ6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvYXV0aC92ZXJpZnktcmVzZXQtY29kZVwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwsIGNvZGUgfSksXG4gICAgICAgIHJlcXVpcmVzQXV0aDogZmFsc2UsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyByZXNldFBhc3N3b3JkV2l0aENvZGUoZW1haWw6IHN0cmluZywgY29kZTogc3RyaW5nLCBuZXdQYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIlBhc3N3b3JkIHJlc2V0IHN1Y2Nlc3NmdWxseVwiIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL2F1dGgvcmVzZXQtcGFzc3dvcmQtd2l0aC1jb2RlXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCwgY29kZSwgbmV3UGFzc3dvcmQgfSksXG4gICAgICAgIHJlcXVpcmVzQXV0aDogZmFsc2UsXG4gICAgICB9KVxuICAgIH0sXG4gIH0sXG5cbiAgYm9va2luZ3M6IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGJvb2tpbmdzIGZvciBhZG1pblxuICAgICAqL1xuICAgIGFzeW5jIGdldEFsbEZvckFkbWluKCk6IFByb21pc2U8QXJyYXk8e1xuICAgICAgaWQ6IG51bWJlclxuICAgICAgdXNlcklkOiBudW1iZXJcbiAgICAgIHByb3BlcnR5SWQ6IHN0cmluZ1xuICAgICAgcHJvcGVydHlUaXRsZTogc3RyaW5nXG4gICAgICBwcm9wZXJ0eUFkZHJlc3M6IHN0cmluZ1xuICAgICAgb3duZXJJZDogbnVtYmVyIHwgbnVsbFxuICAgICAgdGVuYW50TmFtZTogc3RyaW5nXG4gICAgICB0ZW5hbnRFbWFpbDogc3RyaW5nXG4gICAgICBob3N0TmFtZTogc3RyaW5nXG4gICAgICBob3N0RW1haWw6IHN0cmluZ1xuICAgICAgY2hlY2tJbkRhdGU6IHN0cmluZ1xuICAgICAgY2hlY2tPdXREYXRlOiBzdHJpbmdcbiAgICAgIG51bWJlck9mTmlnaHRzOiBudW1iZXIgfCBudWxsXG4gICAgICB0b3RhbFByaWNlOiBudW1iZXIgfCBudWxsXG4gICAgICBsb25nU3RheURpc2NvdW50UGVyY2VudDogbnVtYmVyIHwgbnVsbFxuICAgICAgcmVxdWVzdGVkTmVnb3RpYXRpb25QZXJjZW50OiBudW1iZXIgfCBudWxsXG4gICAgICBzdGF0dXM6IHN0cmluZ1xuICAgICAgb25DaGFpblR4SGFzaDogc3RyaW5nIHwgbnVsbFxuICAgICAgbmVnb3RpYXRpb25FeHBpcmVzQXQ6IHN0cmluZyB8IG51bGxcbiAgICAgIGNyZWF0ZWRBdDogc3RyaW5nXG4gICAgICB1cGRhdGVkQXQ6IHN0cmluZyB8IG51bGxcbiAgICB9Pj4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvYWRtaW4vYWxsYFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGJvb2tpbmdzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkVSUl9DT05ORUNUSU9OX1JFRlVTRURcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gYm9va2luZy1zZXJ2aWNlIGJhY2tlbmQgYXQgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0uIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXMgcnVubmluZy5gXG4gICAgICAgICAgKVxuICAgICAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICAgICAgdGhyb3cgY29ubmVjdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgYm9va2luZyByZXF1ZXN0XG4gICAgICogU2VuZHMgYm9va2luZyBkYXRhIHRvIGJvb2tpbmctc2VydmljZSB2aWEgUmFiYml0TVFcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUoZGF0YToge1xuICAgICAgdXNlcklkOiBzdHJpbmcgfCBudW1iZXJcbiAgICAgIHByb3BlcnR5SWQ6IHN0cmluZyB8IG51bWJlclxuICAgICAgY2hlY2tJbkRhdGU6IHN0cmluZ1xuICAgICAgY2hlY2tPdXREYXRlOiBzdHJpbmdcbiAgICAgIG51bWJlck9mR3Vlc3RzOiBudW1iZXJcbiAgICAgIHJlcXVlc3RlZFByaWNlPzogbnVtYmVyXG4gICAgfSk6IFByb21pc2U8eyBzdGF0dXM6IHN0cmluZzsgbWVzc2FnZTogc3RyaW5nOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2suYm9va2luZ3M/LmNyZWF0ZT8uKGRhdGEpIHx8IHsgc3RhdHVzOiBcImFjY2VwdGVkXCIsIG1lc3NhZ2U6IFwiQm9va2luZyByZXF1ZXN0IHNlbnRcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvcmVxdWVzdGBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdXNlcklkOiB0eXBlb2YgZGF0YS51c2VySWQgPT09IFwic3RyaW5nXCIgPyBwYXJzZUludChkYXRhLnVzZXJJZCkgOiBkYXRhLnVzZXJJZCxcbiAgICAgICAgICBwcm9wZXJ0eUlkOiBkYXRhLnByb3BlcnR5SWQsIC8vIEtlZXAgYXMgU3RyaW5nIChVVUlEIGZyb20gcHJvcGVydHktc2VydmljZSlcbiAgICAgICAgICBjaGVja0luRGF0ZTogZGF0YS5jaGVja0luRGF0ZSxcbiAgICAgICAgICBjaGVja091dERhdGU6IGRhdGEuY2hlY2tPdXREYXRlLFxuICAgICAgICAgIG51bWJlck9mR3Vlc3RzOiBkYXRhLm51bWJlck9mR3Vlc3RzLFxuICAgICAgICAgIHJlcXVlc3RlZFByaWNlOiBkYXRhLnJlcXVlc3RlZFByaWNlLFxuICAgICAgICB9KSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIC8vIElmIHN0YXR1cyBpcyBcInJlamVjdGVkXCIsIHJldHVybiB0aGUgcmVzcG9uc2UgZGF0YSBpbnN0ZWFkIG9mIHRocm93aW5nXG4gICAgICAgIGlmIChyZXNwb25zZURhdGEuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2VEYXRhXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gY3JlYXRlIGJvb2tpbmc6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZURhdGFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJvb2tpbmcgYnkgSURcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCeUlkKGlkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLmJvb2tpbmdzPy5nZXRCeUlkPy4oaWQpIHx8IG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy8ke2lkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGJvb2tpbmc6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJvb2tpbmdzIGJ5IHRlbmFudCBJRFxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5VGVuYW50SWQodGVuYW50SWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5ib29raW5ncz8uZ2V0QnlUZW5hbnRJZD8uKHRlbmFudElkKSB8fCBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzP3RlbmFudElkPSR7dGVuYW50SWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGJvb2tpbmdzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IGJvb2tpbmcgZm9yIGEgdXNlclxuICAgICAqL1xuICAgIGFzeW5jIGdldEN1cnJlbnRCb29raW5nKHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnkgfCBudWxsPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIC8vIE1vY2s6IHJldHVybiBudWxsIGZvciBub3cgKG5vIGN1cnJlbnQgYm9va2luZylcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9jdXJyZW50P3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0IHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGN1cnJlbnQgYm9va2luZzogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGVuZGluZyBib29raW5ncyAobmVnb3RpYXRpb25zKSBmb3IgYSB1c2VyXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UGVuZGluZ0Jvb2tpbmdzKHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICAvLyBNb2NrOiByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvcGVuZGluZz91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHBlbmRpbmcgYm9va2luZ3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGF3YWl0aW5nIHBheW1lbnQgYm9va2luZ3MgZm9yIGEgdXNlclxuICAgICAqL1xuICAgIGFzeW5jIGdldEF3YWl0aW5nUGF5bWVudEJvb2tpbmdzKHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICAvLyBNb2NrOiByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvcGF5bWVudD91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGF3YWl0aW5nIHBheW1lbnQgYm9va2luZ3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHByb3BlcnR5IGluZm8gZm9yIGJvb2tpbmcgKHByaWNlLCBkaXNjb3VudCwgbmVnb3RpYXRpb24pXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJvcGVydHlJbmZvKHByb3BlcnR5SWQ6IHN0cmluZyk6IFByb21pc2U8e1xuICAgICAgaWQ6IHN0cmluZ1xuICAgICAgb3duZXJJZDogbnVtYmVyXG4gICAgICBwcmljZVBlck5pZ2h0OiBudW1iZXIgfCBzdHJpbmcgLy8gQ2FuIGJlIG51bWJlciBvciBzdHJpbmcgKEJpZ0RlY2ltYWwgZnJvbSBiYWNrZW5kKVxuICAgICAgaXNOZWdvdGlhYmxlOiBib29sZWFuXG4gICAgICBkaXNjb3VudEVuYWJsZWQ6IGJvb2xlYW5cbiAgICAgIG1heE5lZ290aWF0aW9uUGVyY2VudD86IG51bWJlclxuICAgIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgLy8gTW9jayBwcm9wZXJ0eSBpbmZvXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IHByb3BlcnR5SWQsXG4gICAgICAgICAgb3duZXJJZDogMSxcbiAgICAgICAgICBwcmljZVBlck5pZ2h0OiAxMDAsXG4gICAgICAgICAgaXNOZWdvdGlhYmxlOiBmYWxzZSxcbiAgICAgICAgICBkaXNjb3VudEVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvcHJvcGVydHkvJHtwcm9wZXJ0eUlkfWBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkNPUlNcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gYm9va2luZy1zZXJ2aWNlIGJhY2tlbmQgYXQgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0uIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXMgcnVubmluZy5gXG4gICAgICAgICAgKVxuICAgICAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICAgICAgdGhyb3cgY29ubmVjdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxhc3QgYm9va2luZyBJRCAoZm9yIHBvbGxpbmcgYWZ0ZXIgY3JlYXRpb24pXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TGFzdEJvb2tpbmdJZCgpOiBQcm9taXNlPHsgYm9va2luZ0lkOiBudW1iZXIgfSB8IG51bGw+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgYm9va2luZ0lkOiAxIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9ib29raW5nLWlkYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIGJvb2tpbmdcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUoaWQ6IHN0cmluZyB8IG51bWJlciwgZGF0YToge1xuICAgICAgY2hlY2tJbkRhdGU/OiBzdHJpbmdcbiAgICAgIGNoZWNrT3V0RGF0ZT86IHN0cmluZ1xuICAgICAgbnVtYmVyT2ZHdWVzdHM/OiBudW1iZXJcbiAgICAgIHJlcXVlc3RlZFByaWNlPzogbnVtYmVyXG4gICAgfSk6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2suYm9va2luZ3M/LnVwZGF0ZT8uKGlkLCBkYXRhKSB8fCBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvJHtpZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGNoZWNrSW5EYXRlOiBkYXRhLmNoZWNrSW5EYXRlLFxuICAgICAgICAgIGNoZWNrT3V0RGF0ZTogZGF0YS5jaGVja091dERhdGUsXG4gICAgICAgICAgbnVtYmVyT2ZHdWVzdHM6IGRhdGEubnVtYmVyT2ZHdWVzdHMsXG4gICAgICAgICAgcmVxdWVzdGVkUHJpY2U6IGRhdGEucmVxdWVzdGVkUHJpY2UsXG4gICAgICAgIH0pLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gdXBkYXRlIGJvb2tpbmc6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKVxuICAgICAgICAgIC8vIEFkZCBzdGF0dXMgYW5kIGVycm9yIGNvZGUgZm9yIGJldHRlciBlcnJvciBoYW5kbGluZ1xuICAgICAgICAgIDsgKGVycm9yIGFzIGFueSkuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzXG4gICAgICAgICAgOyAoZXJyb3IgYXMgYW55KS5lcnJvckNvZGUgPSBlcnJvckRhdGEuZXJyb3JcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZS9DYW5jZWwgYSBib29raW5nIChieSB0ZW5hbnQpXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKGlkOiBzdHJpbmcgfCBudW1iZXIsIHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5ib29raW5ncz8uZGVsZXRlPy4oaWQsIHVzZXJJZClcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy8ke2lkfT91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuZXJyb3IgfHwgYEZhaWxlZCB0byBjYW5jZWwgYm9va2luZzogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUZW5hbnQgY2hlY2tvdXQgKGNoYW5nZXMgc3RhdHVzIHRvIFRFTkFOVF9DSEVDS0VEX09VVClcbiAgICAgKi9cbiAgICBhc3luYyB0ZW5hbnRDaGVja291dChpZDogc3RyaW5nIHwgbnVtYmVyLCB0ZW5hbnRJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJUZW5hbnQgY2hlY2tlZCBvdXQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7aWR9L2NoZWNrb3V0L3RlbmFudD91c2VySWQ9JHt0ZW5hbnRJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuZXJyb3IgfHwgYEZhaWxlZCB0byBjaGVja291dDogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPd25lciBjb25maXJtIGNoZWNrb3V0IChjaGFuZ2VzIHN0YXR1cyB0byBDT01QTEVURUQpXG4gICAgICovXG4gICAgYXN5bmMgb3duZXJDb25maXJtQ2hlY2tvdXQoaWQ6IHN0cmluZyB8IG51bWJlciwgb3duZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJDaGVja291dCBjb25maXJtZWQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7aWR9L2NoZWNrb3V0L293bmVyP3VzZXJJZD0ke293bmVySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gY29uZmlybSBjaGVja291dDogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdGVuYW50Q2hlY2tvdXQoKSBvciBvd25lckNvbmZpcm1DaGVja291dCgpIGluc3RlYWRcbiAgICAgKi9cbiAgICBhc3luYyBtYXJrQXNDaGVja2VkT3V0KGlkOiBzdHJpbmcgfCBudW1iZXIsIHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5ib29raW5ncz8ubWFya0FzQ2hlY2tlZE91dD8uKGlkLCB1c2VySWQpIHx8IG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy8ke2lkfS9jaGVja291dD91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gbWFyayBhcyBjaGVja2VkIG91dDogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBib29raW5ncyBieSBvd25lciAoaG9zdClcbiAgICAgKi9cbiAgICBhc3luYyBnZXRDdXJyZW50Qm9va2luZ3NCeU93bmVyKG93bmVySWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvY3VycmVudC9vd25lcj9vd25lcklkPSR7b3duZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggY3VycmVudCBib29raW5nczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGVuZGluZyBuZWdvdGlhdGlvbnMgYnkgb3duZXIgKGhvc3QpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UGVuZGluZ05lZ290aWF0aW9ucyhvd25lcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzL25lZ290aWF0aW9ucz9vd25lcklkPSR7b3duZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggcGVuZGluZyBuZWdvdGlhdGlvbnM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWNjZXB0IG5lZ290aWF0aW9uIChob3N0KVxuICAgICAqL1xuICAgIGFzeW5jIGFjY2VwdE5lZ290aWF0aW9uKGJvb2tpbmdJZDogc3RyaW5nIHwgbnVtYmVyLCBvd25lcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIk5lZ290aWF0aW9uIGFjY2VwdGVkXCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7Ym9va2luZ0lkfS9hY2NlcHQ/b3duZXJJZD0ke293bmVySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gYWNjZXB0IG5lZ290aWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlamVjdCBuZWdvdGlhdGlvbiAoaG9zdClcbiAgICAgKi9cbiAgICBhc3luYyByZWplY3ROZWdvdGlhdGlvbihib29raW5nSWQ6IHN0cmluZyB8IG51bWJlciwgb3duZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJOZWdvdGlhdGlvbiByZWplY3RlZFwiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy8ke2Jvb2tpbmdJZH0vcmVqZWN0P293bmVySWQ9JHtvd25lcklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGVycm9yRGF0YS5lcnJvciB8fCBgRmFpbGVkIHRvIHJlamVjdCBuZWdvdGlhdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGJvb2tpbmdzIGJ5IG93bmVyIChob3N0KVxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5T3duZXJJZChvd25lcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzP293bmVySWQ9JHtvd25lcklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBib29raW5nczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29uZmlybWVkIGJvb2tpbmdzIGJ5IG93bmVyIChob3N0KVxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbmZpcm1lZEJvb2tpbmdzQnlPd25lcihvd25lcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzL2NvbmZpcm1lZC9vd25lcj9vd25lcklkPSR7b3duZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggY29uZmlybWVkIGJvb2tpbmdzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb25maXJtZWQgYm9va2luZ3MgYnkgcHJvcGVydHkgSURcbiAgICAgKi9cbiAgICBhc3luYyBnZXRDb25maXJtZWRCb29raW5nc0J5UHJvcGVydHkocHJvcGVydHlJZDogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9jb25maXJtZWQvcHJvcGVydHkvJHtwcm9wZXJ0eUlkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBjb25maXJtZWQgYm9va2luZ3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwb3J0IGRpc3B1dGUgKGhvc3Qgb3IgdGVuYW50KVxuICAgICAqL1xuICAgIGFzeW5jIHJlcG9ydERpc3B1dGUoYm9va2luZ0lkOiBzdHJpbmcgfCBudW1iZXIsIHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJEaXNwdXRlIHJlcG9ydGVkXCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7Ym9va2luZ0lkfS9kaXNwdXRlP3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gcmVwb3J0IGRpc3B1dGU6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBQYXltZW50IFNlcnZpY2UgQVBJXG4gICAqL1xuICBwYXltZW50czoge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBwYXltZW50IGludGVudFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUludGVudChib29raW5nSWQ6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVmZXJlbmNlSWQ6IFwibW9jay1yZWYtaWRcIixcbiAgICAgICAgICB0bzogXCIweDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBcIixcbiAgICAgICAgICB2YWx1ZTogXCIxMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICBjaGFpbklkOiAzMTMzNyxcbiAgICAgICAgICB0b3RhbEFtb3VudFdlaTogXCIxMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UEFZTUVOVF9BUElfQkFTRV9VUkx9L2FwaS9wYXltZW50cy9pbnRlbnRgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBib29raW5nSWQgfSksXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBjcmVhdGUgcGF5bWVudCBpbnRlbnQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJvb2tpbmcgZGV0YWlscyBmb3IgcGF5bWVudFxuICAgICAqL1xuICAgIGFzeW5jIGdldEJvb2tpbmdEZXRhaWxzKGJvb2tpbmdJZDogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBib29raW5nSWQsXG4gICAgICAgICAgc3RhdHVzOiBcIlBFTkRJTkdfUEFZTUVOVFwiLFxuICAgICAgICAgIHRvdGFsUHJpY2U6IDEwMC4wLFxuICAgICAgICAgIGNoZWNrSW5EYXRlOiBcIjIwMjUtMTItMDFcIixcbiAgICAgICAgICBjaGVja091dERhdGU6IFwiMjAyNS0xMi0wNVwiLFxuICAgICAgICAgIHByb3BlcnR5SWQ6IDEsXG4gICAgICAgICAgcHJvcGVydHlUaXRsZTogXCJNb2NrIFByb3BlcnR5XCIsXG4gICAgICAgICAgcHJvcGVydHlQcmljZTogMjAuMCxcbiAgICAgICAgICBvd25lcldhbGxldEFkZHJlc3M6IFwiMHgxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwXCIsXG4gICAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICAgIGN1cnJlbnRVc2VySWQ6IDEsXG4gICAgICAgICAgdXNlckZpcnN0TmFtZTogXCJKb2huXCIsXG4gICAgICAgICAgdXNlckxhc3ROYW1lOiBcIkRvZVwiLFxuICAgICAgICAgIHVzZXJFbWFpbDogXCJqb2huQGV4YW1wbGUuY29tXCIsXG4gICAgICAgICAgdXNlcldhbGxldEFkZHJlc3M6IG51bGwsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UEFZTUVOVF9BUElfQkFTRV9VUkx9L2FwaS9wYXltZW50cy9ib29raW5nLyR7Ym9va2luZ0lkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgRmFpbGVkIHRvIGZldGNoIGJvb2tpbmcgZGV0YWlsczogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICAgIC8vIEJhY2tlbmQgcmV0dXJucyB7IGNvZGUsIG1lc3NhZ2UgfSBmb3JtYXRcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuY29kZSB8fCBlcnJvck1lc3NhZ2VcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIElmIHJlc3BvbnNlIGlzIG5vdCBKU09OLCB1c2Ugc3RhdHVzIHRleHRcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSByZXNwb25zZS5zdGF0dXNUZXh0IHx8IGVycm9yTWVzc2FnZVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHdhbGxldCBhZGRyZXNzXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlV2FsbGV0QWRkcmVzcyh1c2VySWQ6IG51bWJlciwgd2FsbGV0QWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtQQVlNRU5UX0FQSV9CQVNFX1VSTH0vYXBpL3BheW1lbnRzL3dhbGxldC1hZGRyZXNzYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1c2VySWQsIHdhbGxldEFkZHJlc3MgfSksXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byB1cGRhdGUgd2FsbGV0IGFkZHJlc3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVHJhbnNhY3Rpb25IYXNoKGJvb2tpbmdJZDogbnVtYmVyLCB0eEhhc2g6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UEFZTUVOVF9BUElfQkFTRV9VUkx9L2FwaS9wYXltZW50cy9ib29raW5nLyR7Ym9va2luZ0lkfS90eC1oYXNoYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB0eEhhc2ggfSksXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byB1cGRhdGUgdHJhbnNhY3Rpb24gaGFzaDogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gRGF0ZSBtb2RpZmljYXRpb24gcmVtb3ZlZCAtIGRhdGVzIGNhbiBvbmx5IGJlIGNoYW5nZWQgZnJvbSBib29raW5nLXNlcnZpY2VcblxuICAgIC8qKlxuICAgICAqIEdldCB0cmFuc2FjdGlvbiBzdGF0dXNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblN0YXR1cyh0eEhhc2g6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHhIYXNoLFxuICAgICAgICAgIHN0YXR1czogXCJQRU5ESU5HXCIsXG4gICAgICAgICAgYmxvY2tOdW1iZXI6IG51bGwsXG4gICAgICAgICAgYm9va2luZ0lkOiBudWxsLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1BBWU1FTlRfQVBJX0JBU0VfVVJMfS9hcGkvcGF5bWVudHMvdHgvJHt0eEhhc2h9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHRyYW5zYWN0aW9uIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZSBib29raW5nIG9uIGJsb2NrY2hhaW4gKGNhbGxlZCBieSBob3N0IHdoZW4gY29uZmlybWluZyBjaGVja291dClcbiAgICAgKi9cbiAgICBhc3luYyBjb21wbGV0ZUJvb2tpbmcoYm9va2luZ0lkOiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWVzc2FnZTogXCJCb29raW5nIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkgb24gYmxvY2tjaGFpblwiLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1BBWU1FTlRfQVBJX0JBU0VfVVJMfS9hcGkvcGF5bWVudHMvYm9va2luZy8ke2Jvb2tpbmdJZH0vY29tcGxldGVgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgbGV0IGVycm9yRGF0YTogYW55ID0ge31cbiAgICAgICAgbGV0IGVycm9yVGV4dCA9IFwiXCJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgICAgICBpZiAoZXJyb3JUZXh0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBlcnJvckRhdGEgPSBKU09OLnBhcnNlKGVycm9yVGV4dClcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICBlcnJvckRhdGEgPSB7IG1lc3NhZ2U6IGVycm9yVGV4dCB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSWYgcmVzcG9uc2UgaXMgbm90IEpTT04sIHVzZSBzdGF0dXMgdGV4dFxuICAgICAgICAgIGVycm9yRGF0YSA9IHsgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCB8fCBgU2VydmVyIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yRGF0YS5tZXNzYWdlIHx8IGVycm9yRGF0YS5lcnJvciB8fCBlcnJvclRleHQgfHwgYEZhaWxlZCB0byBjb21wbGV0ZSBib29raW5nOiAke3Jlc3BvbnNlLnN0YXR1c31gXG5cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcbiAgfSxcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSBSRUNMQU1BVElPTlMgPT09PT09PT09PT09PT09PT09PT1cbiAgcmVjbGFtYXRpb25zOiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcmVjbGFtYXRpb24gZm9yIGEgYm9va2luZ1xuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShcbiAgICAgIGJvb2tpbmdJZDogc3RyaW5nIHwgbnVtYmVyLFxuICAgICAgdXNlcklkOiBzdHJpbmcgfCBudW1iZXIsXG4gICAgICBjb21wbGFpbmFudFJvbGU6IFwiR1VFU1RcIiB8IFwiSE9TVFwiLFxuICAgICAgcmVjbGFtYXRpb25UeXBlOiBzdHJpbmcsXG4gICAgICB0aXRsZT86IHN0cmluZyxcbiAgICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nLFxuICAgICAgaW1hZ2VzPzogRmlsZVtdXG4gICAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiwgbWVzc2FnZTogXCJSZWNsYW1hdGlvbiBjcmVhdGVkIHN1Y2Nlc3NmdWxseVwiIH1cbiAgICAgIH1cblxuICAgICAgLy8gVXNlIHJlY2xhbWF0aW9uLXNlcnZpY2UgZGlyZWN0bHkgdG8gc3VwcG9ydCBpbWFnZXNcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcImJvb2tpbmdJZFwiLCBTdHJpbmcoYm9va2luZ0lkKSlcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcInVzZXJJZFwiLCBTdHJpbmcodXNlcklkKSlcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcImNvbXBsYWluYW50Um9sZVwiLCBjb21wbGFpbmFudFJvbGUpXG4gICAgICBmb3JtRGF0YS5hcHBlbmQoXCJyZWNsYW1hdGlvblR5cGVcIiwgcmVjbGFtYXRpb25UeXBlKVxuICAgICAgaWYgKHRpdGxlKSBmb3JtRGF0YS5hcHBlbmQoXCJ0aXRsZVwiLCB0aXRsZSlcbiAgICAgIGlmIChkZXNjcmlwdGlvbikgZm9ybURhdGEuYXBwZW5kKFwiZGVzY3JpcHRpb25cIiwgZGVzY3JpcHRpb24pXG4gICAgICBpZiAoaW1hZ2VzICYmIGltYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGltYWdlcy5mb3JFYWNoKChpbWFnZSkgPT4ge1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVzXCIsIGltYWdlKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9yZWNsYW1hdGlvbnMvY3JlYXRlYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gY3JlYXRlIHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcmVjbGFtYXRpb25zIGJ5IGNvbXBsYWluYW50IElEIChteSBjb21wbGFpbnRzKVxuICAgICAqL1xuICAgIGFzeW5jIGdldE15Q29tcGxhaW50cyh1c2VySWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy9teS1jb21wbGFpbnRzP3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggY29tcGxhaW50czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHJlY2xhbWF0aW9ucyBhZ2FpbnN0IGEgdXNlciAoY29tcGxhaW50cyBhZ2FpbnN0IG1lKVxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbXBsYWludHNBZ2FpbnN0TWUodXNlcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9yZWNsYW1hdGlvbnMvYWdhaW5zdC1tZT91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGNvbXBsYWludHM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBsb2FkIGF0dGFjaG1lbnRzIChpbWFnZXMpIGZvciBhIHJlY2xhbWF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkQXR0YWNobWVudHMocmVjbGFtYXRpb25JZDogbnVtYmVyLCBmaWxlczogRmlsZVtdKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgIGZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZXNcIiwgZmlsZSlcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9L2F0dGFjaG1lbnRzYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gdXBsb2FkIGF0dGFjaG1lbnRzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZWNsYW1hdGlvbiBieSBib29raW5nIElEIGFuZCBjb21wbGFpbmFudCBJRFxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5Qm9va2luZ0lkQW5kQ29tcGxhaW5hbnQoXG4gICAgICBib29raW5nSWQ6IHN0cmluZyB8IG51bWJlcixcbiAgICAgIGNvbXBsYWluYW50SWQ6IHN0cmluZyB8IG51bWJlclxuICAgICk6IFByb21pc2U8YW55IHwgbnVsbD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9yZWNsYW1hdGlvbnMvYm9va2luZy8ke2Jvb2tpbmdJZH0vY29tcGxhaW5hbnQvJHtjb21wbGFpbmFudElkfWBcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gNDA0IGlzIGV4cGVjdGVkIHdoZW4gbm8gcmVjbGFtYXRpb24gZXhpc3RzIC0gcmV0dXJuIG51bGwgc2lsZW50bHlcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgLy8gU2lsZW50bHkgaGFuZGxlIDQwNCBlcnJvcnMgKG5vIHJlY2xhbWF0aW9uIGV4aXN0cyAtIHRoaXMgaXMgbm9ybWFsKVxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoXCI0MDRcIikgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoXCJOb3QgRm91bmRcIikpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZWNsYW1hdGlvbiBieSBJRFxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5SWQocmVjbGFtYXRpb25JZDogbnVtYmVyKTogUHJvbWlzZTxhbnkgfCBudWxsPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVjbGFtYXRpb24gYXR0YWNobWVudHMgKGltYWdlcylcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBdHRhY2htZW50cyhyZWNsYW1hdGlvbklkOiBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9yZWNsYW1hdGlvbnMvJHtyZWNsYW1hdGlvbklkfS9hdHRhY2htZW50c2BcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBhdHRhY2htZW50czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSByZWNsYW1hdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShyZWNsYW1hdGlvbklkOiBzdHJpbmcgfCBudW1iZXIsIHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9yZWNsYW1hdGlvbnMvJHtyZWNsYW1hdGlvbklkfT91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGRlbGV0ZSByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgcmVjbGFtYXRpb24gKHRpdGxlLCBkZXNjcmlwdGlvbiwgaW1hZ2VzKVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShcbiAgICAgIHJlY2xhbWF0aW9uSWQ6IHN0cmluZyB8IG51bWJlcixcbiAgICAgIHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyLFxuICAgICAgdGl0bGU/OiBzdHJpbmcsXG4gICAgICBkZXNjcmlwdGlvbj86IHN0cmluZyxcbiAgICAgIGltYWdlcz86IEZpbGVbXVxuICAgICk6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJzdWNjZXNzXCIsIG1lc3NhZ2U6IFwiUmVjbGFtYXRpb24gdXBkYXRlZCBzdWNjZXNzZnVsbHlcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcInVzZXJJZFwiLCBTdHJpbmcodXNlcklkKSlcbiAgICAgIGlmICh0aXRsZSkgZm9ybURhdGEuYXBwZW5kKFwidGl0bGVcIiwgdGl0bGUpXG4gICAgICBpZiAoZGVzY3JpcHRpb24pIGZvcm1EYXRhLmFwcGVuZChcImRlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uKVxuICAgICAgaWYgKGltYWdlcyAmJiBpbWFnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpbWFnZXMuZm9yRWFjaCgoaW1hZ2UpID0+IHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlc1wiLCBpbWFnZSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvcmVjbGFtYXRpb25zLyR7cmVjbGFtYXRpb25JZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIHVwZGF0ZSByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBwaG9uZSBudW1iZXJcbiAgICAgKi9cbiAgICBhc3luYyBnZXRVc2VyUGhvbmVOdW1iZXIodXNlcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvcmVjbGFtYXRpb25zL3VzZXIvJHt1c2VySWR9L3Bob25lYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHBob25lIG51bWJlcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgcmV0dXJuIGRhdGEucGhvbmVOdW1iZXIgfHwgbnVsbFxuICAgIH0sXG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gQURNSU4gUkVDTEFNQVRJT05TID09PT09PT09PT09PT09PT09PT09XG4gIGFkbWluUmVjbGFtYXRpb25zOiB7XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCByZWNsYW1hdGlvbnMgKGFkbWluIG9ubHkpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsKCk6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL2FkbWluL3JlY2xhbWF0aW9uc2BcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCByZWNsYW1hdGlvbnM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJlY2xhbWF0aW9ucyBieSBzdGF0dXNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCeVN0YXR1cyhzdGF0dXM6IFwiT1BFTlwiIHwgXCJJTl9SRVZJRVdcIiB8IFwiUkVTT0xWRURcIiB8IFwiUkVKRUNURURcIik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL2FkbWluL3JlY2xhbWF0aW9ucy9zdGF0dXMvJHtzdGF0dXN9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHJlY2xhbWF0aW9uczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVjbGFtYXRpb24gYnkgSURcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCeUlkKHJlY2xhbWF0aW9uSWQ6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcmVjbGFtYXRpb24gc2V2ZXJpdHlcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVTZXZlcml0eShyZWNsYW1hdGlvbklkOiBudW1iZXIsIHNldmVyaXR5OiBcIkxPV1wiIHwgXCJNRURJVU1cIiB8IFwiSElHSFwiIHwgXCJDUklUSUNBTFwiKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL2FkbWluL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9L3NldmVyaXR5P3NldmVyaXR5PSR7c2V2ZXJpdHl9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIHVwZGF0ZSBzZXZlcml0eTogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXZpZXcgcmVjbGFtYXRpb24gKG1vdmUgdG8gSU5fUkVWSUVXKVxuICAgICAqL1xuICAgIGFzeW5jIHJldmlldyhyZWNsYW1hdGlvbklkOiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvYWRtaW4vcmVjbGFtYXRpb25zLyR7cmVjbGFtYXRpb25JZH0vcmV2aWV3YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIHJldmlldyByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIHJlY2xhbWF0aW9uIHdpdGggcGVuYWx0eVxuICAgICAqL1xuICAgIGFzeW5jIHJlc29sdmUocmVjbGFtYXRpb25JZDogbnVtYmVyLCByZXNvbHV0aW9uTm90ZXM6IHN0cmluZywgYXBwcm92ZWQ6IGJvb2xlYW4pOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvYWRtaW4vcmVjbGFtYXRpb25zLyR7cmVjbGFtYXRpb25JZH0vcmVzb2x2ZWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcmVzb2x1dGlvbk5vdGVzLFxuICAgICAgICAgIGFwcHJvdmVkLFxuICAgICAgICB9KSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIHJlc29sdmUgcmVjbGFtYXRpb246ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVqZWN0IHJlY2xhbWF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgcmVqZWN0KHJlY2xhbWF0aW9uSWQ6IG51bWJlciwgcmVqZWN0aW9uTm90ZXM6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJzdWNjZXNzXCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9hZG1pbi9yZWNsYW1hdGlvbnMvJHtyZWNsYW1hdGlvbklkfS9yZWplY3RgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHJlamVjdGlvbk5vdGVzLFxuICAgICAgICB9KSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIHJlamVjdCByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVjbGFtYXRpb24gYXR0YWNobWVudHMgKGltYWdlcylcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBdHRhY2htZW50cyhyZWNsYW1hdGlvbklkOiBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9hZG1pbi9yZWNsYW1hdGlvbnMvJHtyZWNsYW1hdGlvbklkfS9hdHRhY2htZW50c2BcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBhdHRhY2htZW50czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVjbGFtYXRpb24gc3RhdGlzdGljc1xuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXRpc3RpY3MoKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICBvcGVuOiAwLFxuICAgICAgICAgIGluUmV2aWV3OiAwLFxuICAgICAgICAgIHJlc29sdmVkOiAwLFxuICAgICAgICAgIHJlamVjdGVkOiAwLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL2FkbWluL3JlY2xhbWF0aW9ucy9zdGF0aXN0aWNzYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHN0YXRpc3RpY3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuICB9LFxuXG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSBNQVJLRVQgVFJFTkRTID09PT09PT09PT09PT09PT09PT09XG4gIG1hcmtldFRyZW5kczoge1xuICAgIGFzeW5jIGdldEFsbENpdGllcyhwZXJpb2RNb250aHM6IG51bWJlciA9IDEyKSB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSByZXR1cm4geyB0cmVuZHM6IFtdLCBpbnNpZ2h0czogW10gfTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvbWFya2V0LXRyZW5kcy9hbGwtY2l0aWVzP3BlcmlvZF9tb250aHM9JHtwZXJpb2RNb250aHN9YCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggbWFya2V0IHRyZW5kc1wiKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSxcbiAgICBhc3luYyBnZXRDaXR5VHJlbmRzKGNpdHk6IHN0cmluZywgcGVyaW9kTW9udGhzOiBudW1iZXIgPSAxMikge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkgcmV0dXJuIHsgZGF0YV9wb2ludHM6IFtdIH07XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL21hcmtldC10cmVuZHMvY2l0eS8ke2NpdHl9P3BlcmlvZF9tb250aHM9JHtwZXJpb2RNb250aHN9YCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCB0cmVuZHMgZm9yICR7Y2l0eX1gKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSxcbiAgICBhc3luYyBnZXRJbnNpZ2h0cyhjaXR5OiBzdHJpbmcpIHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHJldHVybiBbXTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvbWFya2V0LXRyZW5kcy9pbnNpZ2h0cy8ke2NpdHl9YCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBpbnNpZ2h0cyBmb3IgJHtjaXR5fWApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBjb25zdCBhcGlCYXNlVXJsID0gQVBJX0JBU0VfVVJMXG5leHBvcnQgY29uc3QgYXBpVmVyc2lvbiA9IEFQSV9WRVJTSU9OXG4iXSwibmFtZXMiOlsiR0FURVdBWV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfR0FURVdBWV9VUkwiLCJVU0VfR0FURVdBWSIsIk5FWFRfUFVCTElDX1VTRV9HQVRFV0FZIiwiQVBJX0JBU0VfVVJMIiwiTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMIiwiUFJPUEVSVFlfQVBJX0JBU0VfVVJMIiwiTkVYVF9QVUJMSUNfUFJPUEVSVFlfQVBJX0JBU0VfVVJMIiwiQk9PS0lOR19BUElfQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19CT09LSU5HX0FQSV9CQVNFX1VSTCIsIlBBWU1FTlRfQVBJX0JBU0VfVVJMIiwiTkVYVF9QVUJMSUNfUEFZTUVOVF9BUElfQkFTRV9VUkwiLCJSRUNMQU1BVElPTl9BUElfQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19SRUNMQU1BVElPTl9BUElfQkFTRV9VUkwiLCJBUElfVkVSU0lPTiIsIk5FWFRfUFVCTElDX0FQSV9WRVJTSU9OIiwiQVVUSF9UT0tFTl9LRVkiLCJORVhUX1BVQkxJQ19BVVRIX1NUT1JBR0VfS0VZIiwiVVNFUl9EQVRBX0tFWSIsIk5FWFRfUFVCTElDX1VTRVJfU1RPUkFHRV9LRVkiLCJVU0VfTU9DS19BUEkiLCJnZXRNb2NrQXBpIiwibW9ja0FwaUNsaWVudCIsIkVycm9yIiwiZGVjb2RlSldUIiwidG9rZW4iLCJwYXJ0cyIsInNwbGl0IiwibGVuZ3RoIiwicGF5bG9hZCIsImRlY29kZWQiLCJKU09OIiwicGFyc2UiLCJhdG9iIiwicmVwbGFjZSIsInVzZXJJZCIsInN1YiIsInN1YmplY3QiLCJyb2xlcyIsImVycm9yIiwiZ2V0QXV0aEhlYWRlcnMiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidXNlckRhdGEiLCJmaW5hbFVzZXJJZCIsInVzZXIiLCJpZCIsInVzZXJJZFN0cmluZyIsIlN0cmluZyIsImhlYWRlcnMiLCJqb2luIiwiQXV0aG9yaXphdGlvbiIsImdldFNlcnZpY2VVcmwiLCJzZXJ2aWNlIiwiYnVpbGRVcmwiLCJwYXRoIiwiYmFzZVVybCIsInN0YXJ0c1dpdGgiLCJiYXNlUGF0aCIsInJlcXVlc3QiLCJvcHRpb25zIiwicmVxdWlyZXNBdXRoIiwiZmV0Y2hPcHRpb25zIiwidXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiZXJyb3JEYXRhIiwicmVzcG9uc2VUZXh0IiwidGV4dCIsInBhcnNlRXJyb3IiLCJtZXNzYWdlIiwicmF3IiwidGV4dEVycm9yIiwiT2JqZWN0Iiwia2V5cyIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJlcnJvck1lc3NhZ2UiLCJkZXRhaWwiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvcnMiLCJhcGlFcnJvciIsImNvbnRlbnRUeXBlIiwiZ2V0IiwiaW5jbHVkZXMiLCJkYXRhIiwianNvbiIsImNvbm5lY3Rpb25FcnJvciIsImlzQ29ubmVjdGlvbkVycm9yIiwicmVxdWVzdEZvcm1EYXRhIiwiZm9ybURhdGEiLCJtZXRob2QiLCJib2R5IiwiY2F0Y2giLCJhcGlDbGllbnQiLCJwcm9wZXJ0aWVzIiwiZ2V0QWxsIiwibW9jayIsImdldEFsbEZvckFkbWluIiwiYXV0aEhlYWRlcnMiLCJnZXRCeUlkIiwiZ2V0TXlQcm9wZXJ0aWVzIiwiY3JlYXRlIiwiaW1hZ2VzIiwicmVzdWx0IiwicHJvcGVydHlJZCIsIkZvcm1EYXRhIiwiaW5wdXRCbG9iIiwiQmxvYiIsInN0cmluZ2lmeSIsInR5cGUiLCJhcHBlbmQiLCJmb3JFYWNoIiwiZmlsZSIsInVwZGF0ZSIsInBhcnNlZCIsInN1Y2Nlc3MiLCJkZWxldGUiLCJhcHByb3ZlIiwiaXNBcHByb3ZlZCIsImhpZGUiLCJpc0hpZGRlbiIsInN1c3BlbmQiLCJyZWFzb24iLCJyZXZva2VTdXNwZW5zaW9uIiwic3VibWl0Rm9yQXBwcm92YWwiLCJjYW5jZWxBcHByb3ZhbFJlcXVlc3QiLCJwcmVkaWN0UHJpY2UiLCJjaGVja0luRGF0ZSIsImNoZWNrT3V0RGF0ZSIsInByZWRpY3RlZFByaWNlTWFkIiwicHJlZGljdGVkUHJpY2VVc2QiLCJjb25maWRlbmNlSW50ZXJ2YWxMb3dlciIsImNvbmZpZGVuY2VJbnRlcnZhbFVwcGVyIiwiY2l0eSIsInNlYXNvbiIsIm1vZGVsVmVyc2lvbiIsInByZWRpY3Rpb25UaW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjdXJyZW50UHJpY2VNYWQiLCJwcmljZURpZmZlcmVuY2VQZXJjZW50IiwicmVjb21tZW5kYXRpb24iLCJyaXNrIiwiZ2V0VGVuYW50Umlza1Njb3JlIiwidGVuYW50SWQiLCJjb25zb2xlIiwicmVjb21tZW5kYXRpb25zIiwiZ2V0Rm9yVGVuYW50IiwibWF4UmVzdWx0cyIsImdldFNpbWlsYXIiLCJ2ZXJpZmljYXRpb25SZXF1ZXN0cyIsImdldEJ5U3RhdHVzIiwiZGVzY3JpcHRpb24iLCJyZWplY3QiLCJwcm9wZXJ0eVR5cGVzIiwidXNlcnMiLCJnZXRNZSIsImZpcnN0TmFtZSIsImxhc3ROYW1lIiwiZW1haWwiLCJwaG9uZU51bWJlciIsInNjb3JlIiwiYWxsVXNlcnMiLCJmaW5kIiwidSIsInByb2ZpbGVQaWN0dXJlIiwiYmlydGhkYXkiLCJ3YWxsZXRBZGRyZXNzIiwiZW5hYmxlZCIsImVyciIsInVwZGF0ZU1lIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ1cGRhdGVQcm9maWxlUGljdHVyZSIsImNoYW5nZVBhc3N3b3JkIiwiY3VycmVudFBhc3N3b3JkIiwibmV3UGFzc3dvcmQiLCJkZWxldGVQcm9maWxlUGljdHVyZSIsImJlY29tZUhvc3QiLCJlbmFibGVVc2VyIiwiZGlzYWJsZVVzZXIiLCJhZGRBZG1pblJvbGUiLCJyZW1vdmVBZG1pblJvbGUiLCJhZGRIb3N0Um9sZUJ5QWRtaW4iLCJyZW1vdmVIb3N0Um9sZSIsImF1dGgiLCJyZWdpc3RlciIsInNldFRpbWVvdXQiLCJyZXF1ZXN0Qm9keSIsInBhc3N3b3JkIiwicm9sZSIsImxvZ2luIiwic2V0QXV0aCIsInNldEl0ZW0iLCJnZXRUb2tlbiIsImdldFVzZXIiLCJjbGVhckF1dGgiLCJyZW1vdmVJdGVtIiwiaGFzUm9sZSIsInZlcmlmeSIsInZlcmlmaWNhdGlvbkNvZGUiLCJyZXNlbmRWZXJpZmljYXRpb25Db2RlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZm9yZ290UGFzc3dvcmQiLCJ2ZXJpZnlSZXNldFRva2VuIiwidmFsaWQiLCJyZXNldFBhc3N3b3JkIiwidmVyaWZ5UmVzZXRDb2RlIiwiY29kZSIsInJlc2V0UGFzc3dvcmRXaXRoQ29kZSIsImJvb2tpbmdzIiwicGFyc2VJbnQiLCJudW1iZXJPZkd1ZXN0cyIsInJlcXVlc3RlZFByaWNlIiwicmVzcG9uc2VEYXRhIiwiZ2V0QnlUZW5hbnRJZCIsImdldEN1cnJlbnRCb29raW5nIiwiZ2V0UGVuZGluZ0Jvb2tpbmdzIiwiZ2V0QXdhaXRpbmdQYXltZW50Qm9va2luZ3MiLCJnZXRQcm9wZXJ0eUluZm8iLCJvd25lcklkIiwicHJpY2VQZXJOaWdodCIsImlzTmVnb3RpYWJsZSIsImRpc2NvdW50RW5hYmxlZCIsImdldExhc3RCb29raW5nSWQiLCJib29raW5nSWQiLCJlcnJvckNvZGUiLCJ0ZW5hbnRDaGVja291dCIsIm93bmVyQ29uZmlybUNoZWNrb3V0IiwibWFya0FzQ2hlY2tlZE91dCIsImdldEN1cnJlbnRCb29raW5nc0J5T3duZXIiLCJnZXRQZW5kaW5nTmVnb3RpYXRpb25zIiwiYWNjZXB0TmVnb3RpYXRpb24iLCJyZWplY3ROZWdvdGlhdGlvbiIsImdldEJ5T3duZXJJZCIsImdldENvbmZpcm1lZEJvb2tpbmdzQnlPd25lciIsImdldENvbmZpcm1lZEJvb2tpbmdzQnlQcm9wZXJ0eSIsInJlcG9ydERpc3B1dGUiLCJwYXltZW50cyIsImNyZWF0ZUludGVudCIsInJlZmVyZW5jZUlkIiwidG8iLCJ2YWx1ZSIsImNoYWluSWQiLCJ0b3RhbEFtb3VudFdlaSIsImdldEJvb2tpbmdEZXRhaWxzIiwidG90YWxQcmljZSIsInByb3BlcnR5VGl0bGUiLCJwcm9wZXJ0eVByaWNlIiwib3duZXJXYWxsZXRBZGRyZXNzIiwiY3VycmVudFVzZXJJZCIsInVzZXJGaXJzdE5hbWUiLCJ1c2VyTGFzdE5hbWUiLCJ1c2VyRW1haWwiLCJ1c2VyV2FsbGV0QWRkcmVzcyIsImUiLCJ1cGRhdGVXYWxsZXRBZGRyZXNzIiwidXBkYXRlVHJhbnNhY3Rpb25IYXNoIiwidHhIYXNoIiwiZ2V0VHJhbnNhY3Rpb25TdGF0dXMiLCJibG9ja051bWJlciIsImNvbXBsZXRlQm9va2luZyIsImVycm9yVGV4dCIsInJlY2xhbWF0aW9ucyIsImNvbXBsYWluYW50Um9sZSIsInJlY2xhbWF0aW9uVHlwZSIsInRpdGxlIiwiaW1hZ2UiLCJnZXRNeUNvbXBsYWludHMiLCJnZXRDb21wbGFpbnRzQWdhaW5zdE1lIiwidXBsb2FkQXR0YWNobWVudHMiLCJyZWNsYW1hdGlvbklkIiwiZmlsZXMiLCJnZXRCeUJvb2tpbmdJZEFuZENvbXBsYWluYW50IiwiY29tcGxhaW5hbnRJZCIsImdldEF0dGFjaG1lbnRzIiwiZ2V0VXNlclBob25lTnVtYmVyIiwiYWRtaW5SZWNsYW1hdGlvbnMiLCJ1cGRhdGVTZXZlcml0eSIsInNldmVyaXR5IiwicmV2aWV3IiwicmVzb2x1dGlvbk5vdGVzIiwiYXBwcm92ZWQiLCJyZWplY3Rpb25Ob3RlcyIsImdldFN0YXRpc3RpY3MiLCJ0b3RhbCIsIm9wZW4iLCJpblJldmlldyIsInJlc29sdmVkIiwicmVqZWN0ZWQiLCJtYXJrZXRUcmVuZHMiLCJnZXRBbGxDaXRpZXMiLCJwZXJpb2RNb250aHMiLCJ0cmVuZHMiLCJpbnNpZ2h0cyIsImdldENpdHlUcmVuZHMiLCJkYXRhX3BvaW50cyIsImdldEluc2lnaHRzIiwiYXBpQmFzZVVybCIsImFwaVZlcnNpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/services/api.ts\n"));

/***/ })

});