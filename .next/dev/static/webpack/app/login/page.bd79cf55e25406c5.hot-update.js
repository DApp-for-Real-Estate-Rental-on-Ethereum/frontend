"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./lib/services/api.ts":
/*!*****************************!*\
  !*** ./lib/services/api.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiBaseUrl: () => (/* binding */ apiBaseUrl),\n/* harmony export */   apiClient: () => (/* binding */ apiClient),\n/* harmony export */   apiVersion: () => (/* binding */ apiVersion)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n/**\n * API Service Layer\n *\n * Centralized API communication service that handles:\n * - Base URL configuration from environment variables\n * - Authentication headers (X-User-Id, X-User-Roles)\n * - Request/response interceptors\n * - Error handling\n *\n * Usage:\n * import { apiClient } from '@/lib/services/api'\n * const properties = await apiClient.properties.getAll()\n *\n * Environment Variables (in .env.local):\n * - NEXT_PUBLIC_API_BASE_URL: Backend API base URL (e.g., http://localhost:8080)\n * - NEXT_PUBLIC_API_VERSION: API version path (default: v1)\n */ // Configuration from environment variables\n// Use API Gateway (port 8090) as the single entry point for all services\n// If GATEWAY_URL is not set, fall back to individual service URLs for backward compatibility\nconst GATEWAY_URL = process.env.NEXT_PUBLIC_GATEWAY_URL || \"http://localhost:8090\";\nconst USE_GATEWAY = process.env.NEXT_PUBLIC_USE_GATEWAY !== \"false\" // Default to true\n;\n// Fallback URLs for individual services (used if USE_GATEWAY is false)\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || \"http://localhost:8082\";\nconst PROPERTY_API_BASE_URL = process.env.NEXT_PUBLIC_PROPERTY_API_BASE_URL || \"http://localhost:8081\";\nconst BOOKING_API_BASE_URL = USE_GATEWAY ? GATEWAY_URL : process.env.NEXT_PUBLIC_BOOKING_API_BASE_URL || \"http://localhost:8083\";\nconst PAYMENT_API_BASE_URL = process.env.NEXT_PUBLIC_PAYMENT_API_BASE_URL || \"http://localhost:8085\";\nconst RECLAMATION_API_BASE_URL = process.env.NEXT_PUBLIC_RECLAMATION_API_BASE_URL || \"http://localhost:8091\";\nconst API_VERSION = process.env.NEXT_PUBLIC_API_VERSION || \"v1\";\nconst AUTH_TOKEN_KEY = process.env.NEXT_PUBLIC_AUTH_STORAGE_KEY || \"derent5_auth_token\";\nconst USER_DATA_KEY = process.env.NEXT_PUBLIC_USER_STORAGE_KEY || \"derent5_user_data\";\n// USE_MOCK_API is true if explicitly set to \"true\", otherwise false (use real API)\nconst USE_MOCK_API = process.env.NEXT_PUBLIC_USE_MOCK_API === \"true\";\n// Only import mock API if needed (tree-shake when not used)\nlet mockApiClient = null;\nasync function getMockApi() {\n    if (!mockApiClient) {\n        const { mockApi } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_mock-api_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/lib/mock-api */ \"(app-pages-browser)/./lib/mock-api.ts\"));\n        mockApiClient = mockApi;\n    }\n    return mockApiClient;\n}\n/**\n * Decode JWT token to extract userId from subject\n */ function decodeJWT(token) {\n    try {\n        // JWT format: header.payload.signature\n        const parts = token.split(\".\");\n        if (parts.length !== 3) return null;\n        // Decode payload (base64url)\n        const payload = parts[1];\n        const decoded = JSON.parse(atob(payload.replace(/-/g, \"+\").replace(/_/g, \"/\")));\n        return {\n            userId: decoded.sub || decoded.subject,\n            roles: decoded.roles || []\n        };\n    } catch (error) {\n        return null;\n    }\n}\n/**\n * Get authentication headers from localStorage\n * Used for all API requests that require user context\n */ function getAuthHeaders() {\n    // Only run in browser\n    if (false) {}\n    const token = localStorage.getItem(AUTH_TOKEN_KEY);\n    if (!token) {\n        return {};\n    }\n    // Try to get userId from JWT token first\n    const decoded = decodeJWT(token);\n    const userId = decoded?.userId;\n    // Fallback to user data from localStorage\n    const userData = localStorage.getItem(USER_DATA_KEY);\n    let finalUserId = userId;\n    let roles = decoded?.roles || [];\n    if (userData) {\n        try {\n            const user = JSON.parse(userData);\n            finalUserId = finalUserId || user.id || \"\";\n            roles = roles.length > 0 ? roles : user.roles || [];\n        } catch (error) {\n        // Failed to parse user data\n        }\n    }\n    // Ensure userId is always a string (convert number to string if needed)\n    const userIdString = finalUserId ? String(finalUserId) : \"\";\n    const headers = {\n        \"X-User-Id\": userIdString,\n        \"X-User-Roles\": roles.join(\",\"),\n        ...token && {\n            Authorization: `Bearer ${token}`\n        }\n    };\n    return headers;\n}\n/**\n * Helper function to get the correct base URL for a service\n * Uses Gateway if enabled, otherwise falls back to individual service URLs\n */ function getServiceUrl(service) {\n    if (USE_GATEWAY) {\n        // All services go through the Gateway\n        return GATEWAY_URL;\n    }\n    // Fallback to individual service URLs\n    switch(service){\n        case 'auth':\n        case 'users':\n            return API_BASE_URL;\n        case 'properties':\n            return PROPERTY_API_BASE_URL;\n        case 'bookings':\n            return BOOKING_API_BASE_URL;\n        case 'payments':\n            return PAYMENT_API_BASE_URL;\n        case 'reclamations':\n        case 'admin-reclamations':\n            return RECLAMATION_API_BASE_URL;\n        default:\n            return API_BASE_URL;\n    }\n}\n/**\n * Build full URL with base and version\n * For Gateway, path already includes /api/v1/..., so we don't add it again\n */ function buildUrl(path, service = 'users') {\n    const baseUrl = getServiceUrl(service);\n    if (USE_GATEWAY) {\n        // Gateway routes preserve the full path\n        // Path should already include /api/v1/... or /api/... prefix\n        // If path doesn't start with /api, add the appropriate prefix based on service\n        if (path.startsWith('/api/')) {\n            return `${baseUrl}${path}`;\n        }\n        // Add appropriate prefix based on service\n        if (service === 'auth' || service === 'users') {\n            return `${baseUrl}/api/v1${path}`;\n        } else if (service === 'properties') {\n            return `${baseUrl}/api/v1${path}`;\n        } else if (service === 'bookings') {\n            return `${baseUrl}/api${path}`;\n        } else if (service === 'payments') {\n            return `${baseUrl}/api${path}`;\n        } else if (service === 'reclamations' || service === 'admin-reclamations') {\n            return `${baseUrl}/api${path}`;\n        }\n        return `${baseUrl}${path}`;\n    }\n    // For direct service calls, add version prefix\n    const basePath = `/api/${API_VERSION}`;\n    return `${baseUrl}${basePath}${path}`;\n}\n/**\n * Generic fetch wrapper with error handling\n */ async function request(path, options = {}) {\n    const { requiresAuth = true, service = 'users', ...fetchOptions } = options;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        ...requiresAuth && getAuthHeaders(),\n        ...fetchOptions.headers\n    };\n    const url = buildUrl(path, service);\n    try {\n        const response = await fetch(url, {\n            ...fetchOptions,\n            headers\n        });\n        if (!response.ok) {\n            let errorData = {};\n            let responseText = \"\";\n            try {\n                responseText = await response.text();\n                if (responseText) {\n                    try {\n                        errorData = JSON.parse(responseText);\n                    } catch (parseError) {\n                        // If JSON parsing fails, use the raw text\n                        errorData = {\n                            message: responseText,\n                            raw: responseText\n                        };\n                    }\n                }\n            } catch (textError) {\n                errorData = {\n                    message: `Failed to read response: ${textError}`\n                };\n            }\n            // If errorData is still empty, create a default error\n            if (Object.keys(errorData).length === 0) {\n                errorData = {\n                    message: `HTTP ${response.status}: ${response.statusText}`,\n                    status: response.status,\n                    statusText: response.statusText\n                };\n            }\n            // Extract error message from ErrorResponse format (used by user-service)\n            // ErrorResponse has: timestamp, status, error, message, path\n            const errorMessage = errorData.message || // ErrorResponse.message\n            errorData.error || // ErrorResponse.error (error title)\n            errorData.detail || // Standard Spring error format\n            errorData.raw || // Raw response text if JSON parsing failed\n            (Array.isArray(errorData.errors) ? errorData.errors.join(\", \") : null) || // Validation errors array\n            (typeof errorData === 'string' ? errorData : null) || `API Error: ${response.status} ${response.statusText}`;\n            const apiError = new Error(errorMessage);\n            apiError.status = response.status;\n            apiError.errorData = errorData;\n            apiError.responseText = responseText;\n            throw apiError;\n        }\n        // Check if response has content\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.includes(\"application/json\")) {\n            const data = await response.json();\n            return data;\n        } else {\n            // If no JSON content, return empty object for successful responses\n            const text = await response.text();\n            if (text) {\n                // Try to parse as JSON, if fails return text as message\n                try {\n                    return JSON.parse(text);\n                } catch  {\n                    return {\n                        message: text\n                    };\n                }\n            }\n            return {};\n        }\n    } catch (error) {\n        // Check if it's a connection error\n        if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n            const connectionError = new Error(`Cannot connect to backend server at ${API_BASE_URL}. Please make sure the backend is running.`);\n            connectionError.isConnectionError = true;\n            throw connectionError;\n        }\n        throw error;\n    }\n}\n/**\n * Multipart form data request for file uploads\n */ async function requestFormData(path, formData, options = {}) {\n    const { requiresAuth = true, service = 'users', ...fetchOptions } = options;\n    const headers = {\n        ...requiresAuth && getAuthHeaders(),\n        ...fetchOptions.headers\n    };\n    // Don't set Content-Type for FormData - browser will set it with boundary\n    delete headers[\"Content-Type\"];\n    const url = buildUrl(path, service);\n    try {\n        const response = await fetch(url, {\n            method: \"POST\",\n            ...fetchOptions,\n            headers,\n            body: formData\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(errorData.message || `API Error: ${response.status}`);\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        throw error;\n    }\n}\n/**\n * API Client - Organized by resource\n */ const apiClient = {\n    // ==================== PROPERTIES ====================\n    properties: {\n        async getAll () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getAll();\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async getAllForAdmin () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getAll();\n            }\n            // Use Gateway or property-service URL for admin endpoint\n            const url = buildUrl(\"/properties/admin/all\", 'properties');\n            const authHeaders = getAuthHeaders();\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...authHeaders\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    const errorMessage = errorData.error || errorData.message || `API Error: ${response.status}`;\n                    throw new Error(errorMessage);\n                }\n                const data = await response.json();\n                // Ensure data is an array\n                if (!Array.isArray(data)) {\n                    // If it's an error object, throw it\n                    if (data.error || data.message) {\n                        throw new Error(data.error || data.message || \"Invalid response format\");\n                    }\n                    // Otherwise return empty array\n                    return [];\n                }\n                return data;\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async getById (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getById(id);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async getMyProperties () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getAll();\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/my-properties`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    const errorMessage = errorData.error || errorData.message || `API Error: ${response.status}`;\n                    throw new Error(errorMessage);\n                }\n                const data = await response.json();\n                // Ensure data is an array\n                if (!Array.isArray(data)) {\n                    // If it's an error object, throw it\n                    if (data.error || data.message) {\n                        throw new Error(data.error || data.message || \"Invalid response format\");\n                    }\n                    // Otherwise return empty array\n                    return [];\n                }\n                return data;\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async create (data, images) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                const result = await mock.properties.create(data, images);\n                return {\n                    propertyId: result.id,\n                    id: result.id\n                };\n            }\n            const formData = new FormData();\n            // Create a Blob with JSON content type for the input part\n            // Spring's @RequestPart expects Content-Type: application/json for JSON parts\n            const inputBlob = new Blob([\n                JSON.stringify(data)\n            ], {\n                type: \"application/json\"\n            });\n            formData.append(\"input\", inputBlob);\n            images.forEach((file)=>{\n                formData.append(\"images\", file);\n            });\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties`;\n            const headers = {\n                ...getAuthHeaders()\n            };\n            // Don't set Content-Type header - let browser set it with boundary for multipart/form-data\n            try {\n                const response = await fetch(url, {\n                    method: \"POST\",\n                    headers,\n                    body: formData\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                const result = await response.json();\n                return result;\n            } catch (error) {\n                throw error;\n            }\n        },\n        async update (id, data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.update(id, data);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PUT\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify(data)\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                // Backend returns \"Property updated\" as plain text, not JSON\n                const responseText = await response.text();\n                try {\n                    const parsed = JSON.parse(responseText);\n                    return parsed;\n                } catch  {\n                    // If it's not JSON, return success object\n                    return {\n                        success: true\n                    };\n                }\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async delete (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.delete(id);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"DELETE\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async approve (id, isApproved) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.approve(id, isApproved);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/approve`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify({\n                        isApproved\n                    })\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        /**\n     * Hide property\n     */ async hide (id, isHidden) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return {\n                    success: true\n                };\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/hide`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify({\n                        isHidden\n                    })\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async suspend (id, reason) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.suspend(id, reason);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/suspend`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify({\n                        reason\n                    })\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async revokeSuspension (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.suspend(id, \"\") // Mock\n                ;\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/revoke-suspension`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async submitForApproval (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.approve(id, true);\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/submit-for-approval`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async cancelApprovalRequest (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return {\n                    success: true\n                };\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/cancel-approval-request`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        /**\n     * Get AI-powered price suggestion for a property and date range.\n     * This calls property-service, which forwards the request to the pricing model API.\n     */ async predictPrice (propertyId, checkInDate, checkOutDate) {\n            if (USE_MOCK_API) {\n                // Lightweight mock for UI development\n                return {\n                    predictedPriceMad: 430,\n                    predictedPriceUsd: 43,\n                    confidenceIntervalLower: 380,\n                    confidenceIntervalUpper: 480,\n                    city: \"casablanca\",\n                    season: \"summer\",\n                    modelVersion: \"1.0\",\n                    predictionTimestamp: new Date().toISOString(),\n                    currentPriceMad: 400,\n                    priceDifferencePercent: 7.5,\n                    recommendation: \"INCREASE\"\n                };\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${propertyId}/predict-price`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    propertyId,\n                    checkInDate,\n                    checkOutDate\n                })\n            });\n            const data = await response.json().catch(()=>({}));\n            if (!response.ok) {\n                const message = data?.message || data?.error || (typeof data === \"string\" ? data : null) || `Failed to get price suggestion: ${response.status}`;\n                throw new Error(message);\n            }\n            return data;\n        }\n    },\n    // ==================== TENANT RISK ====================\n    risk: {\n        getTenantRiskScore: async (tenantId)=>{\n            try {\n                // Use local Next.js proxy\n                const response = await fetch(`/api/tenant-risk/${tenantId}`, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    }\n                });\n                if (!response.ok) {\n                    throw new Error(`ML API Error: ${response.status} ${response.statusText}`);\n                }\n                return response.json();\n            } catch (error) {\n                console.error(\"Error fetching risk score:\", error);\n                throw error;\n            }\n        }\n    },\n    recommendations: {\n        getForTenant: async (tenantId, maxResults = 3)=>{\n            try {\n                const response = await fetch(`/api/recommendations/tenant/${tenantId}?max_results=${maxResults}`);\n                if (!response.ok) throw new Error(\"Failed to fetch recommendations\");\n                return response.json();\n            } catch (error) {\n                console.error(\"Error fetching recommendations:\", error);\n                throw error;\n            }\n        },\n        getSimilar: async (propertyId, maxResults = 3)=>{\n            try {\n                const response = await fetch(`/api/recommendations/similar/${propertyId}?max_results=${maxResults}`);\n                if (!response.ok) throw new Error(\"Failed to fetch similar properties\");\n                return response.json();\n            } catch (error) {\n                console.error(\"Error fetching similar properties:\", error);\n                throw error;\n            }\n        }\n    },\n    // ==================== VERIFICATION REQUESTS ====================\n    verificationRequests: {\n        async getAll () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.getAll();\n            }\n            return request(\"/verification-requests\");\n        },\n        async getByStatus (status) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.getByStatus(status);\n            }\n            return request(`/verification-requests/by-status/${status}`);\n        },\n        async create (propertyId, description) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.create(propertyId, description);\n            }\n            return request(\"/verification-requests\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    propertyId,\n                    description\n                })\n            });\n        },\n        async approve (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.approve(id);\n            }\n            return request(`/verification-requests/${id}/approve`, {\n                method: \"PATCH\"\n            });\n        },\n        async reject (id, reason) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.reject(id, reason);\n            }\n            return request(`/verification-requests/${id}/reject`, {\n                method: \"PATCH\",\n                body: JSON.stringify({\n                    reason\n                })\n            });\n        }\n    },\n    // ==================== PROPERTY TYPES ====================\n    propertyTypes: {\n        async getAll () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.propertyTypes.getAll();\n            }\n            return request(\"/property-types\", {\n                requiresAuth: false\n            });\n        },\n        async getById (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.propertyTypes.getById(id);\n            }\n            return request(`/property-types/${id}`, {\n                requiresAuth: false\n            });\n        }\n    },\n    // ==================== USERS ====================\n    users: {\n        async getMe () {\n            if (USE_MOCK_API) {\n                // Mock user data for development\n                return {\n                    firstName: \"Mock\",\n                    lastName: \"User\",\n                    email: \"mock@example.com\"\n                };\n            }\n            return request(\"/users/me\", {\n                method: \"GET\",\n                requiresAuth: true\n            });\n        },\n        /**\n     * Get user information by ID (for getting phone number, etc.)\n     */ async getById (userId) {\n            if (USE_MOCK_API) {\n                return {\n                    firstName: \"Mock\",\n                    lastName: \"User\",\n                    email: \"mock@example.com\",\n                    phoneNumber: 1234567890,\n                    score: 100\n                };\n            }\n            // Try to get from admin endpoint first (if user is admin) for more details\n            try {\n                const allUsers = await this.getAllForAdmin();\n                const user = allUsers.find((u)=>String(u.id) === String(userId));\n                if (user) {\n                    return {\n                        firstName: user.firstName,\n                        lastName: user.lastName,\n                        email: user.email,\n                        profilePicture: user.profilePicture,\n                        birthday: user.birthday,\n                        phoneNumber: user.phoneNumber,\n                        walletAddress: user.walletAddress,\n                        roles: user.roles,\n                        score: user.score,\n                        enabled: user.enabled\n                    };\n                }\n            } catch (err) {\n            // If admin endpoint fails, fallback to regular endpoint\n            }\n            // Fallback to regular endpoint\n            return request(`/users/${userId}`, {\n                method: \"GET\",\n                requiresAuth: true\n            });\n        },\n        async updateMe (data) {\n            if (USE_MOCK_API) {\n                // Mock update\n                return Promise.resolve();\n            }\n            return request(\"/users/me\", {\n                method: \"PUT\",\n                body: JSON.stringify(data),\n                requiresAuth: true\n            });\n        },\n        async updateProfilePicture (file) {\n            if (USE_MOCK_API) {\n                return {\n                    url: \"/placeholder-user.jpg\"\n                };\n            }\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            const headers = getAuthHeaders();\n            // Remove Content-Type header to let browser set it with boundary for multipart/form-data\n            delete headers[\"Content-Type\"];\n            const url = buildUrl(\"/users/me/profile-picture\");\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers,\n                body: formData\n            });\n            if (!response.ok) {\n                let errorData = {};\n                let responseText = \"\";\n                try {\n                    responseText = await response.text();\n                    if (responseText) {\n                        try {\n                            errorData = JSON.parse(responseText);\n                        } catch  {\n                            errorData = {\n                                message: responseText,\n                                raw: responseText\n                            };\n                        }\n                    }\n                } catch  {\n                    errorData = {\n                        message: `HTTP ${response.status}: ${response.statusText}`\n                    };\n                }\n                const errorMessage = errorData.message || errorData.error || errorData.raw || `API Error: ${response.status} ${response.statusText}`;\n                const apiError = new Error(errorMessage);\n                apiError.status = response.status;\n                apiError.errorData = errorData;\n                throw apiError;\n            }\n            const text = await response.text();\n            return {\n                url: text\n            } // Backend returns URL as plain text\n            ;\n        },\n        async changePassword (currentPassword, newPassword) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Password changed successfully\"\n                };\n            }\n            return request(\"/users/me/change-password\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    currentPassword,\n                    newPassword\n                })\n            });\n        },\n        async deleteProfilePicture () {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(\"/users/me/profile-picture\", {\n                method: \"DELETE\",\n                requiresAuth: true\n            });\n        },\n        async becomeHost () {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(\"/users/me/become-host\", {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async getAllForAdmin () {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            return request(\"/users/admin/all\", {\n                method: \"GET\",\n                requiresAuth: true\n            });\n        },\n        async enableUser (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/enable`, {\n                method: \"POST\",\n                body: JSON.stringify({}),\n                requiresAuth: true\n            });\n        },\n        async disableUser (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/disable`, {\n                method: \"POST\",\n                body: JSON.stringify({}),\n                requiresAuth: true\n            });\n        },\n        async addAdminRole (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/add-admin-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async removeAdminRole (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/remove-admin-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async addHostRoleByAdmin (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/add-host-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async removeHostRole (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/remove-host-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        }\n    },\n    // ==================== AUTHENTICATION ====================\n    auth: {\n        async register (data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                // Mock registration - simulate delay\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"User registered successfully\"\n                };\n            }\n            try {\n                const requestBody = {\n                    firstName: data.firstName,\n                    lastName: data.lastName,\n                    email: data.email,\n                    password: data.password,\n                    birthday: data.birthday,\n                    phoneNumber: data.phoneNumber,\n                    ...data.role && {\n                        role: data.role\n                    }\n                };\n                return await request(\"/auth/register\", {\n                    method: \"POST\",\n                    body: JSON.stringify(requestBody),\n                    requiresAuth: false\n                });\n            } catch (error) {\n                // If connection fails, throw with helpful message\n                if (error?.isConnectionError) {\n                    throw new Error(\"Backend server is not available. Please make sure the user-service is running on port 8080.\");\n                }\n                throw error;\n            }\n        },\n        async login (email, password) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                // Mock login - would use mock data\n                throw new Error(\"Mock login not implemented - use useAuth hook\");\n            }\n            return request(\"/auth/login\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    password\n                }),\n                requiresAuth: false\n            });\n        },\n        setAuth (token, user) {\n            if (true) {\n                localStorage.setItem(AUTH_TOKEN_KEY, token);\n                localStorage.setItem(USER_DATA_KEY, JSON.stringify(user));\n            }\n        },\n        getToken () {\n            if (false) {}\n            return localStorage.getItem(AUTH_TOKEN_KEY);\n        },\n        getUser () {\n            if (false) {}\n            const userData = localStorage.getItem(USER_DATA_KEY);\n            return userData ? JSON.parse(userData) : null;\n        },\n        clearAuth () {\n            if (true) {\n                localStorage.removeItem(AUTH_TOKEN_KEY);\n                localStorage.removeItem(USER_DATA_KEY);\n            }\n        },\n        hasRole (role) {\n            const user = this.getUser();\n            return user?.roles.includes(role) ?? false;\n        },\n        async verify (email, verificationCode) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"User verified successfully\"\n                };\n            }\n            return request(\"/auth/verify\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    verificationCode\n                }),\n                requiresAuth: false\n            });\n        },\n        async resendVerificationCode (email) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"Verification Code resent successfully\"\n                };\n            }\n            return request(`/auth/resend?email=${encodeURIComponent(email)}`, {\n                method: \"POST\",\n                requiresAuth: false\n            });\n        },\n        async forgotPassword (email) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return;\n            }\n            return request(\"/auth/forgot-password\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email\n                }),\n                requiresAuth: false\n            });\n        },\n        async verifyResetToken (token) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    valid: true\n                };\n            }\n            return request(\"/auth/verify-reset-token\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    token\n                }),\n                requiresAuth: false\n            });\n        },\n        async resetPassword (token, password) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return;\n            }\n            return request(\"/auth/reset-password\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    token,\n                    password\n                }),\n                requiresAuth: false\n            });\n        },\n        async verifyResetCode (email, code) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    valid: true\n                };\n            }\n            return request(\"/auth/verify-reset-code\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    code\n                }),\n                requiresAuth: false\n            });\n        },\n        async resetPasswordWithCode (email, code, newPassword) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"Password reset successfully\"\n                };\n            }\n            return request(\"/auth/reset-password-with-code\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    code,\n                    newPassword\n                }),\n                requiresAuth: false\n            });\n        }\n    },\n    bookings: {\n        /**\n     * Get all bookings for admin\n     */ async getAllForAdmin () {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/admin/all`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `Failed to fetch bookings: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n                    const connectionError = new Error(`Cannot connect to booking-service backend at ${BOOKING_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        /**\n     * Create a booking request\n     * Sends booking data to booking-service via RabbitMQ\n     */ async create (data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.create?.(data) || {\n                    status: \"accepted\",\n                    message: \"Booking request sent\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/request`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    userId: typeof data.userId === \"string\" ? parseInt(data.userId) : data.userId,\n                    propertyId: data.propertyId,\n                    checkInDate: data.checkInDate,\n                    checkOutDate: data.checkOutDate,\n                    numberOfGuests: data.numberOfGuests,\n                    requestedPrice: data.requestedPrice\n                })\n            });\n            const responseData = await response.json();\n            if (!response.ok) {\n                // If status is \"rejected\", return the response data instead of throwing\n                if (responseData.status === \"rejected\") {\n                    return responseData;\n                }\n                throw new Error(responseData.message || `Failed to create booking: ${response.status}`);\n            }\n            return responseData;\n        },\n        /**\n     * Get booking by ID\n     */ async getById (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.getById?.(id) || null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                if (response.status === 404) {\n                    return null;\n                }\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch booking: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get bookings by tenant ID\n     */ async getByTenantId (tenantId) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.getByTenantId?.(tenantId) || [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings?tenantId=${tenantId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get current booking for a user\n     */ async getCurrentBooking (userId) {\n            if (USE_MOCK_API) {\n                // Mock: return null for now (no current booking)\n                return null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/current?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (response.status === 204 || response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch current booking: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get pending bookings (negotiations) for a user\n     */ async getPendingBookings (userId) {\n            if (USE_MOCK_API) {\n                // Mock: return empty array\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/pending?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch pending bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get awaiting payment bookings for a user\n     */ async getAwaitingPaymentBookings (userId) {\n            if (USE_MOCK_API) {\n                // Mock: return empty array\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/payment?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch awaiting payment bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get property info for booking (price, discount, negotiation)\n     */ async getPropertyInfo (propertyId) {\n            if (USE_MOCK_API) {\n                // Mock property info\n                return {\n                    id: propertyId,\n                    ownerId: 1,\n                    pricePerNight: 100,\n                    isNegotiable: false,\n                    discountEnabled: false\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/property/${propertyId}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to booking-service backend at ${BOOKING_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        /**\n     * Get last booking ID (for polling after creation)\n     */ async getLastBookingId () {\n            if (USE_MOCK_API) {\n                return {\n                    bookingId: 1\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/booking-id`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n            if (response.status === 204 || response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                return null;\n            }\n            return response.json();\n        },\n        /**\n     * Update a booking\n     */ async update (id, data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.update?.(id, data) || null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    checkInDate: data.checkInDate,\n                    checkOutDate: data.checkOutDate,\n                    numberOfGuests: data.numberOfGuests,\n                    requestedPrice: data.requestedPrice\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                const errorMessage = errorData.message || errorData.error || `Failed to update booking: ${response.status}`;\n                const error = new Error(errorMessage);\n                error.status = response.status;\n                error.errorCode = errorData.error;\n                throw error;\n            }\n            const result = await response.json();\n            return result;\n        },\n        /**\n     * Delete/Cancel a booking (by tenant)\n     */ async delete (id, userId) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.delete?.(id, userId);\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"DELETE\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to cancel booking: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Tenant checkout (changes status to TENANT_CHECKED_OUT)\n     */ async tenantCheckout (id, tenantId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Tenant checked out successfully\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}/checkout/tenant?userId=${tenantId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to checkout: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Owner confirm checkout (changes status to COMPLETED)\n     */ async ownerConfirmCheckout (id, ownerId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Checkout confirmed successfully\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}/checkout/owner?userId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to confirm checkout: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * @deprecated Use tenantCheckout() or ownerConfirmCheckout() instead\n     */ async markAsCheckedOut (id, userId) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.markAsCheckedOut?.(id, userId) || null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}/checkout?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to mark as checked out: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get current bookings by owner (host)\n     */ async getCurrentBookingsByOwner (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/current/owner?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch current bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get pending negotiations by owner (host)\n     */ async getPendingNegotiations (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/negotiations?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch pending negotiations: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Accept negotiation (host)\n     */ async acceptNegotiation (bookingId, ownerId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Negotiation accepted\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${bookingId}/accept?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to accept negotiation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Reject negotiation (host)\n     */ async rejectNegotiation (bookingId, ownerId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Negotiation rejected\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${bookingId}/reject?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to reject negotiation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get all bookings by owner (host)\n     */ async getByOwnerId (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get confirmed bookings by owner (host)\n     */ async getConfirmedBookingsByOwner (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/confirmed/owner?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch confirmed bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get confirmed bookings by property ID\n     */ async getConfirmedBookingsByProperty (propertyId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/confirmed/property/${propertyId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch confirmed bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Report dispute (host or tenant)\n     */ async reportDispute (bookingId, userId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Dispute reported\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${bookingId}/dispute?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to report dispute: ${response.status}`);\n            }\n            return response.json();\n        }\n    },\n    /**\n   * Payment Service API\n   */ payments: {\n        /**\n     * Create payment intent\n     */ async createIntent (bookingId) {\n            if (USE_MOCK_API) {\n                return {\n                    referenceId: \"mock-ref-id\",\n                    to: \"0x1234567890123456789012345678901234567890\",\n                    value: \"1000000000000000000\",\n                    data: null,\n                    chainId: 31337,\n                    totalAmountWei: \"1000000000000000000\"\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/intent`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    bookingId\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to create payment intent: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get booking details for payment\n     */ async getBookingDetails (bookingId) {\n            if (USE_MOCK_API) {\n                return {\n                    bookingId,\n                    status: \"PENDING_PAYMENT\",\n                    totalPrice: 100.0,\n                    checkInDate: \"2025-12-01\",\n                    checkOutDate: \"2025-12-05\",\n                    propertyId: 1,\n                    propertyTitle: \"Mock Property\",\n                    propertyPrice: 20.0,\n                    ownerWalletAddress: \"0x1234567890123456789012345678901234567890\",\n                    userId: 1,\n                    currentUserId: 1,\n                    userFirstName: \"John\",\n                    userLastName: \"Doe\",\n                    userEmail: \"john@example.com\",\n                    userWalletAddress: null\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/booking/${bookingId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n            if (!response.ok) {\n                let errorMessage = `Failed to fetch booking details: ${response.status}`;\n                try {\n                    const errorData = await response.json();\n                    // Backend returns { code, message } format\n                    errorMessage = errorData.message || errorData.code || errorMessage;\n                } catch (e) {\n                    // If response is not JSON, use status text\n                    errorMessage = response.statusText || errorMessage;\n                }\n                throw new Error(errorMessage);\n            }\n            return response.json();\n        },\n        /**\n     * Update wallet address\n     */ async updateWalletAddress (userId, walletAddress) {\n            if (USE_MOCK_API) {\n                return;\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/wallet-address`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    userId,\n                    walletAddress\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update wallet address: ${response.status}`);\n            }\n        },\n        /**\n     * Update transaction hash\n     */ async updateTransactionHash (bookingId, txHash) {\n            if (USE_MOCK_API) {\n                return;\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/booking/${bookingId}/tx-hash`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    txHash\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update transaction hash: ${response.status}`);\n            }\n        },\n        // Date modification removed - dates can only be changed from booking-service\n        /**\n     * Get transaction status\n     */ async getTransactionStatus (txHash) {\n            if (USE_MOCK_API) {\n                return {\n                    txHash,\n                    status: \"PENDING\",\n                    blockNumber: null,\n                    bookingId: null\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/tx/${txHash}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch transaction status: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Complete booking on blockchain (called by host when confirming checkout)\n     */ async completeBooking (bookingId) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\",\n                    message: \"Booking completed successfully on blockchain\"\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/booking/${bookingId}/complete`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                let errorData = {};\n                let errorText = \"\";\n                try {\n                    errorText = await response.text();\n                    if (errorText) {\n                        try {\n                            errorData = JSON.parse(errorText);\n                        } catch  {\n                            errorData = {\n                                message: errorText\n                            };\n                        }\n                    }\n                } catch (e) {\n                    // If response is not JSON, use status text\n                    errorData = {\n                        message: response.statusText || `Server error: ${response.status}`\n                    };\n                }\n                const errorMessage = errorData.message || errorData.error || errorText || `Failed to complete booking: ${response.status}`;\n                throw new Error(errorMessage);\n            }\n            return response.json();\n        }\n    },\n    // ==================== RECLAMATIONS ====================\n    reclamations: {\n        /**\n     * Create a reclamation for a booking\n     */ async create (bookingId, userId, complainantRole, reclamationType, title, description, images) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\",\n                    message: \"Reclamation created successfully\"\n                };\n            }\n            // Use reclamation-service directly to support images\n            const formData = new FormData();\n            formData.append(\"bookingId\", String(bookingId));\n            formData.append(\"userId\", String(userId));\n            formData.append(\"complainantRole\", complainantRole);\n            formData.append(\"reclamationType\", reclamationType);\n            if (title) formData.append(\"title\", title);\n            if (description) formData.append(\"description\", description);\n            if (images && images.length > 0) {\n                images.forEach((image)=>{\n                    formData.append(\"files\", image);\n                });\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/create`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    ...getAuthHeaders()\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to create reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get all reclamations by complainant ID (my complaints)\n     */ async getMyComplaints (userId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/my-complaints?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch complaints: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get all reclamations against a user (complaints against me)\n     */ async getComplaintsAgainstMe (userId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/against-me?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch complaints: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Upload attachments (images) for a reclamation\n     */ async uploadAttachments (reclamationId, files) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const formData = new FormData();\n            files.forEach((file)=>{\n                formData.append(\"files\", file);\n            });\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}/attachments`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    ...getAuthHeaders()\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to upload attachments: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation by booking ID and complainant ID\n     */ async getByBookingIdAndComplainant (bookingId, complainantId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/booking/${bookingId}/complainant/${complainantId}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                // 404 is expected when no reclamation exists - return null silently\n                if (response.status === 404) {\n                    return null;\n                }\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `Failed to fetch reclamation: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                // Silently handle 404 errors (no reclamation exists - this is normal)\n                if (error.message?.includes(\"404\") || error.message?.includes(\"Not Found\")) {\n                    return null;\n                }\n                throw error;\n            }\n        },\n        /**\n     * Get reclamation by ID\n     */ async getById (reclamationId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation attachments (images)\n     */ async getAttachments (reclamationId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}/attachments`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch attachments: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Delete a reclamation\n     */ async delete (reclamationId, userId) {\n            if (USE_MOCK_API) {\n                return;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"DELETE\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to delete reclamation: ${response.status}`);\n            }\n        },\n        /**\n     * Update a reclamation (title, description, images)\n     */ async update (reclamationId, userId, title, description, images) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\",\n                    message: \"Reclamation updated successfully\"\n                };\n            }\n            const formData = new FormData();\n            formData.append(\"userId\", String(userId));\n            if (title) formData.append(\"title\", title);\n            if (description) formData.append(\"description\", description);\n            if (images && images.length > 0) {\n                images.forEach((image)=>{\n                    formData.append(\"files\", image);\n                });\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    ...getAuthHeaders()\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get user phone number\n     */ async getUserPhoneNumber (userId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/user/${userId}/phone`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch phone number: ${response.status}`);\n            }\n            const data = await response.json();\n            return data.phoneNumber || null;\n        }\n    },\n    // ==================== ADMIN RECLAMATIONS ====================\n    adminReclamations: {\n        /**\n     * Get all reclamations (admin only)\n     */ async getAll () {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamations: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamations by status\n     */ async getByStatus (status) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/status/${status}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamations: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation by ID\n     */ async getById (reclamationId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Update reclamation severity\n     */ async updateSeverity (reclamationId, severity) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/severity?severity=${severity}`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update severity: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Review reclamation (move to IN_REVIEW)\n     */ async review (reclamationId) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/review`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to review reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Resolve reclamation with penalty\n     */ async resolve (reclamationId, resolutionNotes, approved) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/resolve`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    resolutionNotes,\n                    approved\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to resolve reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Reject reclamation\n     */ async reject (reclamationId, rejectionNotes) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/reject`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    rejectionNotes\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to reject reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation attachments (images)\n     */ async getAttachments (reclamationId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/attachments`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch attachments: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation statistics\n     */ async getStatistics () {\n            if (USE_MOCK_API) {\n                return {\n                    total: 0,\n                    open: 0,\n                    inReview: 0,\n                    resolved: 0,\n                    rejected: 0\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/statistics`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch statistics: ${response.status}`);\n            }\n            return response.json();\n        }\n    },\n    // ==================== RECOMMENDATIONS ====================\n    recommendations: {\n        async getForTenant (tenantId, maxResults = 3) {\n            if (USE_MOCK_API) return [];\n            const response = await fetch(`/api/recommendations/tenant/${tenantId}?max_results=${maxResults}`);\n            if (!response.ok) throw new Error(\"Failed to fetch recommendations\");\n            return response.json();\n        },\n        async getSimilar (propertyId, maxResults = 3) {\n            if (USE_MOCK_API) return [];\n            const response = await fetch(`/api/recommendations/similar/${propertyId}?max_results=${maxResults}`);\n            if (!response.ok) throw new Error(\"Failed to fetch similar properties\");\n            return response.json();\n        }\n    },\n    // ==================== MARKET TRENDS ====================\n    marketTrends: {\n        async getAllCities (periodMonths = 12) {\n            if (USE_MOCK_API) return {\n                trends: [],\n                insights: []\n            };\n            const response = await fetch(`/api/market-trends/all-cities?period_months=${periodMonths}`);\n            if (!response.ok) throw new Error(\"Failed to fetch market trends\");\n            return response.json();\n        },\n        async getCityTrends (city, periodMonths = 12) {\n            if (USE_MOCK_API) return {\n                data_points: []\n            };\n            const response = await fetch(`/api/market-trends/city/${city}?period_months=${periodMonths}`);\n            if (!response.ok) throw new Error(`Failed to fetch trends for ${city}`);\n            return response.json();\n        },\n        async getInsights (city) {\n            if (USE_MOCK_API) return [];\n            const response = await fetch(`/api/market-trends/insights/${city}`);\n            if (!response.ok) throw new Error(`Failed to fetch insights for ${city}`);\n            return response.json();\n        }\n    }\n};\nconst apiBaseUrl = API_BASE_URL;\nconst apiVersion = API_VERSION;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zZXJ2aWNlcy9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBYUQsMkNBQTJDO0FBQzNDLHlFQUF5RTtBQUN6RSw2RkFBNkY7QUFDN0YsTUFBTUEsY0FBY0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyx1QkFBdUIsSUFBSTtBQUMzRCxNQUFNQyxjQUFjSCxPQUFPQSxDQUFDQyxHQUFHLENBQUNHLHVCQUF1QixLQUFLLFFBQVEsa0JBQWtCOztBQUV0Rix1RUFBdUU7QUFDdkUsTUFBTUMsZUFBZUwsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDSyx3QkFBd0IsSUFBSTtBQUM3RCxNQUFNQyx3QkFBd0JQLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ08saUNBQWlDLElBQUk7QUFDL0UsTUFBTUMsdUJBQXVCTixjQUN6QkosY0FDQ0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDUyxnQ0FBZ0MsSUFBSTtBQUNyRCxNQUFNQyx1QkFBdUJYLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ1csZ0NBQWdDLElBQUk7QUFDN0UsTUFBTUMsMkJBQTJCYixPQUFPQSxDQUFDQyxHQUFHLENBQUNhLG9DQUFvQyxJQUFJO0FBQ3JGLE1BQU1DLGNBQWNmLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ2UsdUJBQXVCLElBQUk7QUFDM0QsTUFBTUMsaUJBQWlCakIsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDaUIsNEJBQTRCLElBQUk7QUFDbkUsTUFBTUMsZ0JBQWdCbkIsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDbUIsNEJBQTRCLElBQUk7QUFDbEUsbUZBQW1GO0FBQ25GLE1BQU1DLGVBQWVyQixPQUFPQSxDQUFDQyxHQUFHLENBQUNxQix3QkFBd0IsS0FBSztBQUU5RCw0REFBNEQ7QUFDNUQsSUFBSUMsZ0JBQWdFO0FBRXBFLGVBQWVDO0lBQ2IsSUFBSSxDQUFDRCxlQUFlO1FBQ2xCLE1BQU0sRUFBRUUsT0FBTyxFQUFFLEdBQUcsTUFBTSw4TEFBd0I7UUFDbERGLGdCQUFnQkU7SUFDbEI7SUFDQSxPQUFPRjtBQUNUO0FBRUE7O0NBRUMsR0FDRCxTQUFTRyxVQUFVQyxLQUFhO0lBQzlCLElBQUk7UUFDRix1Q0FBdUM7UUFDdkMsTUFBTUMsUUFBUUQsTUFBTUUsS0FBSyxDQUFDO1FBQzFCLElBQUlELE1BQU1FLE1BQU0sS0FBSyxHQUFHLE9BQU87UUFFL0IsNkJBQTZCO1FBQzdCLE1BQU1DLFVBQVVILEtBQUssQ0FBQyxFQUFFO1FBQ3hCLE1BQU1JLFVBQVVDLEtBQUtDLEtBQUssQ0FBQ0MsS0FBS0osUUFBUUssT0FBTyxDQUFDLE1BQU0sS0FBS0EsT0FBTyxDQUFDLE1BQU07UUFFekUsT0FBTztZQUNMQyxRQUFRTCxRQUFRTSxHQUFHLElBQUlOLFFBQVFPLE9BQU87WUFDdENDLE9BQU9SLFFBQVFRLEtBQUssSUFBSSxFQUFFO1FBQzVCO0lBQ0YsRUFBRSxPQUFPQyxPQUFPO1FBQ2QsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTQztJQUNQLHNCQUFzQjtJQUN0QixJQUFJLEtBQTZCLEVBQUUsRUFFbEM7SUFFRCxNQUFNZixRQUFRZ0IsYUFBYUMsT0FBTyxDQUFDM0I7SUFDbkMsSUFBSSxDQUFDVSxPQUFPO1FBQ1YsT0FBTyxDQUFDO0lBQ1Y7SUFFQSx5Q0FBeUM7SUFDekMsTUFBTUssVUFBVU4sVUFBVUM7SUFDMUIsTUFBTVUsU0FBU0wsU0FBU0s7SUFFeEIsMENBQTBDO0lBQzFDLE1BQU1RLFdBQVdGLGFBQWFDLE9BQU8sQ0FBQ3pCO0lBQ3RDLElBQUkyQixjQUFjVDtJQUNsQixJQUFJRyxRQUFrQlIsU0FBU1EsU0FBUyxFQUFFO0lBRTFDLElBQUlLLFVBQVU7UUFDWixJQUFJO1lBQ0YsTUFBTUUsT0FBT2QsS0FBS0MsS0FBSyxDQUFDVztZQUN4QkMsY0FBY0EsZUFBZUMsS0FBS0MsRUFBRSxJQUFJO1lBQ3hDUixRQUFRQSxNQUFNVixNQUFNLEdBQUcsSUFBSVUsUUFBU08sS0FBS1AsS0FBSyxJQUFJLEVBQUU7UUFDdEQsRUFBRSxPQUFPQyxPQUFPO1FBQ2QsNEJBQTRCO1FBQzlCO0lBQ0Y7SUFFQSx3RUFBd0U7SUFDeEUsTUFBTVEsZUFBZUgsY0FBY0ksT0FBT0osZUFBZTtJQUV6RCxNQUFNSyxVQUFVO1FBQ2QsYUFBYUY7UUFDYixnQkFBZ0JULE1BQU1ZLElBQUksQ0FBQztRQUMzQixHQUFJekIsU0FBUztZQUFFMEIsZUFBZSxDQUFDLE9BQU8sRUFBRTFCLE9BQU87UUFBQyxDQUFDO0lBQ25EO0lBRUEsT0FBT3dCO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxTQUFTRyxjQUFjQyxPQUEwRztJQUMvSCxJQUFJcEQsYUFBYTtRQUNmLHNDQUFzQztRQUN0QyxPQUFPSjtJQUNUO0lBRUEsc0NBQXNDO0lBQ3RDLE9BQVF3RDtRQUNOLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT2xEO1FBQ1QsS0FBSztZQUNILE9BQU9FO1FBQ1QsS0FBSztZQUNILE9BQU9FO1FBQ1QsS0FBSztZQUNILE9BQU9FO1FBQ1QsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPRTtRQUNUO1lBQ0UsT0FBT1I7SUFDWDtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU21ELFNBQVNDLElBQVksRUFBRUYsVUFBNkcsT0FBTztJQUNsSixNQUFNRyxVQUFVSixjQUFjQztJQUU5QixJQUFJcEQsYUFBYTtRQUNmLHdDQUF3QztRQUN4Qyw2REFBNkQ7UUFDN0QsK0VBQStFO1FBQy9FLElBQUlzRCxLQUFLRSxVQUFVLENBQUMsVUFBVTtZQUM1QixPQUFPLEdBQUdELFVBQVVELE1BQU07UUFDNUI7UUFFQSwwQ0FBMEM7UUFDMUMsSUFBSUYsWUFBWSxVQUFVQSxZQUFZLFNBQVM7WUFDN0MsT0FBTyxHQUFHRyxRQUFRLE9BQU8sRUFBRUQsTUFBTTtRQUNuQyxPQUFPLElBQUlGLFlBQVksY0FBYztZQUNuQyxPQUFPLEdBQUdHLFFBQVEsT0FBTyxFQUFFRCxNQUFNO1FBQ25DLE9BQU8sSUFBSUYsWUFBWSxZQUFZO1lBQ2pDLE9BQU8sR0FBR0csUUFBUSxJQUFJLEVBQUVELE1BQU07UUFDaEMsT0FBTyxJQUFJRixZQUFZLFlBQVk7WUFDakMsT0FBTyxHQUFHRyxRQUFRLElBQUksRUFBRUQsTUFBTTtRQUNoQyxPQUFPLElBQUlGLFlBQVksa0JBQWtCQSxZQUFZLHNCQUFzQjtZQUN6RSxPQUFPLEdBQUdHLFFBQVEsSUFBSSxFQUFFRCxNQUFNO1FBQ2hDO1FBRUEsT0FBTyxHQUFHQyxVQUFVRCxNQUFNO0lBQzVCO0lBRUEsK0NBQStDO0lBQy9DLE1BQU1HLFdBQVcsQ0FBQyxLQUFLLEVBQUU3QyxhQUFhO0lBQ3RDLE9BQU8sR0FBRzJDLFVBQVVFLFdBQVdILE1BQU07QUFDdkM7QUFFQTs7Q0FFQyxHQUNELGVBQWVJLFFBQ2JKLElBQVksRUFDWkssVUFBaUssQ0FBQyxDQUFDO0lBRW5LLE1BQU0sRUFBRUMsZUFBZSxJQUFJLEVBQUVSLFVBQVUsT0FBTyxFQUFFLEdBQUdTLGNBQWMsR0FBR0Y7SUFFcEUsTUFBTVgsVUFBdUI7UUFDM0IsZ0JBQWdCO1FBQ2hCLEdBQUlZLGdCQUFnQnJCLGdCQUFnQjtRQUNwQyxHQUFHc0IsYUFBYWIsT0FBTztJQUN6QjtJQUVBLE1BQU1jLE1BQU1ULFNBQVNDLE1BQU1GO0lBRTNCLElBQUk7UUFDRixNQUFNVyxXQUFXLE1BQU1DLE1BQU1GLEtBQUs7WUFDaEMsR0FBR0QsWUFBWTtZQUNmYjtRQUNGO1FBRUEsSUFBSSxDQUFDZSxTQUFTRSxFQUFFLEVBQUU7WUFDaEIsSUFBSUMsWUFBaUIsQ0FBQztZQUN0QixJQUFJQyxlQUFlO1lBRW5CLElBQUk7Z0JBQ0ZBLGVBQWUsTUFBTUosU0FBU0ssSUFBSTtnQkFDbEMsSUFBSUQsY0FBYztvQkFDaEIsSUFBSTt3QkFDRkQsWUFBWXBDLEtBQUtDLEtBQUssQ0FBQ29DO29CQUN6QixFQUFFLE9BQU9FLFlBQVk7d0JBQ25CLDBDQUEwQzt3QkFDMUNILFlBQVk7NEJBQUVJLFNBQVNIOzRCQUFjSSxLQUFLSjt3QkFBYTtvQkFDekQ7Z0JBQ0Y7WUFDRixFQUFFLE9BQU9LLFdBQVc7Z0JBQ2xCTixZQUFZO29CQUFFSSxTQUFTLENBQUMseUJBQXlCLEVBQUVFLFdBQVc7Z0JBQUM7WUFDakU7WUFFQSxzREFBc0Q7WUFDdEQsSUFBSUMsT0FBT0MsSUFBSSxDQUFDUixXQUFXdkMsTUFBTSxLQUFLLEdBQUc7Z0JBQ3ZDdUMsWUFBWTtvQkFDVkksU0FBUyxDQUFDLEtBQUssRUFBRVAsU0FBU1ksTUFBTSxDQUFDLEVBQUUsRUFBRVosU0FBU2EsVUFBVSxFQUFFO29CQUMxREQsUUFBUVosU0FBU1ksTUFBTTtvQkFDdkJDLFlBQVliLFNBQVNhLFVBQVU7Z0JBQ2pDO1lBQ0Y7WUFFQSx5RUFBeUU7WUFDekUsNkRBQTZEO1lBQzdELE1BQU1DLGVBQ0pYLFVBQVVJLE9BQU8sSUFBYyx3QkFBd0I7WUFDdkRKLFVBQVU1QixLQUFLLElBQWdCLG9DQUFvQztZQUNuRTRCLFVBQVVZLE1BQU0sSUFBZSwrQkFBK0I7WUFDOURaLFVBQVVLLEdBQUcsSUFBa0IsMkNBQTJDO1lBQ3pFUSxDQUFBQSxNQUFNQyxPQUFPLENBQUNkLFVBQVVlLE1BQU0sSUFBSWYsVUFBVWUsTUFBTSxDQUFDaEMsSUFBSSxDQUFDLFFBQVEsSUFBRyxLQUFNLDBCQUEwQjtZQUNuRyxRQUFPaUIsY0FBYyxXQUFXQSxZQUFZLElBQUcsS0FDaEQsQ0FBQyxXQUFXLEVBQUVILFNBQVNZLE1BQU0sQ0FBQyxDQUFDLEVBQUVaLFNBQVNhLFVBQVUsRUFBRTtZQUV4RCxNQUFNTSxXQUFXLElBQUlDLE1BQU1OO1lBQ3RCSyxTQUFpQlAsTUFBTSxHQUFHWixTQUFTWSxNQUFNO1lBQ3pDTyxTQUFpQmhCLFNBQVMsR0FBR0E7WUFDN0JnQixTQUFpQmYsWUFBWSxHQUFHQTtZQUNyQyxNQUFNZTtRQUNSO1FBRUEsZ0NBQWdDO1FBQ2hDLE1BQU1FLGNBQWNyQixTQUFTZixPQUFPLENBQUNxQyxHQUFHLENBQUM7UUFDekMsSUFBSUQsZUFBZUEsWUFBWUUsUUFBUSxDQUFDLHFCQUFxQjtZQUMzRCxNQUFNQyxPQUFPLE1BQU14QixTQUFTeUIsSUFBSTtZQUNoQyxPQUFPRDtRQUNULE9BQU87WUFDTCxtRUFBbUU7WUFDbkUsTUFBTW5CLE9BQU8sTUFBTUwsU0FBU0ssSUFBSTtZQUNoQyxJQUFJQSxNQUFNO2dCQUNSLHdEQUF3RDtnQkFDeEQsSUFBSTtvQkFDRixPQUFPdEMsS0FBS0MsS0FBSyxDQUFDcUM7Z0JBQ3BCLEVBQUUsT0FBTTtvQkFDTixPQUFPO3dCQUFFRSxTQUFTRjtvQkFBSztnQkFDekI7WUFDRjtZQUNBLE9BQU8sQ0FBQztRQUNWO0lBQ0YsRUFBRSxPQUFPOUIsT0FBWTtRQUNuQixtQ0FBbUM7UUFDbkMsSUFBSUEsT0FBT2dDLFNBQVNnQixTQUFTLHNCQUFzQmhELE9BQU9nQyxTQUFTZ0IsU0FBUywyQkFBMkI7WUFDckcsTUFBTUcsa0JBQWtCLElBQUlOLE1BQzFCLENBQUMsb0NBQW9DLEVBQUVqRixhQUFhLDBDQUEwQyxDQUFDO1lBRTVGdUYsZ0JBQXdCQyxpQkFBaUIsR0FBRztZQUNqRCxNQUFNRDtRQUNSO1FBRUEsTUFBTW5EO0lBQ1I7QUFDRjtBQUVBOztDQUVDLEdBQ0QsZUFBZXFELGdCQUNickMsSUFBWSxFQUNac0MsUUFBa0IsRUFDbEJqQyxVQUErSyxDQUFDLENBQUM7SUFFakwsTUFBTSxFQUFFQyxlQUFlLElBQUksRUFBRVIsVUFBVSxPQUFPLEVBQUUsR0FBR1MsY0FBYyxHQUFHRjtJQUVwRSxNQUFNWCxVQUF1QjtRQUMzQixHQUFJWSxnQkFBZ0JyQixnQkFBZ0I7UUFDcEMsR0FBR3NCLGFBQWFiLE9BQU87SUFDekI7SUFFQSwwRUFBMEU7SUFDMUUsT0FBTyxPQUFnQixDQUFDLGVBQWU7SUFFdkMsTUFBTWMsTUFBTVQsU0FBU0MsTUFBTUY7SUFFM0IsSUFBSTtRQUNGLE1BQU1XLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztZQUNoQytCLFFBQVE7WUFDUixHQUFHaEMsWUFBWTtZQUNmYjtZQUNBOEMsTUFBTUY7UUFDUjtRQUVBLElBQUksQ0FBQzdCLFNBQVNFLEVBQUUsRUFBRTtZQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7WUFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFUCxTQUFTWSxNQUFNLEVBQUU7UUFDdEU7UUFFQSxNQUFNWSxPQUFPLE1BQU14QixTQUFTeUIsSUFBSTtRQUNoQyxPQUFPRDtJQUNULEVBQUUsT0FBT2pELE9BQU87UUFDZCxNQUFNQTtJQUNSO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLE1BQU0wRCxZQUFZO0lBQ3ZCLHVEQUF1RDtJQUN2REMsWUFBWTtRQUNWLE1BQU1DO1lBQ0osSUFBSWhGLGNBQWM7Z0JBQ2hCLE1BQU1pRixPQUFPLE1BQU05RTtnQkFDbkIsT0FBTzhFLEtBQUtGLFVBQVUsQ0FBQ0MsTUFBTTtZQUMvQjtZQUNBLGtEQUFrRDtZQUNsRCxNQUFNcEMsTUFBTSxHQUFHMUQsc0JBQXNCLEtBQUssRUFBRVEsWUFBWSxXQUFXLENBQUM7WUFFcEUsSUFBSTtnQkFDRixNQUFNbUQsV0FBVyxNQUFNQyxNQUFNRixLQUFLO29CQUNoQytCLFFBQVE7b0JBQ1I3QyxTQUFTO3dCQUNQLGdCQUFnQjt3QkFDaEIsR0FBR1QsZ0JBQWdCO29CQUNyQjtnQkFDRjtnQkFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7b0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztvQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFUCxTQUFTWSxNQUFNLEVBQUU7Z0JBQ3RFO2dCQUVBLE9BQU9aLFNBQVN5QixJQUFJO1lBQ3RCLEVBQUUsT0FBT2xELE9BQVk7Z0JBQ25CLElBQUlBLE9BQU9nQyxTQUFTZ0IsU0FBUyxzQkFBc0JoRCxPQUFPZ0MsU0FBU2dCLFNBQVMsMkJBQTJCO29CQUNyRyxNQUFNRyxrQkFBa0IsSUFBSU4sTUFDMUIsQ0FBQyw4Q0FBOEMsRUFBRS9FLHNCQUFzQiwwQ0FBMEMsQ0FBQztvQkFFL0dxRixnQkFBd0JDLGlCQUFpQixHQUFHO29CQUNqRCxNQUFNRDtnQkFDUjtnQkFDQSxNQUFNbkQ7WUFDUjtRQUNGO1FBRUEsTUFBTThEO1lBQ0osSUFBSWxGLGNBQWM7Z0JBQ2hCLE1BQU1pRixPQUFPLE1BQU05RTtnQkFDbkIsT0FBTzhFLEtBQUtGLFVBQVUsQ0FBQ0MsTUFBTTtZQUMvQjtZQUNBLHlEQUF5RDtZQUN6RCxNQUFNcEMsTUFBTVQsU0FBUyx5QkFBeUI7WUFDOUMsTUFBTWdELGNBQWM5RDtZQUVwQixJQUFJO2dCQUNGLE1BQU13QixXQUFXLE1BQU1DLE1BQU1GLEtBQUs7b0JBQ2hDK0IsUUFBUTtvQkFDUjdDLFNBQVM7d0JBQ1AsZ0JBQWdCO3dCQUNoQixHQUFHcUQsV0FBVztvQkFDaEI7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDdEMsU0FBU0UsRUFBRSxFQUFFO29CQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7b0JBQ3RELE1BQU1sQixlQUFlWCxVQUFVNUIsS0FBSyxJQUFJNEIsVUFBVUksT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFUCxTQUFTWSxNQUFNLEVBQUU7b0JBQzVGLE1BQU0sSUFBSVEsTUFBTU47Z0JBQ2xCO2dCQUVBLE1BQU1VLE9BQU8sTUFBTXhCLFNBQVN5QixJQUFJO2dCQUVoQywwQkFBMEI7Z0JBQzFCLElBQUksQ0FBQ1QsTUFBTUMsT0FBTyxDQUFDTyxPQUFPO29CQUN4QixvQ0FBb0M7b0JBQ3BDLElBQUlBLEtBQUtqRCxLQUFLLElBQUlpRCxLQUFLakIsT0FBTyxFQUFFO3dCQUM5QixNQUFNLElBQUlhLE1BQU1JLEtBQUtqRCxLQUFLLElBQUlpRCxLQUFLakIsT0FBTyxJQUFJO29CQUNoRDtvQkFDQSwrQkFBK0I7b0JBQy9CLE9BQU8sRUFBRTtnQkFDWDtnQkFFQSxPQUFPaUI7WUFDVCxFQUFFLE9BQU9qRCxPQUFZO2dCQUNuQixJQUFJQSxPQUFPZ0MsU0FBU2dCLFNBQVMsc0JBQXNCaEQsT0FBT2dDLFNBQVNnQixTQUFTLDJCQUEyQjtvQkFDckcsTUFBTUcsa0JBQWtCLElBQUlOLE1BQzFCLENBQUMsOENBQThDLEVBQUUvRSxzQkFBc0IsMENBQTBDLENBQUM7b0JBRS9HcUYsZ0JBQXdCQyxpQkFBaUIsR0FBRztvQkFDakQsTUFBTUQ7Z0JBQ1I7Z0JBQ0EsTUFBTW5EO1lBQ1I7UUFDRjtRQUVBLE1BQU1nRSxTQUFRekQsRUFBVTtZQUN0QixJQUFJM0IsY0FBYztnQkFDaEIsTUFBTWlGLE9BQU8sTUFBTTlFO2dCQUNuQixPQUFPOEUsS0FBS0YsVUFBVSxDQUFDSyxPQUFPLENBQUN6RDtZQUNqQztZQUNBLGtEQUFrRDtZQUNsRCxNQUFNaUIsTUFBTSxHQUFHMUQsc0JBQXNCLEtBQUssRUFBRVEsWUFBWSxZQUFZLEVBQUVpQyxJQUFJO1lBRTFFLElBQUk7Z0JBQ0YsTUFBTWtCLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztvQkFDaEMrQixRQUFRO29CQUNSN0MsU0FBUzt3QkFDUCxnQkFBZ0I7b0JBQ2xCO2dCQUNGO2dCQUVBLElBQUksQ0FBQ2UsU0FBU0UsRUFBRSxFQUFFO29CQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7b0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSSxDQUFDLFdBQVcsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO2dCQUN0RTtnQkFFQSxPQUFPWixTQUFTeUIsSUFBSTtZQUN0QixFQUFFLE9BQU9sRCxPQUFZO2dCQUNuQixJQUFJQSxPQUFPZ0MsU0FBU2dCLFNBQVMsc0JBQXNCaEQsT0FBT2dDLFNBQVNnQixTQUFTLDZCQUE2QmhELE9BQU9nQyxTQUFTZ0IsU0FBUyxTQUFTO29CQUN6SSxNQUFNRyxrQkFBa0IsSUFBSU4sTUFDMUIsQ0FBQyw4Q0FBOEMsRUFBRS9FLHNCQUFzQiwwQ0FBMEMsQ0FBQztvQkFFL0dxRixnQkFBd0JDLGlCQUFpQixHQUFHO29CQUNqRCxNQUFNRDtnQkFDUjtnQkFDQSxNQUFNbkQ7WUFDUjtRQUNGO1FBRUEsTUFBTWlFO1lBQ0osSUFBSXJGLGNBQWM7Z0JBQ2hCLE1BQU1pRixPQUFPLE1BQU05RTtnQkFDbkIsT0FBTzhFLEtBQUtGLFVBQVUsQ0FBQ0MsTUFBTTtZQUMvQjtZQUVBLE1BQU1wQyxNQUFNLEdBQUcxRCxzQkFBc0IsS0FBSyxFQUFFUSxZQUFZLHlCQUF5QixDQUFDO1lBQ2xGLElBQUk7Z0JBQ0YsTUFBTW1ELFdBQVcsTUFBTUMsTUFBTUYsS0FBSztvQkFDaEMrQixRQUFRO29CQUNSN0MsU0FBUzt3QkFDUCxnQkFBZ0I7d0JBQ2hCLEdBQUdULGdCQUFnQjtvQkFDckI7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDd0IsU0FBU0UsRUFBRSxFQUFFO29CQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7b0JBQ3RELE1BQU1sQixlQUFlWCxVQUFVNUIsS0FBSyxJQUFJNEIsVUFBVUksT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFUCxTQUFTWSxNQUFNLEVBQUU7b0JBQzVGLE1BQU0sSUFBSVEsTUFBTU47Z0JBQ2xCO2dCQUVBLE1BQU1VLE9BQU8sTUFBTXhCLFNBQVN5QixJQUFJO2dCQUVoQywwQkFBMEI7Z0JBQzFCLElBQUksQ0FBQ1QsTUFBTUMsT0FBTyxDQUFDTyxPQUFPO29CQUN4QixvQ0FBb0M7b0JBQ3BDLElBQUlBLEtBQUtqRCxLQUFLLElBQUlpRCxLQUFLakIsT0FBTyxFQUFFO3dCQUM5QixNQUFNLElBQUlhLE1BQU1JLEtBQUtqRCxLQUFLLElBQUlpRCxLQUFLakIsT0FBTyxJQUFJO29CQUNoRDtvQkFDQSwrQkFBK0I7b0JBQy9CLE9BQU8sRUFBRTtnQkFDWDtnQkFFQSxPQUFPaUI7WUFDVCxFQUFFLE9BQU9qRCxPQUFZO2dCQUNuQixJQUFJQSxPQUFPZ0MsU0FBU2dCLFNBQVMsc0JBQXNCaEQsT0FBT2dDLFNBQVNnQixTQUFTLDZCQUE2QmhELE9BQU9nQyxTQUFTZ0IsU0FBUyxTQUFTO29CQUN6SSxNQUFNRyxrQkFBa0IsSUFBSU4sTUFDMUIsQ0FBQyw4Q0FBOEMsRUFBRS9FLHNCQUFzQiwwQ0FBMEMsQ0FBQztvQkFFL0dxRixnQkFBd0JDLGlCQUFpQixHQUFHO29CQUNqRCxNQUFNRDtnQkFDUjtnQkFDQSxNQUFNbkQ7WUFDUjtRQUNGO1FBRUEsTUFBTWtFLFFBQU9qQixJQUEyQixFQUFFa0IsTUFBYztZQUN0RCxJQUFJdkYsY0FBYztnQkFDaEIsTUFBTWlGLE9BQU8sTUFBTTlFO2dCQUNuQixNQUFNcUYsU0FBUyxNQUFNUCxLQUFLRixVQUFVLENBQUNPLE1BQU0sQ0FBQ2pCLE1BQU1rQjtnQkFDbEQsT0FBTztvQkFBRUUsWUFBWUQsT0FBTzdELEVBQUU7b0JBQUVBLElBQUk2RCxPQUFPN0QsRUFBRTtnQkFBQztZQUNoRDtZQUNBLE1BQU0rQyxXQUFXLElBQUlnQjtZQUNyQiwwREFBMEQ7WUFDMUQsOEVBQThFO1lBQzlFLE1BQU1DLFlBQVksSUFBSUMsS0FBSztnQkFBQ2hGLEtBQUtpRixTQUFTLENBQUN4QjthQUFNLEVBQUU7Z0JBQUV5QixNQUFNO1lBQW1CO1lBQzlFcEIsU0FBU3FCLE1BQU0sQ0FBQyxTQUFTSjtZQUV6QkosT0FBT1MsT0FBTyxDQUFDLENBQUNDO2dCQUNkdkIsU0FBU3FCLE1BQU0sQ0FBQyxVQUFVRTtZQUM1QjtZQUVBLGtEQUFrRDtZQUNsRCxNQUFNckQsTUFBTSxHQUFHMUQsc0JBQXNCLEtBQUssRUFBRVEsWUFBWSxXQUFXLENBQUM7WUFDcEUsTUFBTW9DLFVBQXVCO2dCQUMzQixHQUFHVCxnQkFBZ0I7WUFDckI7WUFDQSwyRkFBMkY7WUFFM0YsSUFBSTtnQkFDRixNQUFNd0IsV0FBVyxNQUFNQyxNQUFNRixLQUFLO29CQUNoQytCLFFBQVE7b0JBQ1I3QztvQkFDQThDLE1BQU1GO2dCQUNSO2dCQUVBLElBQUksQ0FBQzdCLFNBQVNFLEVBQUUsRUFBRTtvQkFDaEIsTUFBTUMsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTyxFQUFDO29CQUN0RCxNQUFNLElBQUlaLE1BQU1qQixVQUFVSSxPQUFPLElBQUksQ0FBQyxXQUFXLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtnQkFDdEU7Z0JBRUEsTUFBTStCLFNBQVMsTUFBTTNDLFNBQVN5QixJQUFJO2dCQUNsQyxPQUFPa0I7WUFDVCxFQUFFLE9BQU9wRSxPQUFPO2dCQUNkLE1BQU1BO1lBQ1I7UUFDRjtRQUVBLE1BQU04RSxRQUFPdkUsRUFBVSxFQUFFMEMsSUFBMkI7WUFDbEQsSUFBSXJFLGNBQWM7Z0JBQ2hCLE1BQU1pRixPQUFPLE1BQU05RTtnQkFDbkIsT0FBTzhFLEtBQUtGLFVBQVUsQ0FBQ21CLE1BQU0sQ0FBQ3ZFLElBQUkwQztZQUNwQztZQUNBLGtEQUFrRDtZQUNsRCxNQUFNekIsTUFBTSxHQUFHMUQsc0JBQXNCLEtBQUssRUFBRVEsWUFBWSxZQUFZLEVBQUVpQyxJQUFJO1lBRTFFLElBQUk7Z0JBQ0YsTUFBTWtCLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztvQkFDaEMrQixRQUFRO29CQUNSN0MsU0FBUzt3QkFDUCxnQkFBZ0I7d0JBQ2hCLEdBQUdULGdCQUFnQjtvQkFDckI7b0JBQ0F1RCxNQUFNaEUsS0FBS2lGLFNBQVMsQ0FBQ3hCO2dCQUN2QjtnQkFFQSxJQUFJLENBQUN4QixTQUFTRSxFQUFFLEVBQUU7b0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztvQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFUCxTQUFTWSxNQUFNLEVBQUU7Z0JBQ3RFO2dCQUVBLDZEQUE2RDtnQkFDN0QsTUFBTVIsZUFBZSxNQUFNSixTQUFTSyxJQUFJO2dCQUN4QyxJQUFJO29CQUNGLE1BQU1pRCxTQUFTdkYsS0FBS0MsS0FBSyxDQUFDb0M7b0JBQzFCLE9BQU9rRDtnQkFDVCxFQUFFLE9BQU07b0JBQ04sMENBQTBDO29CQUMxQyxPQUFPO3dCQUFFQyxTQUFTO29CQUFLO2dCQUN6QjtZQUNGLEVBQUUsT0FBT2hGLE9BQVk7Z0JBQ25CLElBQUlBLE9BQU9nQyxTQUFTZ0IsU0FBUyxzQkFBc0JoRCxPQUFPZ0MsU0FBU2dCLFNBQVMsNkJBQTZCaEQsT0FBT2dDLFNBQVNnQixTQUFTLFNBQVM7b0JBQ3pJLE1BQU1HLGtCQUFrQixJQUFJTixNQUMxQixDQUFDLDhDQUE4QyxFQUFFL0Usc0JBQXNCLDBDQUEwQyxDQUFDO29CQUUvR3FGLGdCQUF3QkMsaUJBQWlCLEdBQUc7b0JBQ2pELE1BQU1EO2dCQUNSO2dCQUNBLE1BQU1uRDtZQUNSO1FBQ0Y7UUFFQSxNQUFNaUYsUUFBTzFFLEVBQVU7WUFDckIsSUFBSTNCLGNBQWM7Z0JBQ2hCLE1BQU1pRixPQUFPLE1BQU05RTtnQkFDbkIsT0FBTzhFLEtBQUtGLFVBQVUsQ0FBQ3NCLE1BQU0sQ0FBQzFFO1lBQ2hDO1lBQ0Esa0RBQWtEO1lBQ2xELE1BQU1pQixNQUFNLEdBQUcxRCxzQkFBc0IsS0FBSyxFQUFFUSxZQUFZLFlBQVksRUFBRWlDLElBQUk7WUFFMUUsSUFBSTtnQkFDRixNQUFNa0IsV0FBVyxNQUFNQyxNQUFNRixLQUFLO29CQUNoQytCLFFBQVE7b0JBQ1I3QyxTQUFTO3dCQUNQLGdCQUFnQjt3QkFDaEIsR0FBR1QsZ0JBQWdCO29CQUNyQjtnQkFDRjtnQkFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7b0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztvQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFUCxTQUFTWSxNQUFNLEVBQUU7Z0JBQ3RFO2dCQUVBLE9BQU87b0JBQUUyQyxTQUFTO2dCQUFLO1lBQ3pCLEVBQUUsT0FBT2hGLE9BQVk7Z0JBQ25CLElBQUlBLE9BQU9nQyxTQUFTZ0IsU0FBUyxzQkFBc0JoRCxPQUFPZ0MsU0FBU2dCLFNBQVMsNkJBQTZCaEQsT0FBT2dDLFNBQVNnQixTQUFTLFNBQVM7b0JBQ3pJLE1BQU1HLGtCQUFrQixJQUFJTixNQUMxQixDQUFDLDhDQUE4QyxFQUFFL0Usc0JBQXNCLDBDQUEwQyxDQUFDO29CQUUvR3FGLGdCQUF3QkMsaUJBQWlCLEdBQUc7b0JBQ2pELE1BQU1EO2dCQUNSO2dCQUNBLE1BQU1uRDtZQUNSO1FBQ0Y7UUFFQSxNQUFNa0YsU0FBUTNFLEVBQVUsRUFBRTRFLFVBQW1CO1lBQzNDLElBQUl2RyxjQUFjO2dCQUNoQixNQUFNaUYsT0FBTyxNQUFNOUU7Z0JBQ25CLE9BQU84RSxLQUFLRixVQUFVLENBQUN1QixPQUFPLENBQUMzRSxJQUFJNEU7WUFDckM7WUFDQSxrREFBa0Q7WUFDbEQsTUFBTTNELE1BQU0sR0FBRzFELHNCQUFzQixLQUFLLEVBQUVRLFlBQVksWUFBWSxFQUFFaUMsR0FBRyxRQUFRLENBQUM7WUFDbEYsSUFBSTtnQkFDRixNQUFNa0IsV0FBVyxNQUFNQyxNQUFNRixLQUFLO29CQUNoQytCLFFBQVE7b0JBQ1I3QyxTQUFTO3dCQUNQLGdCQUFnQjt3QkFDaEIsR0FBR1QsZ0JBQWdCO29CQUNyQjtvQkFDQXVELE1BQU1oRSxLQUFLaUYsU0FBUyxDQUFDO3dCQUFFVTtvQkFBVztnQkFDcEM7Z0JBRUEsSUFBSSxDQUFDMUQsU0FBU0UsRUFBRSxFQUFFO29CQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7b0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSSxDQUFDLFdBQVcsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO2dCQUN0RTtnQkFFQSxPQUFPO29CQUFFMkMsU0FBUztnQkFBSztZQUN6QixFQUFFLE9BQU9oRixPQUFZO2dCQUNuQixNQUFNQTtZQUNSO1FBQ0Y7UUFFQTs7S0FFQyxHQUNELE1BQU1vRixNQUFLN0UsRUFBVSxFQUFFOEUsUUFBaUI7WUFDdEMsSUFBSXpHLGNBQWM7Z0JBQ2hCLE1BQU1pRixPQUFPLE1BQU05RTtnQkFDbkIsT0FBTztvQkFBRWlHLFNBQVM7Z0JBQUs7WUFDekI7WUFDQSxrREFBa0Q7WUFDbEQsTUFBTXhELE1BQU0sR0FBRzFELHNCQUFzQixLQUFLLEVBQUVRLFlBQVksWUFBWSxFQUFFaUMsR0FBRyxLQUFLLENBQUM7WUFDL0UsSUFBSTtnQkFDRixNQUFNa0IsV0FBVyxNQUFNQyxNQUFNRixLQUFLO29CQUNoQytCLFFBQVE7b0JBQ1I3QyxTQUFTO3dCQUNQLGdCQUFnQjt3QkFDaEIsR0FBR1QsZ0JBQWdCO29CQUNyQjtvQkFDQXVELE1BQU1oRSxLQUFLaUYsU0FBUyxDQUFDO3dCQUFFWTtvQkFBUztnQkFDbEM7Z0JBRUEsSUFBSSxDQUFDNUQsU0FBU0UsRUFBRSxFQUFFO29CQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7b0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSSxDQUFDLFdBQVcsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO2dCQUN0RTtnQkFFQSxPQUFPO29CQUFFMkMsU0FBUztnQkFBSztZQUN6QixFQUFFLE9BQU9oRixPQUFZO2dCQUNuQixNQUFNQTtZQUNSO1FBQ0Y7UUFFQSxNQUFNc0YsU0FBUS9FLEVBQVUsRUFBRWdGLE1BQWM7WUFDdEMsSUFBSTNHLGNBQWM7Z0JBQ2hCLE1BQU1pRixPQUFPLE1BQU05RTtnQkFDbkIsT0FBTzhFLEtBQUtGLFVBQVUsQ0FBQzJCLE9BQU8sQ0FBQy9FLElBQUlnRjtZQUNyQztZQUNBLGtEQUFrRDtZQUNsRCxNQUFNL0QsTUFBTSxHQUFHMUQsc0JBQXNCLEtBQUssRUFBRVEsWUFBWSxZQUFZLEVBQUVpQyxHQUFHLFFBQVEsQ0FBQztZQUNsRixJQUFJO2dCQUNGLE1BQU1rQixXQUFXLE1BQU1DLE1BQU1GLEtBQUs7b0JBQ2hDK0IsUUFBUTtvQkFDUjdDLFNBQVM7d0JBQ1AsZ0JBQWdCO3dCQUNoQixHQUFHVCxnQkFBZ0I7b0JBQ3JCO29CQUNBdUQsTUFBTWhFLEtBQUtpRixTQUFTLENBQUM7d0JBQUVjO29CQUFPO2dCQUNoQztnQkFFQSxJQUFJLENBQUM5RCxTQUFTRSxFQUFFLEVBQUU7b0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztvQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFUCxTQUFTWSxNQUFNLEVBQUU7Z0JBQ3RFO2dCQUVBLE9BQU87b0JBQUUyQyxTQUFTO2dCQUFLO1lBQ3pCLEVBQUUsT0FBT2hGLE9BQVk7Z0JBQ25CLE1BQU1BO1lBQ1I7UUFDRjtRQUVBLE1BQU13RixrQkFBaUJqRixFQUFVO1lBQy9CLElBQUkzQixjQUFjO2dCQUNoQixNQUFNaUYsT0FBTyxNQUFNOUU7Z0JBQ25CLE9BQU84RSxLQUFLRixVQUFVLENBQUMyQixPQUFPLENBQUMvRSxJQUFJLElBQUksT0FBTzs7WUFDaEQ7WUFDQSxrREFBa0Q7WUFDbEQsTUFBTWlCLE1BQU0sR0FBRzFELHNCQUFzQixLQUFLLEVBQUVRLFlBQVksWUFBWSxFQUFFaUMsR0FBRyxrQkFBa0IsQ0FBQztZQUM1RixJQUFJO2dCQUNGLE1BQU1rQixXQUFXLE1BQU1DLE1BQU1GLEtBQUs7b0JBQ2hDK0IsUUFBUTtvQkFDUjdDLFNBQVM7d0JBQ1AsZ0JBQWdCO3dCQUNoQixHQUFHVCxnQkFBZ0I7b0JBQ3JCO2dCQUNGO2dCQUVBLElBQUksQ0FBQ3dCLFNBQVNFLEVBQUUsRUFBRTtvQkFDaEIsTUFBTUMsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTyxFQUFDO29CQUN0RCxNQUFNLElBQUlaLE1BQU1qQixVQUFVSSxPQUFPLElBQUksQ0FBQyxXQUFXLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtnQkFDdEU7Z0JBRUEsT0FBTztvQkFBRTJDLFNBQVM7Z0JBQUs7WUFDekIsRUFBRSxPQUFPaEYsT0FBWTtnQkFDbkIsTUFBTUE7WUFDUjtRQUNGO1FBRUEsTUFBTXlGLG1CQUFrQmxGLEVBQVU7WUFDaEMsSUFBSTNCLGNBQWM7Z0JBQ2hCLE1BQU1pRixPQUFPLE1BQU05RTtnQkFDbkIsT0FBTzhFLEtBQUtGLFVBQVUsQ0FBQ3VCLE9BQU8sQ0FBQzNFLElBQUk7WUFDckM7WUFDQSxNQUFNaUIsTUFBTSxHQUFHMUQsc0JBQXNCLEtBQUssRUFBRVEsWUFBWSxZQUFZLEVBQUVpQyxHQUFHLG9CQUFvQixDQUFDO1lBQzlGLElBQUk7Z0JBQ0YsTUFBTWtCLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztvQkFDaEMrQixRQUFRO29CQUNSN0MsU0FBUzt3QkFDUCxnQkFBZ0I7d0JBQ2hCLEdBQUdULGdCQUFnQjtvQkFDckI7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDd0IsU0FBU0UsRUFBRSxFQUFFO29CQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7b0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSSxDQUFDLFdBQVcsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO2dCQUN0RTtnQkFFQSxPQUFPO29CQUFFMkMsU0FBUztnQkFBSztZQUN6QixFQUFFLE9BQU9oRixPQUFZO2dCQUNuQixNQUFNQTtZQUNSO1FBQ0Y7UUFFQSxNQUFNMEYsdUJBQXNCbkYsRUFBVTtZQUNwQyxJQUFJM0IsY0FBYztnQkFDaEIsTUFBTWlGLE9BQU8sTUFBTTlFO2dCQUNuQixPQUFPO29CQUFFaUcsU0FBUztnQkFBSztZQUN6QjtZQUNBLE1BQU14RCxNQUFNLEdBQUcxRCxzQkFBc0IsS0FBSyxFQUFFUSxZQUFZLFlBQVksRUFBRWlDLEdBQUcsd0JBQXdCLENBQUM7WUFDbEcsSUFBSTtnQkFDRixNQUFNa0IsV0FBVyxNQUFNQyxNQUFNRixLQUFLO29CQUNoQytCLFFBQVE7b0JBQ1I3QyxTQUFTO3dCQUNQLGdCQUFnQjt3QkFDaEIsR0FBR1QsZ0JBQWdCO29CQUNyQjtnQkFDRjtnQkFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7b0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztvQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFUCxTQUFTWSxNQUFNLEVBQUU7Z0JBQ3RFO2dCQUVBLE9BQU87b0JBQUUyQyxTQUFTO2dCQUFLO1lBQ3pCLEVBQUUsT0FBT2hGLE9BQVk7Z0JBQ25CLE1BQU1BO1lBQ1I7UUFDRjtRQUVBOzs7S0FHQyxHQUNELE1BQU0yRixjQUNKdEIsVUFBa0IsRUFDbEJ1QixXQUFtQixFQUNuQkMsWUFBb0I7WUFjcEIsSUFBSWpILGNBQWM7Z0JBQ2hCLHNDQUFzQztnQkFDdEMsT0FBTztvQkFDTGtILG1CQUFtQjtvQkFDbkJDLG1CQUFtQjtvQkFDbkJDLHlCQUF5QjtvQkFDekJDLHlCQUF5QjtvQkFDekJDLE1BQU07b0JBQ05DLFFBQVE7b0JBQ1JDLGNBQWM7b0JBQ2RDLHFCQUFxQixJQUFJQyxPQUFPQyxXQUFXO29CQUMzQ0MsaUJBQWlCO29CQUNqQkMsd0JBQXdCO29CQUN4QkMsZ0JBQWdCO2dCQUNsQjtZQUNGO1lBRUEsTUFBTWxGLE1BQU0sR0FBRzFELHNCQUFzQixLQUFLLEVBQUVRLFlBQVksWUFBWSxFQUFFK0YsV0FBVyxjQUFjLENBQUM7WUFFaEcsTUFBTTVDLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztnQkFDaEMrQixRQUFRO2dCQUNSN0MsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLEdBQUdULGdCQUFnQjtnQkFDckI7Z0JBQ0F1RCxNQUFNaEUsS0FBS2lGLFNBQVMsQ0FBQztvQkFDbkJKO29CQUNBdUI7b0JBQ0FDO2dCQUNGO1lBQ0Y7WUFFQSxNQUFNNUMsT0FBTyxNQUFNeEIsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztZQUVqRCxJQUFJLENBQUNoQyxTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1LLFVBQ0ppQixNQUFNakIsV0FDTmlCLE1BQU1qRCxTQUNMLFFBQU9pRCxTQUFTLFdBQVdBLE9BQU8sSUFBRyxLQUN0QyxDQUFDLGdDQUFnQyxFQUFFeEIsU0FBU1ksTUFBTSxFQUFFO2dCQUN0RCxNQUFNLElBQUlRLE1BQU1iO1lBQ2xCO1lBRUEsT0FBT2lCO1FBQ1Q7SUFDRjtJQUVBLHdEQUF3RDtJQUN4RDBELE1BQU07UUFDSkMsb0JBQW9CLE9BQU9DO1lBQ3pCLElBQUk7Z0JBQ0YsMEJBQTBCO2dCQUMxQixNQUFNcEYsV0FBVyxNQUFNQyxNQUFNLENBQUMsaUJBQWlCLEVBQUVtRixVQUFVLEVBQUU7b0JBQzNEdEQsUUFBUTtvQkFDUjdDLFNBQVM7d0JBQ1AsZ0JBQWdCO29CQUNsQjtnQkFDRjtnQkFFQSxJQUFJLENBQUNlLFNBQVNFLEVBQUUsRUFBRTtvQkFDaEIsTUFBTSxJQUFJa0IsTUFBTSxDQUFDLGNBQWMsRUFBRXBCLFNBQVNZLE1BQU0sQ0FBQyxDQUFDLEVBQUVaLFNBQVNhLFVBQVUsRUFBRTtnQkFDM0U7Z0JBRUEsT0FBT2IsU0FBU3lCLElBQUk7WUFDdEIsRUFBRSxPQUFPbEQsT0FBTztnQkFDZDhHLFFBQVE5RyxLQUFLLENBQUMsOEJBQThCQTtnQkFDNUMsTUFBTUE7WUFDUjtRQUNGO0lBQ0Y7SUFFQStHLGlCQUFpQjtRQUNmQyxjQUFjLE9BQU9ILFVBQWtCSSxhQUFxQixDQUFDO1lBQzNELElBQUk7Z0JBQ0YsTUFBTXhGLFdBQVcsTUFBTUMsTUFBTSxDQUFDLDRCQUE0QixFQUFFbUYsU0FBUyxhQUFhLEVBQUVJLFlBQVk7Z0JBQ2hHLElBQUksQ0FBQ3hGLFNBQVNFLEVBQUUsRUFBRSxNQUFNLElBQUlrQixNQUFNO2dCQUNsQyxPQUFPcEIsU0FBU3lCLElBQUk7WUFDdEIsRUFBRSxPQUFPbEQsT0FBTztnQkFDZDhHLFFBQVE5RyxLQUFLLENBQUMsbUNBQW1DQTtnQkFDakQsTUFBTUE7WUFDUjtRQUNGO1FBQ0FrSCxZQUFZLE9BQU83QyxZQUFvQjRDLGFBQXFCLENBQUM7WUFDM0QsSUFBSTtnQkFDRixNQUFNeEYsV0FBVyxNQUFNQyxNQUFNLENBQUMsNkJBQTZCLEVBQUUyQyxXQUFXLGFBQWEsRUFBRTRDLFlBQVk7Z0JBQ25HLElBQUksQ0FBQ3hGLFNBQVNFLEVBQUUsRUFBRSxNQUFNLElBQUlrQixNQUFNO2dCQUNsQyxPQUFPcEIsU0FBU3lCLElBQUk7WUFDdEIsRUFBRSxPQUFPbEQsT0FBTztnQkFDZDhHLFFBQVE5RyxLQUFLLENBQUMsc0NBQXNDQTtnQkFDcEQsTUFBTUE7WUFDUjtRQUNGO0lBQ0Y7SUFFQSxrRUFBa0U7SUFDbEVtSCxzQkFBc0I7UUFDcEIsTUFBTXZEO1lBQ0osSUFBSWhGLGNBQWM7Z0JBQ2hCLE1BQU1pRixPQUFPLE1BQU05RTtnQkFDbkIsT0FBTzhFLEtBQUtzRCxvQkFBb0IsQ0FBQ3ZELE1BQU07WUFDekM7WUFDQSxPQUFPeEMsUUFBUTtRQUNqQjtRQUVBLE1BQU1nRyxhQUFZL0UsTUFBYztZQUM5QixJQUFJekQsY0FBYztnQkFDaEIsTUFBTWlGLE9BQU8sTUFBTTlFO2dCQUNuQixPQUFPOEUsS0FBS3NELG9CQUFvQixDQUFDQyxXQUFXLENBQUMvRTtZQUMvQztZQUNBLE9BQU9qQixRQUFRLENBQUMsaUNBQWlDLEVBQUVpQixRQUFRO1FBQzdEO1FBRUEsTUFBTTZCLFFBQU9HLFVBQWtCLEVBQUVnRCxXQUFtQjtZQUNsRCxJQUFJekksY0FBYztnQkFDaEIsTUFBTWlGLE9BQU8sTUFBTTlFO2dCQUNuQixPQUFPOEUsS0FBS3NELG9CQUFvQixDQUFDakQsTUFBTSxDQUFDRyxZQUFZZ0Q7WUFDdEQ7WUFDQSxPQUFPakcsUUFBUSwwQkFBMEI7Z0JBQ3ZDbUMsUUFBUTtnQkFDUkMsTUFBTWhFLEtBQUtpRixTQUFTLENBQUM7b0JBQUVKO29CQUFZZ0Q7Z0JBQVk7WUFDakQ7UUFDRjtRQUVBLE1BQU1uQyxTQUFRM0UsRUFBVTtZQUN0QixJQUFJM0IsY0FBYztnQkFDaEIsTUFBTWlGLE9BQU8sTUFBTTlFO2dCQUNuQixPQUFPOEUsS0FBS3NELG9CQUFvQixDQUFDakMsT0FBTyxDQUFDM0U7WUFDM0M7WUFDQSxPQUFPYSxRQUFRLENBQUMsdUJBQXVCLEVBQUViLEdBQUcsUUFBUSxDQUFDLEVBQUU7Z0JBQ3JEZ0QsUUFBUTtZQUNWO1FBQ0Y7UUFFQSxNQUFNK0QsUUFBTy9HLEVBQVUsRUFBRWdGLE1BQWM7WUFDckMsSUFBSTNHLGNBQWM7Z0JBQ2hCLE1BQU1pRixPQUFPLE1BQU05RTtnQkFDbkIsT0FBTzhFLEtBQUtzRCxvQkFBb0IsQ0FBQ0csTUFBTSxDQUFDL0csSUFBSWdGO1lBQzlDO1lBQ0EsT0FBT25FLFFBQVEsQ0FBQyx1QkFBdUIsRUFBRWIsR0FBRyxPQUFPLENBQUMsRUFBRTtnQkFDcERnRCxRQUFRO2dCQUNSQyxNQUFNaEUsS0FBS2lGLFNBQVMsQ0FBQztvQkFBRWM7Z0JBQU87WUFDaEM7UUFDRjtJQUNGO0lBRUEsMkRBQTJEO0lBQzNEZ0MsZUFBZTtRQUNiLE1BQU0zRDtZQUNKLElBQUloRixjQUFjO2dCQUNoQixNQUFNaUYsT0FBTyxNQUFNOUU7Z0JBQ25CLE9BQU84RSxLQUFLMEQsYUFBYSxDQUFDM0QsTUFBTTtZQUNsQztZQUNBLE9BQU94QyxRQUFRLG1CQUFtQjtnQkFBRUUsY0FBYztZQUFNO1FBQzFEO1FBRUEsTUFBTTBDLFNBQVF6RCxFQUFVO1lBQ3RCLElBQUkzQixjQUFjO2dCQUNoQixNQUFNaUYsT0FBTyxNQUFNOUU7Z0JBQ25CLE9BQU84RSxLQUFLMEQsYUFBYSxDQUFDdkQsT0FBTyxDQUFDekQ7WUFDcEM7WUFDQSxPQUFPYSxRQUFRLENBQUMsZ0JBQWdCLEVBQUViLElBQUksRUFBRTtnQkFBRWUsY0FBYztZQUFNO1FBQ2hFO0lBQ0Y7SUFFQSxrREFBa0Q7SUFDbERrRyxPQUFPO1FBQ0wsTUFBTUM7WUFVSixJQUFJN0ksY0FBYztnQkFDaEIsaUNBQWlDO2dCQUNqQyxPQUFPO29CQUNMOEksV0FBVztvQkFDWEMsVUFBVTtvQkFDVkMsT0FBTztnQkFDVDtZQUNGO1lBQ0EsT0FBT3hHLFFBQVEsYUFBYTtnQkFDMUJtQyxRQUFRO2dCQUNSakMsY0FBYztZQUNoQjtRQUNGO1FBRUE7O0tBRUMsR0FDRCxNQUFNMEMsU0FBUXBFLE1BQXVCO1lBYW5DLElBQUloQixjQUFjO2dCQUNoQixPQUFPO29CQUNMOEksV0FBVztvQkFDWEMsVUFBVTtvQkFDVkMsT0FBTztvQkFDUEMsYUFBYTtvQkFDYkMsT0FBTztnQkFDVDtZQUNGO1lBQ0EsMkVBQTJFO1lBQzNFLElBQUk7Z0JBQ0YsTUFBTUMsV0FBVyxNQUFNLElBQUksQ0FBQ2pFLGNBQWM7Z0JBQzFDLE1BQU14RCxPQUFPeUgsU0FBU0MsSUFBSSxDQUFDQyxDQUFBQSxJQUFLeEgsT0FBT3dILEVBQUUxSCxFQUFFLE1BQU1FLE9BQU9iO2dCQUN4RCxJQUFJVSxNQUFNO29CQUNSLE9BQU87d0JBQ0xvSCxXQUFXcEgsS0FBS29ILFNBQVM7d0JBQ3pCQyxVQUFVckgsS0FBS3FILFFBQVE7d0JBQ3ZCQyxPQUFPdEgsS0FBS3NILEtBQUs7d0JBQ2pCTSxnQkFBZ0I1SCxLQUFLNEgsY0FBYzt3QkFDbkNDLFVBQVU3SCxLQUFLNkgsUUFBUTt3QkFDdkJOLGFBQWF2SCxLQUFLdUgsV0FBVzt3QkFDN0JPLGVBQWU5SCxLQUFLOEgsYUFBYTt3QkFDakNySSxPQUFPTyxLQUFLUCxLQUFLO3dCQUNqQitILE9BQU94SCxLQUFLd0gsS0FBSzt3QkFDakJPLFNBQVMvSCxLQUFLK0gsT0FBTztvQkFDdkI7Z0JBQ0Y7WUFDRixFQUFFLE9BQU9DLEtBQUs7WUFDWix3REFBd0Q7WUFDMUQ7WUFFQSwrQkFBK0I7WUFDL0IsT0FBT2xILFFBQVEsQ0FBQyxPQUFPLEVBQUV4QixRQUFRLEVBQUU7Z0JBQ2pDMkQsUUFBUTtnQkFDUmpDLGNBQWM7WUFDaEI7UUFDRjtRQUVBLE1BQU1pSCxVQUFTdEYsSUFNZDtZQUNDLElBQUlyRSxjQUFjO2dCQUNoQixjQUFjO2dCQUNkLE9BQU80SixRQUFRQyxPQUFPO1lBQ3hCO1lBQ0EsT0FBT3JILFFBQVEsYUFBYTtnQkFDMUJtQyxRQUFRO2dCQUNSQyxNQUFNaEUsS0FBS2lGLFNBQVMsQ0FBQ3hCO2dCQUNyQjNCLGNBQWM7WUFDaEI7UUFDRjtRQUVBLE1BQU1vSCxzQkFBcUI3RCxJQUFVO1lBQ25DLElBQUlqRyxjQUFjO2dCQUNoQixPQUFPO29CQUFFNEMsS0FBSztnQkFBd0I7WUFDeEM7WUFFQSxNQUFNOEIsV0FBVyxJQUFJZ0I7WUFDckJoQixTQUFTcUIsTUFBTSxDQUFDLFFBQVFFO1lBRXhCLE1BQU1uRSxVQUFVVDtZQUNoQix5RkFBeUY7WUFDekYsT0FBT1MsT0FBTyxDQUFDLGVBQWU7WUFFOUIsTUFBTWMsTUFBTVQsU0FBUztZQUVyQixNQUFNVSxXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDO2dCQUNBOEMsTUFBTUY7WUFDUjtZQUVBLElBQUksQ0FBQzdCLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsSUFBSUMsWUFBaUIsQ0FBQztnQkFDdEIsSUFBSUMsZUFBZTtnQkFFbkIsSUFBSTtvQkFDRkEsZUFBZSxNQUFNSixTQUFTSyxJQUFJO29CQUNsQyxJQUFJRCxjQUFjO3dCQUNoQixJQUFJOzRCQUNGRCxZQUFZcEMsS0FBS0MsS0FBSyxDQUFDb0M7d0JBQ3pCLEVBQUUsT0FBTTs0QkFDTkQsWUFBWTtnQ0FBRUksU0FBU0g7Z0NBQWNJLEtBQUtKOzRCQUFhO3dCQUN6RDtvQkFDRjtnQkFDRixFQUFFLE9BQU07b0JBQ05ELFlBQVk7d0JBQUVJLFNBQVMsQ0FBQyxLQUFLLEVBQUVQLFNBQVNZLE1BQU0sQ0FBQyxFQUFFLEVBQUVaLFNBQVNhLFVBQVUsRUFBRTtvQkFBQztnQkFDM0U7Z0JBRUEsTUFBTUMsZUFDSlgsVUFBVUksT0FBTyxJQUNqQkosVUFBVTVCLEtBQUssSUFDZjRCLFVBQVVLLEdBQUcsSUFDYixDQUFDLFdBQVcsRUFBRVIsU0FBU1ksTUFBTSxDQUFDLENBQUMsRUFBRVosU0FBU2EsVUFBVSxFQUFFO2dCQUV4RCxNQUFNTSxXQUFXLElBQUlDLE1BQU1OO2dCQUN0QkssU0FBaUJQLE1BQU0sR0FBR1osU0FBU1ksTUFBTTtnQkFDekNPLFNBQWlCaEIsU0FBUyxHQUFHQTtnQkFDbEMsTUFBTWdCO1lBQ1I7WUFFQSxNQUFNZCxPQUFPLE1BQU1MLFNBQVNLLElBQUk7WUFDaEMsT0FBTztnQkFBRU4sS0FBS007WUFBSyxFQUFFLG9DQUFvQzs7UUFDM0Q7UUFFQSxNQUFNNkcsZ0JBQWVDLGVBQXVCLEVBQUVDLFdBQW1CO1lBQy9ELElBQUlqSyxjQUFjO2dCQUNoQixPQUFPO29CQUFFb0QsU0FBUztnQkFBZ0M7WUFDcEQ7WUFDQSxPQUFPWixRQUFRLDZCQUE2QjtnQkFDMUNtQyxRQUFRO2dCQUNSQyxNQUFNaEUsS0FBS2lGLFNBQVMsQ0FBQztvQkFBRW1FO29CQUFpQkM7Z0JBQVk7WUFDdEQ7UUFDRjtRQUVBLE1BQU1DO1lBQ0osSUFBSWxLLGNBQWM7Z0JBQ2hCLE9BQU80SixRQUFRQyxPQUFPO1lBQ3hCO1lBQ0EsT0FBT3JILFFBQVEsNkJBQTZCO2dCQUMxQ21DLFFBQVE7Z0JBQ1JqQyxjQUFjO1lBQ2hCO1FBQ0Y7UUFFQSxNQUFNeUg7WUFDSixJQUFJbkssY0FBYztnQkFDaEIsT0FBTzRKLFFBQVFDLE9BQU87WUFDeEI7WUFDQSxPQUFPckgsUUFBUSx5QkFBeUI7Z0JBQ3RDbUMsUUFBUTtnQkFDUmpDLGNBQWM7WUFDaEI7UUFDRjtRQUVBLE1BQU13QztZQWNKLElBQUlsRixjQUFjO2dCQUNoQixPQUFPLEVBQUU7WUFDWDtZQUNBLE9BQU93QyxRQUFRLG9CQUFvQjtnQkFDakNtQyxRQUFRO2dCQUNSakMsY0FBYztZQUNoQjtRQUNGO1FBRUEsTUFBTTBILFlBQVdwSixNQUFjO1lBQzdCLElBQUloQixjQUFjO2dCQUNoQixPQUFPNEosUUFBUUMsT0FBTztZQUN4QjtZQUNBLE9BQU9ySCxRQUFRLENBQUMsYUFBYSxFQUFFeEIsT0FBTyxPQUFPLENBQUMsRUFBRTtnQkFDOUMyRCxRQUFRO2dCQUNSQyxNQUFNaEUsS0FBS2lGLFNBQVMsQ0FBQyxDQUFDO2dCQUN0Qm5ELGNBQWM7WUFDaEI7UUFDRjtRQUVBLE1BQU0ySCxhQUFZckosTUFBYztZQUM5QixJQUFJaEIsY0FBYztnQkFDaEIsT0FBTzRKLFFBQVFDLE9BQU87WUFDeEI7WUFDQSxPQUFPckgsUUFBUSxDQUFDLGFBQWEsRUFBRXhCLE9BQU8sUUFBUSxDQUFDLEVBQUU7Z0JBQy9DMkQsUUFBUTtnQkFDUkMsTUFBTWhFLEtBQUtpRixTQUFTLENBQUMsQ0FBQztnQkFDdEJuRCxjQUFjO1lBQ2hCO1FBQ0Y7UUFFQSxNQUFNNEgsY0FBYXRKLE1BQWM7WUFDL0IsSUFBSWhCLGNBQWM7Z0JBQ2hCLE9BQU80SixRQUFRQyxPQUFPO1lBQ3hCO1lBQ0EsT0FBT3JILFFBQVEsQ0FBQyxhQUFhLEVBQUV4QixPQUFPLGVBQWUsQ0FBQyxFQUFFO2dCQUN0RDJELFFBQVE7Z0JBQ1JqQyxjQUFjO1lBQ2hCO1FBQ0Y7UUFFQSxNQUFNNkgsaUJBQWdCdkosTUFBYztZQUNsQyxJQUFJaEIsY0FBYztnQkFDaEIsT0FBTzRKLFFBQVFDLE9BQU87WUFDeEI7WUFDQSxPQUFPckgsUUFBUSxDQUFDLGFBQWEsRUFBRXhCLE9BQU8sa0JBQWtCLENBQUMsRUFBRTtnQkFDekQyRCxRQUFRO2dCQUNSakMsY0FBYztZQUNoQjtRQUNGO1FBRUEsTUFBTThILG9CQUFtQnhKLE1BQWM7WUFDckMsSUFBSWhCLGNBQWM7Z0JBQ2hCLE9BQU80SixRQUFRQyxPQUFPO1lBQ3hCO1lBQ0EsT0FBT3JILFFBQVEsQ0FBQyxhQUFhLEVBQUV4QixPQUFPLGNBQWMsQ0FBQyxFQUFFO2dCQUNyRDJELFFBQVE7Z0JBQ1JqQyxjQUFjO1lBQ2hCO1FBQ0Y7UUFFQSxNQUFNK0gsZ0JBQWV6SixNQUFjO1lBQ2pDLElBQUloQixjQUFjO2dCQUNoQixPQUFPNEosUUFBUUMsT0FBTztZQUN4QjtZQUNBLE9BQU9ySCxRQUFRLENBQUMsYUFBYSxFQUFFeEIsT0FBTyxpQkFBaUIsQ0FBQyxFQUFFO2dCQUN4RDJELFFBQVE7Z0JBQ1JqQyxjQUFjO1lBQ2hCO1FBQ0Y7SUFDRjtJQUVBLDJEQUEyRDtJQUMzRGdJLE1BQU07UUFDSixNQUFNQyxVQUFTdEcsSUFRZDtZQUNDLElBQUlyRSxjQUFjO2dCQUNoQixNQUFNaUYsT0FBTyxNQUFNOUU7Z0JBQ25CLHFDQUFxQztnQkFDckMsTUFBTSxJQUFJeUosUUFBUSxDQUFDQyxVQUFZZSxXQUFXZixTQUFTO2dCQUNuRCxPQUFPO29CQUFFekcsU0FBUztnQkFBK0I7WUFDbkQ7WUFFQSxJQUFJO2dCQUNGLE1BQU15SCxjQUFjO29CQUNsQi9CLFdBQVd6RSxLQUFLeUUsU0FBUztvQkFDekJDLFVBQVUxRSxLQUFLMEUsUUFBUTtvQkFDdkJDLE9BQU8zRSxLQUFLMkUsS0FBSztvQkFDakI4QixVQUFVekcsS0FBS3lHLFFBQVE7b0JBQ3ZCdkIsVUFBVWxGLEtBQUtrRixRQUFRO29CQUN2Qk4sYUFBYTVFLEtBQUs0RSxXQUFXO29CQUM3QixHQUFJNUUsS0FBSzBHLElBQUksSUFBSTt3QkFBRUEsTUFBTTFHLEtBQUswRyxJQUFJO29CQUFDLENBQUM7Z0JBQ3RDO2dCQUdBLE9BQU8sTUFBTXZJLFFBQVEsa0JBQWtCO29CQUNyQ21DLFFBQVE7b0JBQ1JDLE1BQU1oRSxLQUFLaUYsU0FBUyxDQUFDZ0Y7b0JBQ3JCbkksY0FBYztnQkFDaEI7WUFDRixFQUFFLE9BQU90QixPQUFZO2dCQUNuQixrREFBa0Q7Z0JBQ2xELElBQUlBLE9BQU9vRCxtQkFBbUI7b0JBQzVCLE1BQU0sSUFBSVAsTUFDUjtnQkFFSjtnQkFDQSxNQUFNN0M7WUFDUjtRQUNGO1FBRUEsTUFBTTRKLE9BQU1oQyxLQUFhLEVBQUU4QixRQUFnQjtZQUN6QyxJQUFJOUssY0FBYztnQkFDaEIsTUFBTWlGLE9BQU8sTUFBTTlFO2dCQUNuQixtQ0FBbUM7Z0JBQ25DLE1BQU0sSUFBSThELE1BQU07WUFDbEI7WUFDQSxPQUFPekIsUUFBUSxlQUFlO2dCQUM1Qm1DLFFBQVE7Z0JBQ1JDLE1BQU1oRSxLQUFLaUYsU0FBUyxDQUFDO29CQUFFbUQ7b0JBQU84QjtnQkFBUztnQkFDdkNwSSxjQUFjO1lBQ2hCO1FBQ0Y7UUFFQXVJLFNBQVEzSyxLQUFhLEVBQUVvQixJQUFVO1lBQy9CLElBQUksSUFBNkIsRUFBRTtnQkFDakNKLGFBQWE0SixPQUFPLENBQUN0TCxnQkFBZ0JVO2dCQUNyQ2dCLGFBQWE0SixPQUFPLENBQUNwTCxlQUFlYyxLQUFLaUYsU0FBUyxDQUFDbkU7WUFDckQ7UUFDRjtRQUVBeUo7WUFDRSxJQUFJLEtBQTZCLEVBQUUsRUFBTztZQUMxQyxPQUFPN0osYUFBYUMsT0FBTyxDQUFDM0I7UUFDOUI7UUFFQXdMO1lBQ0UsSUFBSSxLQUE2QixFQUFFLEVBQU87WUFDMUMsTUFBTTVKLFdBQVdGLGFBQWFDLE9BQU8sQ0FBQ3pCO1lBQ3RDLE9BQU8wQixXQUFXWixLQUFLQyxLQUFLLENBQUNXLFlBQVk7UUFDM0M7UUFFQTZKO1lBQ0UsSUFBSSxJQUE2QixFQUFFO2dCQUNqQy9KLGFBQWFnSyxVQUFVLENBQUMxTDtnQkFDeEIwQixhQUFhZ0ssVUFBVSxDQUFDeEw7WUFDMUI7UUFDRjtRQUVBeUwsU0FBUVIsSUFBWTtZQUNsQixNQUFNckosT0FBTyxJQUFJLENBQUMwSixPQUFPO1lBQ3pCLE9BQU8xSixNQUFNUCxNQUFNaUQsU0FBUzJHLFNBQWdCO1FBQzlDO1FBRUEsTUFBTVMsUUFBT3hDLEtBQWEsRUFBRXlDLGdCQUF3QjtZQUNsRCxJQUFJekwsY0FBYztnQkFDaEIsTUFBTSxJQUFJNEosUUFBUSxDQUFDQyxVQUFZZSxXQUFXZixTQUFTO2dCQUNuRCxPQUFPO29CQUFFekcsU0FBUztnQkFBNkI7WUFDakQ7WUFDQSxPQUFPWixRQUFRLGdCQUFnQjtnQkFDN0JtQyxRQUFRO2dCQUNSQyxNQUFNaEUsS0FBS2lGLFNBQVMsQ0FBQztvQkFBRW1EO29CQUFPeUM7Z0JBQWlCO2dCQUMvQy9JLGNBQWM7WUFDaEI7UUFDRjtRQUVBLE1BQU1nSix3QkFBdUIxQyxLQUFhO1lBQ3hDLElBQUloSixjQUFjO2dCQUNoQixNQUFNLElBQUk0SixRQUFRLENBQUNDLFVBQVllLFdBQVdmLFNBQVM7Z0JBQ25ELE9BQU87b0JBQUV6RyxTQUFTO2dCQUF3QztZQUM1RDtZQUNBLE9BQU9aLFFBQVEsQ0FBQyxtQkFBbUIsRUFBRW1KLG1CQUFtQjNDLFFBQVEsRUFBRTtnQkFDaEVyRSxRQUFRO2dCQUNSakMsY0FBYztZQUNoQjtRQUNGO1FBRUEsTUFBTWtKLGdCQUFlNUMsS0FBYTtZQUNoQyxJQUFJaEosY0FBYztnQkFDaEIsTUFBTSxJQUFJNEosUUFBUSxDQUFDQyxVQUFZZSxXQUFXZixTQUFTO2dCQUNuRDtZQUNGO1lBQ0EsT0FBT3JILFFBQVEseUJBQXlCO2dCQUN0Q21DLFFBQVE7Z0JBQ1JDLE1BQU1oRSxLQUFLaUYsU0FBUyxDQUFDO29CQUFFbUQ7Z0JBQU07Z0JBQzdCdEcsY0FBYztZQUNoQjtRQUNGO1FBRUEsTUFBTW1KLGtCQUFpQnZMLEtBQWE7WUFDbEMsSUFBSU4sY0FBYztnQkFDaEIsTUFBTSxJQUFJNEosUUFBUSxDQUFDQyxVQUFZZSxXQUFXZixTQUFTO2dCQUNuRCxPQUFPO29CQUFFaUMsT0FBTztnQkFBSztZQUN2QjtZQUNBLE9BQU90SixRQUFRLDRCQUE0QjtnQkFDekNtQyxRQUFRO2dCQUNSQyxNQUFNaEUsS0FBS2lGLFNBQVMsQ0FBQztvQkFBRXZGO2dCQUFNO2dCQUM3Qm9DLGNBQWM7WUFDaEI7UUFDRjtRQUVBLE1BQU1xSixlQUFjekwsS0FBYSxFQUFFd0ssUUFBZ0I7WUFDakQsSUFBSTlLLGNBQWM7Z0JBQ2hCLE1BQU0sSUFBSTRKLFFBQVEsQ0FBQ0MsVUFBWWUsV0FBV2YsU0FBUztnQkFDbkQ7WUFDRjtZQUNBLE9BQU9ySCxRQUFRLHdCQUF3QjtnQkFDckNtQyxRQUFRO2dCQUNSQyxNQUFNaEUsS0FBS2lGLFNBQVMsQ0FBQztvQkFBRXZGO29CQUFPd0s7Z0JBQVM7Z0JBQ3ZDcEksY0FBYztZQUNoQjtRQUNGO1FBRUEsTUFBTXNKLGlCQUFnQmhELEtBQWEsRUFBRWlELElBQVk7WUFDL0MsSUFBSWpNLGNBQWM7Z0JBQ2hCLE1BQU0sSUFBSTRKLFFBQVEsQ0FBQ0MsVUFBWWUsV0FBV2YsU0FBUztnQkFDbkQsT0FBTztvQkFBRWlDLE9BQU87Z0JBQUs7WUFDdkI7WUFDQSxPQUFPdEosUUFBUSwyQkFBMkI7Z0JBQ3hDbUMsUUFBUTtnQkFDUkMsTUFBTWhFLEtBQUtpRixTQUFTLENBQUM7b0JBQUVtRDtvQkFBT2lEO2dCQUFLO2dCQUNuQ3ZKLGNBQWM7WUFDaEI7UUFDRjtRQUVBLE1BQU13Six1QkFBc0JsRCxLQUFhLEVBQUVpRCxJQUFZLEVBQUVoQyxXQUFtQjtZQUMxRSxJQUFJakssY0FBYztnQkFDaEIsTUFBTSxJQUFJNEosUUFBUSxDQUFDQyxVQUFZZSxXQUFXZixTQUFTO2dCQUNuRCxPQUFPO29CQUFFekcsU0FBUztnQkFBOEI7WUFDbEQ7WUFDQSxPQUFPWixRQUFRLGtDQUFrQztnQkFDL0NtQyxRQUFRO2dCQUNSQyxNQUFNaEUsS0FBS2lGLFNBQVMsQ0FBQztvQkFBRW1EO29CQUFPaUQ7b0JBQU1oQztnQkFBWTtnQkFDaER2SCxjQUFjO1lBQ2hCO1FBQ0Y7SUFDRjtJQUVBeUosVUFBVTtRQUNSOztLQUVDLEdBQ0QsTUFBTWpIO1lBdUJKLElBQUlsRixjQUFjO2dCQUNoQixPQUFPLEVBQUU7WUFDWDtZQUNBLE1BQU00QyxNQUFNLEdBQUd4RCxxQkFBcUIsdUJBQXVCLENBQUM7WUFDNUQsSUFBSTtnQkFDRixNQUFNeUQsV0FBVyxNQUFNQyxNQUFNRixLQUFLO29CQUNoQytCLFFBQVE7b0JBQ1I3QyxTQUFTO3dCQUNQLGdCQUFnQjt3QkFDaEIsR0FBR1QsZ0JBQWdCO29CQUNyQjtnQkFDRjtnQkFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7b0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztvQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsMEJBQTBCLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtnQkFDckY7Z0JBRUEsT0FBT1osU0FBU3lCLElBQUk7WUFDdEIsRUFBRSxPQUFPbEQsT0FBWTtnQkFDbkIsSUFBSUEsT0FBT2dDLFNBQVNnQixTQUFTLHNCQUFzQmhELE9BQU9nQyxTQUFTZ0IsU0FBUywyQkFBMkI7b0JBQ3JHLE1BQU1HLGtCQUFrQixJQUFJTixNQUMxQixDQUFDLDZDQUE2QyxFQUFFN0UscUJBQXFCLDBDQUEwQyxDQUFDO29CQUU3R21GLGdCQUF3QkMsaUJBQWlCLEdBQUc7b0JBQ2pELE1BQU1EO2dCQUNSO2dCQUNBLE1BQU1uRDtZQUNSO1FBQ0Y7UUFFQTs7O0tBR0MsR0FDRCxNQUFNa0UsUUFBT2pCLElBT1o7WUFDQyxJQUFJckUsY0FBYztnQkFDaEIsTUFBTWlGLE9BQU8sTUFBTTlFO2dCQUNuQixPQUFPOEUsS0FBS2tILFFBQVEsRUFBRTdHLFNBQVNqQixTQUFTO29CQUFFWixRQUFRO29CQUFZTCxTQUFTO2dCQUF1QjtZQUNoRztZQUVBLE1BQU1SLE1BQU0sR0FBR3hELHFCQUFxQixxQkFBcUIsQ0FBQztZQUMxRCxNQUFNeUQsV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0E4QyxNQUFNaEUsS0FBS2lGLFNBQVMsQ0FBQztvQkFDbkI3RSxRQUFRLE9BQU9xRCxLQUFLckQsTUFBTSxLQUFLLFdBQVdvTCxTQUFTL0gsS0FBS3JELE1BQU0sSUFBSXFELEtBQUtyRCxNQUFNO29CQUM3RXlFLFlBQVlwQixLQUFLb0IsVUFBVTtvQkFDM0J1QixhQUFhM0MsS0FBSzJDLFdBQVc7b0JBQzdCQyxjQUFjNUMsS0FBSzRDLFlBQVk7b0JBQy9Cb0YsZ0JBQWdCaEksS0FBS2dJLGNBQWM7b0JBQ25DQyxnQkFBZ0JqSSxLQUFLaUksY0FBYztnQkFDckM7WUFDRjtZQUVBLE1BQU1DLGVBQWUsTUFBTTFKLFNBQVN5QixJQUFJO1lBRXhDLElBQUksQ0FBQ3pCLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsd0VBQXdFO2dCQUN4RSxJQUFJd0osYUFBYTlJLE1BQU0sS0FBSyxZQUFZO29CQUN0QyxPQUFPOEk7Z0JBQ1Q7Z0JBQ0EsTUFBTSxJQUFJdEksTUFBTXNJLGFBQWFuSixPQUFPLElBQUksQ0FBQywwQkFBMEIsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO1lBQ3hGO1lBRUEsT0FBTzhJO1FBQ1Q7UUFFQTs7S0FFQyxHQUNELE1BQU1uSCxTQUFRekQsRUFBbUI7WUFDL0IsSUFBSTNCLGNBQWM7Z0JBQ2hCLE1BQU1pRixPQUFPLE1BQU05RTtnQkFDbkIsT0FBTzhFLEtBQUtrSCxRQUFRLEVBQUUvRyxVQUFVekQsT0FBTztZQUN6QztZQUVBLE1BQU1pQixNQUFNLEdBQUd4RCxxQkFBcUIsY0FBYyxFQUFFdUMsSUFBSTtZQUN4RCxNQUFNa0IsV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsR0FBR1QsZ0JBQWdCO2dCQUNyQjtZQUNGO1lBRUEsSUFBSSxDQUFDd0IsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixJQUFJRixTQUFTWSxNQUFNLEtBQUssS0FBSztvQkFDM0IsT0FBTztnQkFDVDtnQkFDQSxNQUFNVCxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSSxDQUFDLHlCQUF5QixFQUFFUCxTQUFTWSxNQUFNLEVBQUU7WUFDcEY7WUFFQSxPQUFPWixTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTWtJLGVBQWN2RSxRQUF5QjtZQUMzQyxJQUFJakksY0FBYztnQkFDaEIsTUFBTWlGLE9BQU8sTUFBTTlFO2dCQUNuQixPQUFPOEUsS0FBS2tILFFBQVEsRUFBRUssZ0JBQWdCdkUsYUFBYSxFQUFFO1lBQ3ZEO1lBRUEsTUFBTXJGLE1BQU0sR0FBR3hELHFCQUFxQix1QkFBdUIsRUFBRTZJLFVBQVU7WUFDdkUsTUFBTXBGLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztnQkFDaEMrQixRQUFRO2dCQUNSN0MsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLEdBQUdULGdCQUFnQjtnQkFDckI7WUFDRjtZQUVBLElBQUksQ0FBQ3dCLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlaLE1BQU1qQixVQUFVSSxPQUFPLElBQUksQ0FBQywwQkFBMEIsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO1lBQ3JGO1lBRUEsT0FBT1osU0FBU3lCLElBQUk7UUFDdEI7UUFFQTs7S0FFQyxHQUNELE1BQU1tSSxtQkFBa0J6TCxNQUF1QjtZQUM3QyxJQUFJaEIsY0FBYztnQkFDaEIsaURBQWlEO2dCQUNqRCxPQUFPO1lBQ1Q7WUFFQSxNQUFNNEMsTUFBTSxHQUFHeEQscUJBQXFCLDZCQUE2QixFQUFFNEIsUUFBUTtZQUMzRSxNQUFNNkIsV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsR0FBR1QsZ0JBQWdCO2dCQUNyQjtZQUNGO1lBRUEsSUFBSXdCLFNBQVNZLE1BQU0sS0FBSyxPQUFPWixTQUFTWSxNQUFNLEtBQUssS0FBSztnQkFDdEQsT0FBTztZQUNUO1lBRUEsSUFBSSxDQUFDWixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsaUNBQWlDLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtZQUM1RjtZQUVBLE9BQU9aLFNBQVN5QixJQUFJO1FBQ3RCO1FBRUE7O0tBRUMsR0FDRCxNQUFNb0ksb0JBQW1CMUwsTUFBdUI7WUFDOUMsSUFBSWhCLGNBQWM7Z0JBQ2hCLDJCQUEyQjtnQkFDM0IsT0FBTyxFQUFFO1lBQ1g7WUFFQSxNQUFNNEMsTUFBTSxHQUFHeEQscUJBQXFCLDZCQUE2QixFQUFFNEIsUUFBUTtZQUMzRSxNQUFNNkIsV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsR0FBR1QsZ0JBQWdCO2dCQUNyQjtZQUNGO1lBRUEsSUFBSSxDQUFDd0IsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSSxDQUFDLGtDQUFrQyxFQUFFUCxTQUFTWSxNQUFNLEVBQUU7WUFDN0Y7WUFFQSxPQUFPWixTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTXFJLDRCQUEyQjNMLE1BQXVCO1lBQ3RELElBQUloQixjQUFjO2dCQUNoQiwyQkFBMkI7Z0JBQzNCLE9BQU8sRUFBRTtZQUNYO1lBRUEsTUFBTTRDLE1BQU0sR0FBR3hELHFCQUFxQiw2QkFBNkIsRUFBRTRCLFFBQVE7WUFDM0UsTUFBTTZCLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztnQkFDaEMrQixRQUFRO2dCQUNSN0MsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLEdBQUdULGdCQUFnQjtnQkFDckI7WUFDRjtZQUVBLElBQUksQ0FBQ3dCLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlaLE1BQU1qQixVQUFVSSxPQUFPLElBQUksQ0FBQywyQ0FBMkMsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO1lBQ3RHO1lBRUEsT0FBT1osU0FBU3lCLElBQUk7UUFDdEI7UUFFQTs7S0FFQyxHQUNELE1BQU1zSSxpQkFBZ0JuSCxVQUFrQjtZQVF0QyxJQUFJekYsY0FBYztnQkFDaEIscUJBQXFCO2dCQUNyQixPQUFPO29CQUNMMkIsSUFBSThEO29CQUNKb0gsU0FBUztvQkFDVEMsZUFBZTtvQkFDZkMsY0FBYztvQkFDZEMsaUJBQWlCO2dCQUNuQjtZQUNGO1lBRUEsTUFBTXBLLE1BQU0sR0FBR3hELHFCQUFxQix1QkFBdUIsRUFBRXFHLFlBQVk7WUFDekUsSUFBSTtnQkFDRixNQUFNNUMsV0FBVyxNQUFNQyxNQUFNRixLQUFLO29CQUNoQytCLFFBQVE7b0JBQ1I3QyxTQUFTO3dCQUNQLGdCQUFnQjt3QkFDaEIsR0FBR1QsZ0JBQWdCO29CQUNyQjtnQkFDRjtnQkFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7b0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztvQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFUCxTQUFTWSxNQUFNLEVBQUU7Z0JBQ3RFO2dCQUVBLE9BQU9aLFNBQVN5QixJQUFJO1lBQ3RCLEVBQUUsT0FBT2xELE9BQVk7Z0JBQ25CLElBQUlBLE9BQU9nQyxTQUFTZ0IsU0FBUyxzQkFBc0JoRCxPQUFPZ0MsU0FBU2dCLFNBQVMsNkJBQTZCaEQsT0FBT2dDLFNBQVNnQixTQUFTLFNBQVM7b0JBQ3pJLE1BQU1HLGtCQUFrQixJQUFJTixNQUMxQixDQUFDLDZDQUE2QyxFQUFFN0UscUJBQXFCLDBDQUEwQyxDQUFDO29CQUU3R21GLGdCQUF3QkMsaUJBQWlCLEdBQUc7b0JBQ2pELE1BQU1EO2dCQUNSO2dCQUNBLE1BQU1uRDtZQUNSO1FBQ0Y7UUFFQTs7S0FFQyxHQUNELE1BQU02TDtZQUNKLElBQUlqTixjQUFjO2dCQUNoQixPQUFPO29CQUFFa04sV0FBVztnQkFBRTtZQUN4QjtZQUVBLE1BQU10SyxNQUFNLEdBQUd4RCxxQkFBcUIsd0JBQXdCLENBQUM7WUFDN0QsTUFBTXlELFdBQVcsTUFBTUMsTUFBTUYsS0FBSztnQkFDaEMrQixRQUFRO2dCQUNSN0MsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO1lBQ0Y7WUFFQSxJQUFJZSxTQUFTWSxNQUFNLEtBQUssT0FBT1osU0FBU1ksTUFBTSxLQUFLLEtBQUs7Z0JBQ3RELE9BQU87WUFDVDtZQUVBLElBQUksQ0FBQ1osU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixPQUFPO1lBQ1Q7WUFFQSxPQUFPRixTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTTRCLFFBQU92RSxFQUFtQixFQUFFMEMsSUFLakM7WUFDQyxJQUFJckUsY0FBYztnQkFDaEIsTUFBTWlGLE9BQU8sTUFBTTlFO2dCQUNuQixPQUFPOEUsS0FBS2tILFFBQVEsRUFBRWpHLFNBQVN2RSxJQUFJMEMsU0FBUztZQUM5QztZQUVBLE1BQU16QixNQUFNLEdBQUd4RCxxQkFBcUIsY0FBYyxFQUFFdUMsSUFBSTtZQUN4RCxNQUFNa0IsV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0E4QyxNQUFNaEUsS0FBS2lGLFNBQVMsQ0FBQztvQkFDbkJtQixhQUFhM0MsS0FBSzJDLFdBQVc7b0JBQzdCQyxjQUFjNUMsS0FBSzRDLFlBQVk7b0JBQy9Cb0YsZ0JBQWdCaEksS0FBS2dJLGNBQWM7b0JBQ25DQyxnQkFBZ0JqSSxLQUFLaUksY0FBYztnQkFDckM7WUFDRjtZQUVBLElBQUksQ0FBQ3pKLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNbEIsZUFBZVgsVUFBVUksT0FBTyxJQUFJSixVQUFVNUIsS0FBSyxJQUFJLENBQUMsMEJBQTBCLEVBQUV5QixTQUFTWSxNQUFNLEVBQUU7Z0JBQzNHLE1BQU1yQyxRQUFRLElBQUk2QyxNQUFNTjtnQkFFbkJ2QyxNQUFjcUMsTUFBTSxHQUFHWixTQUFTWSxNQUFNO2dCQUN0Q3JDLE1BQWMrTCxTQUFTLEdBQUduSyxVQUFVNUIsS0FBSztnQkFDOUMsTUFBTUE7WUFDUjtZQUVBLE1BQU1vRSxTQUFTLE1BQU0zQyxTQUFTeUIsSUFBSTtZQUNsQyxPQUFPa0I7UUFDVDtRQUVBOztLQUVDLEdBQ0QsTUFBTWEsUUFBTzFFLEVBQW1CLEVBQUVYLE1BQXVCO1lBQ3ZELElBQUloQixjQUFjO2dCQUNoQixNQUFNaUYsT0FBTyxNQUFNOUU7Z0JBQ25CLE9BQU84RSxLQUFLa0gsUUFBUSxFQUFFOUYsU0FBUzFFLElBQUlYO1lBQ3JDO1lBRUEsTUFBTTRCLE1BQU0sR0FBR3hELHFCQUFxQixjQUFjLEVBQUV1QyxHQUFHLFFBQVEsRUFBRVgsUUFBUTtZQUN6RSxNQUFNNkIsV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsR0FBR1QsZ0JBQWdCO2dCQUNyQjtZQUNGO1lBRUEsSUFBSSxDQUFDd0IsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSUosVUFBVTVCLEtBQUssSUFBSSxDQUFDLDBCQUEwQixFQUFFeUIsU0FBU1ksTUFBTSxFQUFFO1lBQ3hHO1lBRUEsT0FBT1osU0FBU3lCLElBQUk7UUFDdEI7UUFFQTs7S0FFQyxHQUNELE1BQU04SSxnQkFBZXpMLEVBQW1CLEVBQUVzRyxRQUF5QjtZQUNqRSxJQUFJakksY0FBYztnQkFDaEIsT0FBTztvQkFBRW9ELFNBQVM7Z0JBQWtDO1lBQ3REO1lBRUEsTUFBTVIsTUFBTSxHQUFHeEQscUJBQXFCLGNBQWMsRUFBRXVDLEdBQUcsd0JBQXdCLEVBQUVzRyxVQUFVO1lBQzNGLE1BQU1wRixXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixHQUFHVCxnQkFBZ0I7Z0JBQ3JCO1lBQ0Y7WUFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJSixVQUFVNUIsS0FBSyxJQUFJLENBQUMsb0JBQW9CLEVBQUV5QixTQUFTWSxNQUFNLEVBQUU7WUFDbEc7WUFFQSxPQUFPWixTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTStJLHNCQUFxQjFMLEVBQW1CLEVBQUVrTCxPQUF3QjtZQUN0RSxJQUFJN00sY0FBYztnQkFDaEIsT0FBTztvQkFBRW9ELFNBQVM7Z0JBQWtDO1lBQ3REO1lBRUEsTUFBTVIsTUFBTSxHQUFHeEQscUJBQXFCLGNBQWMsRUFBRXVDLEdBQUcsdUJBQXVCLEVBQUVrTCxTQUFTO1lBQ3pGLE1BQU1oSyxXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixHQUFHVCxnQkFBZ0I7Z0JBQ3JCO1lBQ0Y7WUFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJSixVQUFVNUIsS0FBSyxJQUFJLENBQUMsNEJBQTRCLEVBQUV5QixTQUFTWSxNQUFNLEVBQUU7WUFDMUc7WUFFQSxPQUFPWixTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTWdKLGtCQUFpQjNMLEVBQW1CLEVBQUVYLE1BQXVCO1lBQ2pFLElBQUloQixjQUFjO2dCQUNoQixNQUFNaUYsT0FBTyxNQUFNOUU7Z0JBQ25CLE9BQU84RSxLQUFLa0gsUUFBUSxFQUFFbUIsbUJBQW1CM0wsSUFBSVgsV0FBVztZQUMxRDtZQUVBLE1BQU00QixNQUFNLEdBQUd4RCxxQkFBcUIsY0FBYyxFQUFFdUMsR0FBRyxpQkFBaUIsRUFBRVgsUUFBUTtZQUNsRixNQUFNNkIsV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsR0FBR1QsZ0JBQWdCO2dCQUNyQjtZQUNGO1lBRUEsSUFBSSxDQUFDd0IsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSUosVUFBVTVCLEtBQUssSUFBSSxDQUFDLCtCQUErQixFQUFFeUIsU0FBU1ksTUFBTSxFQUFFO1lBQzdHO1lBRUEsT0FBT1osU0FBU3lCLElBQUk7UUFDdEI7UUFFQTs7S0FFQyxHQUNELE1BQU1pSiwyQkFBMEJWLE9BQXdCO1lBQ3RELElBQUk3TSxjQUFjO2dCQUNoQixPQUFPLEVBQUU7WUFDWDtZQUVBLE1BQU00QyxNQUFNLEdBQUd4RCxxQkFBcUIsb0NBQW9DLEVBQUV5TixTQUFTO1lBQ25GLE1BQU1oSyxXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixHQUFHVCxnQkFBZ0I7Z0JBQ3JCO1lBQ0Y7WUFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsa0NBQWtDLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtZQUM3RjtZQUVBLE9BQU9aLFNBQVN5QixJQUFJO1FBQ3RCO1FBRUE7O0tBRUMsR0FDRCxNQUFNa0osd0JBQXVCWCxPQUF3QjtZQUNuRCxJQUFJN00sY0FBYztnQkFDaEIsT0FBTyxFQUFFO1lBQ1g7WUFFQSxNQUFNNEMsTUFBTSxHQUFHeEQscUJBQXFCLG1DQUFtQyxFQUFFeU4sU0FBUztZQUNsRixNQUFNaEssV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsR0FBR1QsZ0JBQWdCO2dCQUNyQjtZQUNGO1lBRUEsSUFBSSxDQUFDd0IsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSSxDQUFDLHNDQUFzQyxFQUFFUCxTQUFTWSxNQUFNLEVBQUU7WUFDakc7WUFFQSxPQUFPWixTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTW1KLG1CQUFrQlAsU0FBMEIsRUFBRUwsT0FBd0I7WUFDMUUsSUFBSTdNLGNBQWM7Z0JBQ2hCLE9BQU87b0JBQUVvRCxTQUFTO2dCQUF1QjtZQUMzQztZQUVBLE1BQU1SLE1BQU0sR0FBR3hELHFCQUFxQixjQUFjLEVBQUU4TixVQUFVLGdCQUFnQixFQUFFTCxTQUFTO1lBQ3pGLE1BQU1oSyxXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixHQUFHVCxnQkFBZ0I7Z0JBQ3JCO1lBQ0Y7WUFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJSixVQUFVNUIsS0FBSyxJQUFJLENBQUMsOEJBQThCLEVBQUV5QixTQUFTWSxNQUFNLEVBQUU7WUFDNUc7WUFFQSxPQUFPWixTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTW9KLG1CQUFrQlIsU0FBMEIsRUFBRUwsT0FBd0I7WUFDMUUsSUFBSTdNLGNBQWM7Z0JBQ2hCLE9BQU87b0JBQUVvRCxTQUFTO2dCQUF1QjtZQUMzQztZQUVBLE1BQU1SLE1BQU0sR0FBR3hELHFCQUFxQixjQUFjLEVBQUU4TixVQUFVLGdCQUFnQixFQUFFTCxTQUFTO1lBQ3pGLE1BQU1oSyxXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixHQUFHVCxnQkFBZ0I7Z0JBQ3JCO1lBQ0Y7WUFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJSixVQUFVNUIsS0FBSyxJQUFJLENBQUMsOEJBQThCLEVBQUV5QixTQUFTWSxNQUFNLEVBQUU7WUFDNUc7WUFFQSxPQUFPWixTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTXFKLGNBQWFkLE9BQXdCO1lBQ3pDLElBQUk3TSxjQUFjO2dCQUNoQixPQUFPLEVBQUU7WUFDWDtZQUVBLE1BQU00QyxNQUFNLEdBQUd4RCxxQkFBcUIsc0JBQXNCLEVBQUV5TixTQUFTO1lBQ3JFLE1BQU1oSyxXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixHQUFHVCxnQkFBZ0I7Z0JBQ3JCO1lBQ0Y7WUFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsMEJBQTBCLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtZQUNyRjtZQUVBLE9BQU9aLFNBQVN5QixJQUFJO1FBQ3RCO1FBRUE7O0tBRUMsR0FDRCxNQUFNc0osNkJBQTRCZixPQUF3QjtZQUN4RCxJQUFJN00sY0FBYztnQkFDaEIsT0FBTyxFQUFFO1lBQ1g7WUFFQSxNQUFNNEMsTUFBTSxHQUFHeEQscUJBQXFCLHNDQUFzQyxFQUFFeU4sU0FBUztZQUNyRixNQUFNaEssV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsR0FBR1QsZ0JBQWdCO2dCQUNyQjtZQUNGO1lBRUEsSUFBSSxDQUFDd0IsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSSxDQUFDLG9DQUFvQyxFQUFFUCxTQUFTWSxNQUFNLEVBQUU7WUFDL0Y7WUFFQSxPQUFPWixTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTXVKLGdDQUErQnBJLFVBQWtCO1lBQ3JELElBQUl6RixjQUFjO2dCQUNoQixPQUFPLEVBQUU7WUFDWDtZQUVBLE1BQU00QyxNQUFNLEdBQUd4RCxxQkFBcUIsaUNBQWlDLEVBQUVxRyxZQUFZO1lBQ25GLE1BQU01QyxXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixHQUFHVCxnQkFBZ0I7Z0JBQ3JCO1lBQ0Y7WUFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsb0NBQW9DLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtZQUMvRjtZQUVBLE9BQU9aLFNBQVN5QixJQUFJO1FBQ3RCO1FBRUE7O0tBRUMsR0FDRCxNQUFNd0osZUFBY1osU0FBMEIsRUFBRWxNLE1BQXVCO1lBQ3JFLElBQUloQixjQUFjO2dCQUNoQixPQUFPO29CQUFFb0QsU0FBUztnQkFBbUI7WUFDdkM7WUFFQSxNQUFNUixNQUFNLEdBQUd4RCxxQkFBcUIsY0FBYyxFQUFFOE4sVUFBVSxnQkFBZ0IsRUFBRWxNLFFBQVE7WUFDeEYsTUFBTTZCLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztnQkFDaEMrQixRQUFRO2dCQUNSN0MsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO1lBQ0Y7WUFFQSxJQUFJLENBQUNlLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlaLE1BQU1qQixVQUFVSSxPQUFPLElBQUlKLFVBQVU1QixLQUFLLElBQUksQ0FBQywwQkFBMEIsRUFBRXlCLFNBQVNZLE1BQU0sRUFBRTtZQUN4RztZQUVBLE9BQU9aLFNBQVN5QixJQUFJO1FBQ3RCO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEeUosVUFBVTtRQUNSOztLQUVDLEdBQ0QsTUFBTUMsY0FBYWQsU0FBaUI7WUFDbEMsSUFBSWxOLGNBQWM7Z0JBQ2hCLE9BQU87b0JBQ0xpTyxhQUFhO29CQUNiQyxJQUFJO29CQUNKQyxPQUFPO29CQUNQOUosTUFBTTtvQkFDTitKLFNBQVM7b0JBQ1RDLGdCQUFnQjtnQkFDbEI7WUFDRjtZQUVBLE1BQU16TCxNQUFNLEdBQUd0RCxxQkFBcUIsb0JBQW9CLENBQUM7WUFDekQsTUFBTXVELFdBQVcsTUFBTUMsTUFBTUYsS0FBSztnQkFDaEMrQixRQUFRO2dCQUNSN0MsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBOEMsTUFBTWhFLEtBQUtpRixTQUFTLENBQUM7b0JBQUVxSDtnQkFBVTtZQUNuQztZQUVBLElBQUksQ0FBQ3JLLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlaLE1BQU1qQixVQUFVSSxPQUFPLElBQUksQ0FBQyxpQ0FBaUMsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO1lBQzVGO1lBRUEsT0FBT1osU0FBU3lCLElBQUk7UUFDdEI7UUFFQTs7S0FFQyxHQUNELE1BQU1nSyxtQkFBa0JwQixTQUFpQjtZQUN2QyxJQUFJbE4sY0FBYztnQkFDaEIsT0FBTztvQkFDTGtOO29CQUNBekosUUFBUTtvQkFDUjhLLFlBQVk7b0JBQ1p2SCxhQUFhO29CQUNiQyxjQUFjO29CQUNkeEIsWUFBWTtvQkFDWitJLGVBQWU7b0JBQ2ZDLGVBQWU7b0JBQ2ZDLG9CQUFvQjtvQkFDcEIxTixRQUFRO29CQUNSMk4sZUFBZTtvQkFDZkMsZUFBZTtvQkFDZkMsY0FBYztvQkFDZEMsV0FBVztvQkFDWEMsbUJBQW1CO2dCQUNyQjtZQUNGO1lBRUEsTUFBTW5NLE1BQU0sR0FBR3RELHFCQUFxQixzQkFBc0IsRUFBRTROLFdBQVc7WUFDdkUsTUFBTXJLLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztnQkFDaEMrQixRQUFRO2dCQUNSN0MsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO1lBQ0Y7WUFFQSxJQUFJLENBQUNlLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsSUFBSVksZUFBZSxDQUFDLGlDQUFpQyxFQUFFZCxTQUFTWSxNQUFNLEVBQUU7Z0JBQ3hFLElBQUk7b0JBQ0YsTUFBTVQsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSTtvQkFDckMsMkNBQTJDO29CQUMzQ1gsZUFBZVgsVUFBVUksT0FBTyxJQUFJSixVQUFVaUosSUFBSSxJQUFJdEk7Z0JBQ3hELEVBQUUsT0FBT3FMLEdBQUc7b0JBQ1YsMkNBQTJDO29CQUMzQ3JMLGVBQWVkLFNBQVNhLFVBQVUsSUFBSUM7Z0JBQ3hDO2dCQUNBLE1BQU0sSUFBSU0sTUFBTU47WUFDbEI7WUFFQSxPQUFPZCxTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTTJLLHFCQUFvQmpPLE1BQWMsRUFBRXdJLGFBQXFCO1lBQzdELElBQUl4SixjQUFjO2dCQUNoQjtZQUNGO1lBRUEsTUFBTTRDLE1BQU0sR0FBR3RELHFCQUFxQiw0QkFBNEIsQ0FBQztZQUNqRSxNQUFNdUQsV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0E4QyxNQUFNaEUsS0FBS2lGLFNBQVMsQ0FBQztvQkFBRTdFO29CQUFRd0k7Z0JBQWM7WUFDL0M7WUFFQSxJQUFJLENBQUMzRyxTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsaUNBQWlDLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtZQUM1RjtRQUNGO1FBRUE7O0tBRUMsR0FDRCxNQUFNeUwsdUJBQXNCaEMsU0FBaUIsRUFBRWlDLE1BQWM7WUFDM0QsSUFBSW5QLGNBQWM7Z0JBQ2hCO1lBQ0Y7WUFFQSxNQUFNNEMsTUFBTSxHQUFHdEQscUJBQXFCLHNCQUFzQixFQUFFNE4sVUFBVSxRQUFRLENBQUM7WUFDL0UsTUFBTXJLLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztnQkFDaEMrQixRQUFRO2dCQUNSN0MsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBOEMsTUFBTWhFLEtBQUtpRixTQUFTLENBQUM7b0JBQUVzSjtnQkFBTztZQUNoQztZQUVBLElBQUksQ0FBQ3RNLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlaLE1BQU1qQixVQUFVSSxPQUFPLElBQUksQ0FBQyxtQ0FBbUMsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO1lBQzlGO1FBQ0Y7UUFFQSw2RUFBNkU7UUFFN0U7O0tBRUMsR0FDRCxNQUFNMkwsc0JBQXFCRCxNQUFjO1lBQ3ZDLElBQUluUCxjQUFjO2dCQUNoQixPQUFPO29CQUNMbVA7b0JBQ0ExTCxRQUFRO29CQUNSNEwsYUFBYTtvQkFDYm5DLFdBQVc7Z0JBQ2I7WUFDRjtZQUVBLE1BQU10SyxNQUFNLEdBQUd0RCxxQkFBcUIsaUJBQWlCLEVBQUU2UCxRQUFRO1lBQy9ELE1BQU10TSxXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsZ0JBQWdCO2dCQUNsQjtZQUNGO1lBRUEsSUFBSSxDQUFDZSxTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsb0NBQW9DLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtZQUMvRjtZQUVBLE9BQU9aLFNBQVN5QixJQUFJO1FBQ3RCO1FBRUE7O0tBRUMsR0FDRCxNQUFNZ0wsaUJBQWdCcEMsU0FBaUI7WUFDckMsSUFBSWxOLGNBQWM7Z0JBQ2hCLE9BQU87b0JBQ0x5RCxRQUFRO29CQUNSTCxTQUFTO2dCQUNYO1lBQ0Y7WUFFQSxNQUFNUixNQUFNLEdBQUd0RCxxQkFBcUIsc0JBQXNCLEVBQUU0TixVQUFVLFNBQVMsQ0FBQztZQUNoRixNQUFNckssV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsR0FBR1QsZ0JBQWdCO2dCQUNyQjtZQUNGO1lBRUEsSUFBSSxDQUFDd0IsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixJQUFJQyxZQUFpQixDQUFDO2dCQUN0QixJQUFJdU0sWUFBWTtnQkFDaEIsSUFBSTtvQkFDRkEsWUFBWSxNQUFNMU0sU0FBU0ssSUFBSTtvQkFDL0IsSUFBSXFNLFdBQVc7d0JBQ2IsSUFBSTs0QkFDRnZNLFlBQVlwQyxLQUFLQyxLQUFLLENBQUMwTzt3QkFDekIsRUFBRSxPQUFNOzRCQUNOdk0sWUFBWTtnQ0FBRUksU0FBU21NOzRCQUFVO3dCQUNuQztvQkFDRjtnQkFDRixFQUFFLE9BQU9QLEdBQUc7b0JBQ1YsMkNBQTJDO29CQUMzQ2hNLFlBQVk7d0JBQUVJLFNBQVNQLFNBQVNhLFVBQVUsSUFBSSxDQUFDLGNBQWMsRUFBRWIsU0FBU1ksTUFBTSxFQUFFO29CQUFDO2dCQUNuRjtnQkFFQSxNQUFNRSxlQUFlWCxVQUFVSSxPQUFPLElBQUlKLFVBQVU1QixLQUFLLElBQUltTyxhQUFhLENBQUMsNEJBQTRCLEVBQUUxTSxTQUFTWSxNQUFNLEVBQUU7Z0JBRzFILE1BQU0sSUFBSVEsTUFBTU47WUFDbEI7WUFFQSxPQUFPZCxTQUFTeUIsSUFBSTtRQUN0QjtJQUNGO0lBRUEseURBQXlEO0lBQ3pEa0wsY0FBYztRQUNaOztLQUVDLEdBQ0QsTUFBTWxLLFFBQ0o0SCxTQUEwQixFQUMxQmxNLE1BQXVCLEVBQ3ZCeU8sZUFBaUMsRUFDakNDLGVBQXVCLEVBQ3ZCQyxLQUFjLEVBQ2RsSCxXQUFvQixFQUNwQmxELE1BQWU7WUFFZixJQUFJdkYsY0FBYztnQkFDaEIsT0FBTztvQkFBRXlELFFBQVE7b0JBQVdMLFNBQVM7Z0JBQW1DO1lBQzFFO1lBRUEscURBQXFEO1lBQ3JELE1BQU1zQixXQUFXLElBQUlnQjtZQUNyQmhCLFNBQVNxQixNQUFNLENBQUMsYUFBYWxFLE9BQU9xTDtZQUNwQ3hJLFNBQVNxQixNQUFNLENBQUMsVUFBVWxFLE9BQU9iO1lBQ2pDMEQsU0FBU3FCLE1BQU0sQ0FBQyxtQkFBbUIwSjtZQUNuQy9LLFNBQVNxQixNQUFNLENBQUMsbUJBQW1CMko7WUFDbkMsSUFBSUMsT0FBT2pMLFNBQVNxQixNQUFNLENBQUMsU0FBUzRKO1lBQ3BDLElBQUlsSCxhQUFhL0QsU0FBU3FCLE1BQU0sQ0FBQyxlQUFlMEM7WUFDaEQsSUFBSWxELFVBQVVBLE9BQU85RSxNQUFNLEdBQUcsR0FBRztnQkFDL0I4RSxPQUFPUyxPQUFPLENBQUMsQ0FBQzRKO29CQUNkbEwsU0FBU3FCLE1BQU0sQ0FBQyxTQUFTNko7Z0JBQzNCO1lBQ0Y7WUFFQSxNQUFNaE4sTUFBTSxHQUFHcEQseUJBQXlCLHdCQUF3QixDQUFDO1lBQ2pFLE1BQU1xRCxXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsR0FBR1QsZ0JBQWdCO2dCQUNyQjtnQkFDQXVELE1BQU1GO1lBQ1I7WUFFQSxJQUFJLENBQUM3QixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsOEJBQThCLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtZQUN6RjtZQUVBLE9BQU9aLFNBQVN5QixJQUFJO1FBQ3RCO1FBRUE7O0tBRUMsR0FDRCxNQUFNdUwsaUJBQWdCN08sTUFBdUI7WUFDM0MsSUFBSWhCLGNBQWM7Z0JBQ2hCLE9BQU8sRUFBRTtZQUNYO1lBRUEsTUFBTTRDLE1BQU0sR0FBR3BELHlCQUF5Qix1Q0FBdUMsRUFBRXdCLFFBQVE7WUFDekYsTUFBTTZCLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztnQkFDaEMrQixRQUFRO2dCQUNSN0MsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLEdBQUdULGdCQUFnQjtnQkFDckI7WUFDRjtZQUVBLElBQUksQ0FBQ3dCLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlaLE1BQU1qQixVQUFVSSxPQUFPLElBQUksQ0FBQyw0QkFBNEIsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO1lBQ3ZGO1lBRUEsT0FBT1osU0FBU3lCLElBQUk7UUFDdEI7UUFFQTs7S0FFQyxHQUNELE1BQU13TCx3QkFBdUI5TyxNQUF1QjtZQUNsRCxJQUFJaEIsY0FBYztnQkFDaEIsT0FBTyxFQUFFO1lBQ1g7WUFFQSxNQUFNNEMsTUFBTSxHQUFHcEQseUJBQXlCLG9DQUFvQyxFQUFFd0IsUUFBUTtZQUN0RixNQUFNNkIsV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsR0FBR1QsZ0JBQWdCO2dCQUNyQjtZQUNGO1lBRUEsSUFBSSxDQUFDd0IsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSSxDQUFDLDRCQUE0QixFQUFFUCxTQUFTWSxNQUFNLEVBQUU7WUFDdkY7WUFFQSxPQUFPWixTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTXlMLG1CQUFrQkMsYUFBcUIsRUFBRUMsS0FBYTtZQUMxRCxJQUFJalEsY0FBYztnQkFDaEIsT0FBTztvQkFBRXlELFFBQVE7Z0JBQVU7WUFDN0I7WUFFQSxNQUFNaUIsV0FBVyxJQUFJZ0I7WUFDckJ1SyxNQUFNakssT0FBTyxDQUFDLENBQUNDO2dCQUNidkIsU0FBU3FCLE1BQU0sQ0FBQyxTQUFTRTtZQUMzQjtZQUVBLE1BQU1yRCxNQUFNLEdBQUdwRCx5QkFBeUIsa0JBQWtCLEVBQUV3USxjQUFjLFlBQVksQ0FBQztZQUN2RixNQUFNbk4sV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLEdBQUdULGdCQUFnQjtnQkFDckI7Z0JBQ0F1RCxNQUFNRjtZQUNSO1lBRUEsSUFBSSxDQUFDN0IsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSSxDQUFDLDhCQUE4QixFQUFFUCxTQUFTWSxNQUFNLEVBQUU7WUFDekY7WUFFQSxPQUFPWixTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTTRMLDhCQUNKaEQsU0FBMEIsRUFDMUJpRCxhQUE4QjtZQUU5QixJQUFJblEsY0FBYztnQkFDaEIsT0FBTztZQUNUO1lBRUEsTUFBTTRDLE1BQU0sR0FBR3BELHlCQUF5QiwwQkFBMEIsRUFBRTBOLFVBQVUsYUFBYSxFQUFFaUQsZUFBZTtZQUU1RyxJQUFJO2dCQUNGLE1BQU10TixXQUFXLE1BQU1DLE1BQU1GLEtBQUs7b0JBQ2hDK0IsUUFBUTtvQkFDUjdDLFNBQVM7d0JBQ1AsZ0JBQWdCO3dCQUNoQixHQUFHVCxnQkFBZ0I7b0JBQ3JCO2dCQUNGO2dCQUVBLG9FQUFvRTtnQkFDcEUsSUFBSXdCLFNBQVNZLE1BQU0sS0FBSyxLQUFLO29CQUMzQixPQUFPO2dCQUNUO2dCQUVBLElBQUksQ0FBQ1osU0FBU0UsRUFBRSxFQUFFO29CQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7b0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSSxDQUFDLDZCQUE2QixFQUFFUCxTQUFTWSxNQUFNLEVBQUU7Z0JBQ3hGO2dCQUVBLE9BQU9aLFNBQVN5QixJQUFJO1lBQ3RCLEVBQUUsT0FBT2xELE9BQVk7Z0JBQ25CLHNFQUFzRTtnQkFDdEUsSUFBSUEsTUFBTWdDLE9BQU8sRUFBRWdCLFNBQVMsVUFBVWhELE1BQU1nQyxPQUFPLEVBQUVnQixTQUFTLGNBQWM7b0JBQzFFLE9BQU87Z0JBQ1Q7Z0JBQ0EsTUFBTWhEO1lBQ1I7UUFDRjtRQUVBOztLQUVDLEdBQ0QsTUFBTWdFLFNBQVE0SyxhQUFxQjtZQUNqQyxJQUFJaFEsY0FBYztnQkFDaEIsT0FBTztZQUNUO1lBRUEsTUFBTTRDLE1BQU0sR0FBR3BELHlCQUF5QixrQkFBa0IsRUFBRXdRLGVBQWU7WUFDM0UsTUFBTW5OLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztnQkFDaEMrQixRQUFRO2dCQUNSN0MsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLEdBQUdULGdCQUFnQjtnQkFDckI7WUFDRjtZQUVBLElBQUl3QixTQUFTWSxNQUFNLEtBQUssS0FBSztnQkFDM0IsT0FBTztZQUNUO1lBRUEsSUFBSSxDQUFDWixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsNkJBQTZCLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtZQUN4RjtZQUVBLE9BQU9aLFNBQVN5QixJQUFJO1FBQ3RCO1FBRUE7O0tBRUMsR0FDRCxNQUFNOEwsZ0JBQWVKLGFBQXFCO1lBQ3hDLElBQUloUSxjQUFjO2dCQUNoQixPQUFPLEVBQUU7WUFDWDtZQUVBLE1BQU00QyxNQUFNLEdBQUdwRCx5QkFBeUIsa0JBQWtCLEVBQUV3USxjQUFjLFlBQVksQ0FBQztZQUN2RixNQUFNbk4sV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsR0FBR1QsZ0JBQWdCO2dCQUNyQjtZQUNGO1lBRUEsSUFBSSxDQUFDd0IsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSSxDQUFDLDZCQUE2QixFQUFFUCxTQUFTWSxNQUFNLEVBQUU7WUFDeEY7WUFFQSxPQUFPWixTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTStCLFFBQU8ySixhQUE4QixFQUFFaFAsTUFBdUI7WUFDbEUsSUFBSWhCLGNBQWM7Z0JBQ2hCO1lBQ0Y7WUFFQSxNQUFNNEMsTUFBTSxHQUFHcEQseUJBQXlCLGtCQUFrQixFQUFFd1EsY0FBYyxRQUFRLEVBQUVoUCxRQUFRO1lBQzVGLE1BQU02QixXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixHQUFHVCxnQkFBZ0I7Z0JBQ3JCO1lBQ0Y7WUFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsOEJBQThCLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtZQUN6RjtRQUNGO1FBRUE7O0tBRUMsR0FDRCxNQUFNeUMsUUFDSjhKLGFBQThCLEVBQzlCaFAsTUFBdUIsRUFDdkIyTyxLQUFjLEVBQ2RsSCxXQUFvQixFQUNwQmxELE1BQWU7WUFFZixJQUFJdkYsY0FBYztnQkFDaEIsT0FBTztvQkFBRXlELFFBQVE7b0JBQVdMLFNBQVM7Z0JBQW1DO1lBQzFFO1lBRUEsTUFBTXNCLFdBQVcsSUFBSWdCO1lBQ3JCaEIsU0FBU3FCLE1BQU0sQ0FBQyxVQUFVbEUsT0FBT2I7WUFDakMsSUFBSTJPLE9BQU9qTCxTQUFTcUIsTUFBTSxDQUFDLFNBQVM0SjtZQUNwQyxJQUFJbEgsYUFBYS9ELFNBQVNxQixNQUFNLENBQUMsZUFBZTBDO1lBQ2hELElBQUlsRCxVQUFVQSxPQUFPOUUsTUFBTSxHQUFHLEdBQUc7Z0JBQy9COEUsT0FBT1MsT0FBTyxDQUFDLENBQUM0SjtvQkFDZGxMLFNBQVNxQixNQUFNLENBQUMsU0FBUzZKO2dCQUMzQjtZQUNGO1lBRUEsTUFBTWhOLE1BQU0sR0FBR3BELHlCQUF5QixrQkFBa0IsRUFBRXdRLGVBQWU7WUFDM0UsTUFBTW5OLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztnQkFDaEMrQixRQUFRO2dCQUNSN0MsU0FBUztvQkFDUCxHQUFHVCxnQkFBZ0I7Z0JBQ3JCO2dCQUNBdUQsTUFBTUY7WUFDUjtZQUVBLElBQUksQ0FBQzdCLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlaLE1BQU1qQixVQUFVSSxPQUFPLElBQUksQ0FBQyw4QkFBOEIsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO1lBQ3pGO1lBRUEsT0FBT1osU0FBU3lCLElBQUk7UUFDdEI7UUFFQTs7S0FFQyxHQUNELE1BQU0rTCxvQkFBbUJyUCxNQUF1QjtZQUM5QyxJQUFJaEIsY0FBYztnQkFDaEIsT0FBTztZQUNUO1lBRUEsTUFBTTRDLE1BQU0sR0FBR3BELHlCQUF5Qix1QkFBdUIsRUFBRXdCLE9BQU8sTUFBTSxDQUFDO1lBQy9FLE1BQU02QixXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixHQUFHVCxnQkFBZ0I7Z0JBQ3JCO1lBQ0Y7WUFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsOEJBQThCLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtZQUN6RjtZQUVBLE1BQU1ZLE9BQU8sTUFBTXhCLFNBQVN5QixJQUFJO1lBQ2hDLE9BQU9ELEtBQUs0RSxXQUFXLElBQUk7UUFDN0I7SUFDRjtJQUVBLCtEQUErRDtJQUMvRHFILG1CQUFtQjtRQUNqQjs7S0FFQyxHQUNELE1BQU10TDtZQUNKLElBQUloRixjQUFjO2dCQUNoQixPQUFPLEVBQUU7WUFDWDtZQUVBLE1BQU00QyxNQUFNLEdBQUdwRCx5QkFBeUIsdUJBQXVCLENBQUM7WUFDaEUsTUFBTXFELFdBQVcsTUFBTUMsTUFBTUYsS0FBSztnQkFDaEMrQixRQUFRO2dCQUNSN0MsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLEdBQUdULGdCQUFnQjtnQkFDckI7WUFDRjtZQUVBLElBQUksQ0FBQ3dCLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlaLE1BQU1qQixVQUFVSSxPQUFPLElBQUksQ0FBQyw4QkFBOEIsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO1lBQ3pGO1lBRUEsT0FBT1osU0FBU3lCLElBQUk7UUFDdEI7UUFFQTs7S0FFQyxHQUNELE1BQU1rRSxhQUFZL0UsTUFBc0Q7WUFDdEUsSUFBSXpELGNBQWM7Z0JBQ2hCLE9BQU8sRUFBRTtZQUNYO1lBRUEsTUFBTTRDLE1BQU0sR0FBR3BELHlCQUF5QiwrQkFBK0IsRUFBRWlFLFFBQVE7WUFDakYsTUFBTVosV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsR0FBR1QsZ0JBQWdCO2dCQUNyQjtZQUNGO1lBRUEsSUFBSSxDQUFDd0IsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSSxDQUFDLDhCQUE4QixFQUFFUCxTQUFTWSxNQUFNLEVBQUU7WUFDekY7WUFFQSxPQUFPWixTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTWMsU0FBUTRLLGFBQXFCO1lBQ2pDLElBQUloUSxjQUFjO2dCQUNoQixPQUFPO1lBQ1Q7WUFFQSxNQUFNNEMsTUFBTSxHQUFHcEQseUJBQXlCLGtCQUFrQixFQUFFd1EsZUFBZTtZQUMzRSxNQUFNbk4sV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsR0FBR1QsZ0JBQWdCO2dCQUNyQjtZQUNGO1lBRUEsSUFBSXdCLFNBQVNZLE1BQU0sS0FBSyxLQUFLO2dCQUMzQixPQUFPO1lBQ1Q7WUFFQSxJQUFJLENBQUNaLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlaLE1BQU1qQixVQUFVSSxPQUFPLElBQUksQ0FBQyw2QkFBNkIsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO1lBQ3hGO1lBRUEsT0FBT1osU0FBU3lCLElBQUk7UUFDdEI7UUFFQTs7S0FFQyxHQUNELE1BQU1pTSxnQkFBZVAsYUFBcUIsRUFBRVEsUUFBZ0Q7WUFDMUYsSUFBSXhRLGNBQWM7Z0JBQ2hCLE9BQU87b0JBQUV5RCxRQUFRO2dCQUFVO1lBQzdCO1lBRUEsTUFBTWIsTUFBTSxHQUFHcEQseUJBQXlCLHdCQUF3QixFQUFFd1EsY0FBYyxtQkFBbUIsRUFBRVEsVUFBVTtZQUMvRyxNQUFNM04sV0FBVyxNQUFNQyxNQUFNRixLQUFLO2dCQUNoQytCLFFBQVE7Z0JBQ1I3QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsR0FBR1QsZ0JBQWdCO2dCQUNyQjtZQUNGO1lBRUEsSUFBSSxDQUFDd0IsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1ILFNBQVN5QixJQUFJLEdBQUdPLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSVosTUFBTWpCLFVBQVVJLE9BQU8sSUFBSSxDQUFDLDJCQUEyQixFQUFFUCxTQUFTWSxNQUFNLEVBQUU7WUFDdEY7WUFFQSxPQUFPWixTQUFTeUIsSUFBSTtRQUN0QjtRQUVBOztLQUVDLEdBQ0QsTUFBTW1NLFFBQU9ULGFBQXFCO1lBQ2hDLElBQUloUSxjQUFjO2dCQUNoQixPQUFPO29CQUFFeUQsUUFBUTtnQkFBVTtZQUM3QjtZQUVBLE1BQU1iLE1BQU0sR0FBR3BELHlCQUF5Qix3QkFBd0IsRUFBRXdRLGNBQWMsT0FBTyxDQUFDO1lBQ3hGLE1BQU1uTixXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixHQUFHVCxnQkFBZ0I7Z0JBQ3JCO1lBQ0Y7WUFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsOEJBQThCLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtZQUN6RjtZQUVBLE9BQU9aLFNBQVN5QixJQUFJO1FBQ3RCO1FBRUE7O0tBRUMsR0FDRCxNQUFNdUYsU0FBUW1HLGFBQXFCLEVBQUVVLGVBQXVCLEVBQUVDLFFBQWlCO1lBQzdFLElBQUkzUSxjQUFjO2dCQUNoQixPQUFPO29CQUFFeUQsUUFBUTtnQkFBVTtZQUM3QjtZQUVBLE1BQU1iLE1BQU0sR0FBR3BELHlCQUF5Qix3QkFBd0IsRUFBRXdRLGNBQWMsUUFBUSxDQUFDO1lBQ3pGLE1BQU1uTixXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixHQUFHVCxnQkFBZ0I7Z0JBQ3JCO2dCQUNBdUQsTUFBTWhFLEtBQUtpRixTQUFTLENBQUM7b0JBQ25CNks7b0JBQ0FDO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJLENBQUM5TixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsK0JBQStCLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtZQUMxRjtZQUVBLE9BQU9aLFNBQVN5QixJQUFJO1FBQ3RCO1FBRUE7O0tBRUMsR0FDRCxNQUFNb0UsUUFBT3NILGFBQXFCLEVBQUVZLGNBQXNCO1lBQ3hELElBQUk1USxjQUFjO2dCQUNoQixPQUFPO29CQUFFeUQsUUFBUTtnQkFBVTtZQUM3QjtZQUVBLE1BQU1iLE1BQU0sR0FBR3BELHlCQUF5Qix3QkFBd0IsRUFBRXdRLGNBQWMsT0FBTyxDQUFDO1lBQ3hGLE1BQU1uTixXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixHQUFHVCxnQkFBZ0I7Z0JBQ3JCO2dCQUNBdUQsTUFBTWhFLEtBQUtpRixTQUFTLENBQUM7b0JBQ25CK0s7Z0JBQ0Y7WUFDRjtZQUVBLElBQUksQ0FBQy9OLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlaLE1BQU1qQixVQUFVSSxPQUFPLElBQUksQ0FBQyw4QkFBOEIsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO1lBQ3pGO1lBRUEsT0FBT1osU0FBU3lCLElBQUk7UUFDdEI7UUFFQTs7S0FFQyxHQUNELE1BQU04TCxnQkFBZUosYUFBcUI7WUFDeEMsSUFBSWhRLGNBQWM7Z0JBQ2hCLE9BQU8sRUFBRTtZQUNYO1lBRUEsTUFBTTRDLE1BQU0sR0FBR3BELHlCQUF5Qix3QkFBd0IsRUFBRXdRLGNBQWMsWUFBWSxDQUFDO1lBQzdGLE1BQU1uTixXQUFXLE1BQU1DLE1BQU1GLEtBQUs7Z0JBQ2hDK0IsUUFBUTtnQkFDUjdDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixHQUFHVCxnQkFBZ0I7Z0JBQ3JCO1lBQ0Y7WUFFQSxJQUFJLENBQUN3QixTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTUgsU0FBU3lCLElBQUksR0FBR08sS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJWixNQUFNakIsVUFBVUksT0FBTyxJQUFJLENBQUMsNkJBQTZCLEVBQUVQLFNBQVNZLE1BQU0sRUFBRTtZQUN4RjtZQUVBLE9BQU9aLFNBQVN5QixJQUFJO1FBQ3RCO1FBRUE7O0tBRUMsR0FDRCxNQUFNdU07WUFDSixJQUFJN1EsY0FBYztnQkFDaEIsT0FBTztvQkFDTDhRLE9BQU87b0JBQ1BDLE1BQU07b0JBQ05DLFVBQVU7b0JBQ1ZDLFVBQVU7b0JBQ1ZDLFVBQVU7Z0JBQ1o7WUFDRjtZQUVBLE1BQU10TyxNQUFNLEdBQUdwRCx5QkFBeUIsa0NBQWtDLENBQUM7WUFDM0UsTUFBTXFELFdBQVcsTUFBTUMsTUFBTUYsS0FBSztnQkFDaEMrQixRQUFRO2dCQUNSN0MsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLEdBQUdULGdCQUFnQjtnQkFDckI7WUFDRjtZQUVBLElBQUksQ0FBQ3dCLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNSCxTQUFTeUIsSUFBSSxHQUFHTyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlaLE1BQU1qQixVQUFVSSxPQUFPLElBQUksQ0FBQyw0QkFBNEIsRUFBRVAsU0FBU1ksTUFBTSxFQUFFO1lBQ3ZGO1lBRUEsT0FBT1osU0FBU3lCLElBQUk7UUFDdEI7SUFDRjtJQUVBLDREQUE0RDtJQUM1RDZELGlCQUFpQjtRQUNmLE1BQU1DLGNBQWFILFFBQWdCLEVBQUVJLGFBQXFCLENBQUM7WUFDekQsSUFBSXJJLGNBQWMsT0FBTyxFQUFFO1lBQzNCLE1BQU02QyxXQUFXLE1BQU1DLE1BQU0sQ0FBQyw0QkFBNEIsRUFBRW1GLFNBQVMsYUFBYSxFQUFFSSxZQUFZO1lBQ2hHLElBQUksQ0FBQ3hGLFNBQVNFLEVBQUUsRUFBRSxNQUFNLElBQUlrQixNQUFNO1lBQ2xDLE9BQU9wQixTQUFTeUIsSUFBSTtRQUN0QjtRQUNBLE1BQU1nRSxZQUFXN0MsVUFBa0IsRUFBRTRDLGFBQXFCLENBQUM7WUFDekQsSUFBSXJJLGNBQWMsT0FBTyxFQUFFO1lBQzNCLE1BQU02QyxXQUFXLE1BQU1DLE1BQU0sQ0FBQyw2QkFBNkIsRUFBRTJDLFdBQVcsYUFBYSxFQUFFNEMsWUFBWTtZQUNuRyxJQUFJLENBQUN4RixTQUFTRSxFQUFFLEVBQUUsTUFBTSxJQUFJa0IsTUFBTTtZQUNsQyxPQUFPcEIsU0FBU3lCLElBQUk7UUFDdEI7SUFDRjtJQUVBLDBEQUEwRDtJQUMxRDZNLGNBQWM7UUFDWixNQUFNQyxjQUFhQyxlQUF1QixFQUFFO1lBQzFDLElBQUlyUixjQUFjLE9BQU87Z0JBQUVzUixRQUFRLEVBQUU7Z0JBQUVDLFVBQVUsRUFBRTtZQUFDO1lBQ3BELE1BQU0xTyxXQUFXLE1BQU1DLE1BQU0sQ0FBQyw0Q0FBNEMsRUFBRXVPLGNBQWM7WUFDMUYsSUFBSSxDQUFDeE8sU0FBU0UsRUFBRSxFQUFFLE1BQU0sSUFBSWtCLE1BQU07WUFDbEMsT0FBT3BCLFNBQVN5QixJQUFJO1FBQ3RCO1FBQ0EsTUFBTWtOLGVBQWNsSyxJQUFZLEVBQUUrSixlQUF1QixFQUFFO1lBQ3pELElBQUlyUixjQUFjLE9BQU87Z0JBQUV5UixhQUFhLEVBQUU7WUFBQztZQUMzQyxNQUFNNU8sV0FBVyxNQUFNQyxNQUFNLENBQUMsd0JBQXdCLEVBQUV3RSxLQUFLLGVBQWUsRUFBRStKLGNBQWM7WUFDNUYsSUFBSSxDQUFDeE8sU0FBU0UsRUFBRSxFQUFFLE1BQU0sSUFBSWtCLE1BQU0sQ0FBQywyQkFBMkIsRUFBRXFELE1BQU07WUFDdEUsT0FBT3pFLFNBQVN5QixJQUFJO1FBQ3RCO1FBQ0EsTUFBTW9OLGFBQVlwSyxJQUFZO1lBQzVCLElBQUl0SCxjQUFjLE9BQU8sRUFBRTtZQUMzQixNQUFNNkMsV0FBVyxNQUFNQyxNQUFNLENBQUMsNEJBQTRCLEVBQUV3RSxNQUFNO1lBQ2xFLElBQUksQ0FBQ3pFLFNBQVNFLEVBQUUsRUFBRSxNQUFNLElBQUlrQixNQUFNLENBQUMsNkJBQTZCLEVBQUVxRCxNQUFNO1lBQ3hFLE9BQU96RSxTQUFTeUIsSUFBSTtRQUN0QjtJQUNGO0FBQ0YsRUFBQztBQUVNLE1BQU1xTixhQUFhM1MsYUFBWTtBQUMvQixNQUFNNFMsYUFBYWxTLFlBQVciLCJzb3VyY2VzIjpbIi9ob21lL21lZGdtL3ZzYy9Qcm9qZXQgSkVFL2RlcmVudC1tYWluL2xpYi9zZXJ2aWNlcy9hcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBUEkgU2VydmljZSBMYXllclxuICpcbiAqIENlbnRyYWxpemVkIEFQSSBjb21tdW5pY2F0aW9uIHNlcnZpY2UgdGhhdCBoYW5kbGVzOlxuICogLSBCYXNlIFVSTCBjb25maWd1cmF0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKiAtIEF1dGhlbnRpY2F0aW9uIGhlYWRlcnMgKFgtVXNlci1JZCwgWC1Vc2VyLVJvbGVzKVxuICogLSBSZXF1ZXN0L3Jlc3BvbnNlIGludGVyY2VwdG9yc1xuICogLSBFcnJvciBoYW5kbGluZ1xuICpcbiAqIFVzYWdlOlxuICogaW1wb3J0IHsgYXBpQ2xpZW50IH0gZnJvbSAnQC9saWIvc2VydmljZXMvYXBpJ1xuICogY29uc3QgcHJvcGVydGllcyA9IGF3YWl0IGFwaUNsaWVudC5wcm9wZXJ0aWVzLmdldEFsbCgpXG4gKlxuICogRW52aXJvbm1lbnQgVmFyaWFibGVzIChpbiAuZW52LmxvY2FsKTpcbiAqIC0gTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMOiBCYWNrZW5kIEFQSSBiYXNlIFVSTCAoZS5nLiwgaHR0cDovL2xvY2FsaG9zdDo4MDgwKVxuICogLSBORVhUX1BVQkxJQ19BUElfVkVSU0lPTjogQVBJIHZlcnNpb24gcGF0aCAoZGVmYXVsdDogdjEpXG4gKi9cblxuaW1wb3J0IHR5cGUge1xuICBQcm9wZXJ0eSxcbiAgQ3JlYXRlUHJvcGVydHlSZXF1ZXN0LFxuICBVcGRhdGVQcm9wZXJ0eVJlcXVlc3QsXG4gIEFwcHJvdmVQcm9wZXJ0eVJlcXVlc3QsXG4gIFByb3BlcnR5VHlwZSxcbiAgVXNlcixcbiAgVmVyaWZpY2F0aW9uUmVxdWVzdCxcbiAgVGVuYW50Umlza1Jlc3BvbnNlLFxufSBmcm9tIFwiQC9saWIvdHlwZXNcIlxuXG4vLyBDb25maWd1cmF0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4vLyBVc2UgQVBJIEdhdGV3YXkgKHBvcnQgODA5MCkgYXMgdGhlIHNpbmdsZSBlbnRyeSBwb2ludCBmb3IgYWxsIHNlcnZpY2VzXG4vLyBJZiBHQVRFV0FZX1VSTCBpcyBub3Qgc2V0LCBmYWxsIGJhY2sgdG8gaW5kaXZpZHVhbCBzZXJ2aWNlIFVSTHMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmNvbnN0IEdBVEVXQVlfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR0FURVdBWV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjgwOTBcIlxuY29uc3QgVVNFX0dBVEVXQVkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19VU0VfR0FURVdBWSAhPT0gXCJmYWxzZVwiIC8vIERlZmF1bHQgdG8gdHJ1ZVxuXG4vLyBGYWxsYmFjayBVUkxzIGZvciBpbmRpdmlkdWFsIHNlcnZpY2VzICh1c2VkIGlmIFVTRV9HQVRFV0FZIGlzIGZhbHNlKVxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo4MDgyXCJcbmNvbnN0IFBST1BFUlRZX0FQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1BST1BFUlRZX0FQSV9CQVNFX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6ODA4MVwiXG5jb25zdCBCT09LSU5HX0FQSV9CQVNFX1VSTCA9IFVTRV9HQVRFV0FZXG4gID8gR0FURVdBWV9VUkxcbiAgOiAocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQk9PS0lOR19BUElfQkFTRV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjgwODNcIilcbmNvbnN0IFBBWU1FTlRfQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfUEFZTUVOVF9BUElfQkFTRV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjgwODVcIlxuY29uc3QgUkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfUkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo4MDkxXCJcbmNvbnN0IEFQSV9WRVJTSU9OID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1ZFUlNJT04gfHwgXCJ2MVwiXG5jb25zdCBBVVRIX1RPS0VOX0tFWSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FVVEhfU1RPUkFHRV9LRVkgfHwgXCJkZXJlbnQ1X2F1dGhfdG9rZW5cIlxuY29uc3QgVVNFUl9EQVRBX0tFWSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1VTRVJfU1RPUkFHRV9LRVkgfHwgXCJkZXJlbnQ1X3VzZXJfZGF0YVwiXG4vLyBVU0VfTU9DS19BUEkgaXMgdHJ1ZSBpZiBleHBsaWNpdGx5IHNldCB0byBcInRydWVcIiwgb3RoZXJ3aXNlIGZhbHNlICh1c2UgcmVhbCBBUEkpXG5jb25zdCBVU0VfTU9DS19BUEkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19VU0VfTU9DS19BUEkgPT09IFwidHJ1ZVwiXG5cbi8vIE9ubHkgaW1wb3J0IG1vY2sgQVBJIGlmIG5lZWRlZCAodHJlZS1zaGFrZSB3aGVuIG5vdCB1c2VkKVxubGV0IG1vY2tBcGlDbGllbnQ6IHR5cGVvZiBpbXBvcnQoXCJAL2xpYi9tb2NrLWFwaVwiKS5tb2NrQXBpIHwgbnVsbCA9IG51bGxcblxuYXN5bmMgZnVuY3Rpb24gZ2V0TW9ja0FwaSgpIHtcbiAgaWYgKCFtb2NrQXBpQ2xpZW50KSB7XG4gICAgY29uc3QgeyBtb2NrQXBpIH0gPSBhd2FpdCBpbXBvcnQoXCJAL2xpYi9tb2NrLWFwaVwiKVxuICAgIG1vY2tBcGlDbGllbnQgPSBtb2NrQXBpXG4gIH1cbiAgcmV0dXJuIG1vY2tBcGlDbGllbnRcbn1cblxuLyoqXG4gKiBEZWNvZGUgSldUIHRva2VuIHRvIGV4dHJhY3QgdXNlcklkIGZyb20gc3ViamVjdFxuICovXG5mdW5jdGlvbiBkZWNvZGVKV1QodG9rZW46IHN0cmluZyk6IHsgdXNlcklkPzogc3RyaW5nOyByb2xlcz86IHN0cmluZ1tdIH0gfCBudWxsIHtcbiAgdHJ5IHtcbiAgICAvLyBKV1QgZm9ybWF0OiBoZWFkZXIucGF5bG9hZC5zaWduYXR1cmVcbiAgICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KFwiLlwiKVxuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsXG5cbiAgICAvLyBEZWNvZGUgcGF5bG9hZCAoYmFzZTY0dXJsKVxuICAgIGNvbnN0IHBheWxvYWQgPSBwYXJ0c1sxXVxuICAgIGNvbnN0IGRlY29kZWQgPSBKU09OLnBhcnNlKGF0b2IocGF5bG9hZC5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKSkpXG5cbiAgICByZXR1cm4ge1xuICAgICAgdXNlcklkOiBkZWNvZGVkLnN1YiB8fCBkZWNvZGVkLnN1YmplY3QsIC8vIEpXVCBzdWJqZWN0IGNvbnRhaW5zIHVzZXJJZFxuICAgICAgcm9sZXM6IGRlY29kZWQucm9sZXMgfHwgW10sXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYXV0aGVudGljYXRpb24gaGVhZGVycyBmcm9tIGxvY2FsU3RvcmFnZVxuICogVXNlZCBmb3IgYWxsIEFQSSByZXF1ZXN0cyB0aGF0IHJlcXVpcmUgdXNlciBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGdldEF1dGhIZWFkZXJzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAvLyBPbmx5IHJ1biBpbiBicm93c2VyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cblxuICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKEFVVEhfVE9LRU5fS0VZKVxuICBpZiAoIXRva2VuKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cblxuICAvLyBUcnkgdG8gZ2V0IHVzZXJJZCBmcm9tIEpXVCB0b2tlbiBmaXJzdFxuICBjb25zdCBkZWNvZGVkID0gZGVjb2RlSldUKHRva2VuKVxuICBjb25zdCB1c2VySWQgPSBkZWNvZGVkPy51c2VySWRcblxuICAvLyBGYWxsYmFjayB0byB1c2VyIGRhdGEgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgY29uc3QgdXNlckRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShVU0VSX0RBVEFfS0VZKVxuICBsZXQgZmluYWxVc2VySWQgPSB1c2VySWRcbiAgbGV0IHJvbGVzOiBzdHJpbmdbXSA9IGRlY29kZWQ/LnJvbGVzIHx8IFtdXG5cbiAgaWYgKHVzZXJEYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBKU09OLnBhcnNlKHVzZXJEYXRhKVxuICAgICAgZmluYWxVc2VySWQgPSBmaW5hbFVzZXJJZCB8fCB1c2VyLmlkIHx8IFwiXCJcbiAgICAgIHJvbGVzID0gcm9sZXMubGVuZ3RoID4gMCA/IHJvbGVzIDogKHVzZXIucm9sZXMgfHwgW10pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEZhaWxlZCB0byBwYXJzZSB1c2VyIGRhdGFcbiAgICB9XG4gIH1cblxuICAvLyBFbnN1cmUgdXNlcklkIGlzIGFsd2F5cyBhIHN0cmluZyAoY29udmVydCBudW1iZXIgdG8gc3RyaW5nIGlmIG5lZWRlZClcbiAgY29uc3QgdXNlcklkU3RyaW5nID0gZmluYWxVc2VySWQgPyBTdHJpbmcoZmluYWxVc2VySWQpIDogXCJcIlxuXG4gIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgXCJYLVVzZXItSWRcIjogdXNlcklkU3RyaW5nLFxuICAgIFwiWC1Vc2VyLVJvbGVzXCI6IHJvbGVzLmpvaW4oXCIsXCIpLFxuICAgIC4uLih0b2tlbiAmJiB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0pLFxuICB9XG5cbiAgcmV0dXJuIGhlYWRlcnNcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBjb3JyZWN0IGJhc2UgVVJMIGZvciBhIHNlcnZpY2VcbiAqIFVzZXMgR2F0ZXdheSBpZiBlbmFibGVkLCBvdGhlcndpc2UgZmFsbHMgYmFjayB0byBpbmRpdmlkdWFsIHNlcnZpY2UgVVJMc1xuICovXG5mdW5jdGlvbiBnZXRTZXJ2aWNlVXJsKHNlcnZpY2U6ICdhdXRoJyB8ICd1c2VycycgfCAncHJvcGVydGllcycgfCAnYm9va2luZ3MnIHwgJ3BheW1lbnRzJyB8ICdyZWNsYW1hdGlvbnMnIHwgJ2FkbWluLXJlY2xhbWF0aW9ucycpOiBzdHJpbmcge1xuICBpZiAoVVNFX0dBVEVXQVkpIHtcbiAgICAvLyBBbGwgc2VydmljZXMgZ28gdGhyb3VnaCB0aGUgR2F0ZXdheVxuICAgIHJldHVybiBHQVRFV0FZX1VSTFxuICB9XG5cbiAgLy8gRmFsbGJhY2sgdG8gaW5kaXZpZHVhbCBzZXJ2aWNlIFVSTHNcbiAgc3dpdGNoIChzZXJ2aWNlKSB7XG4gICAgY2FzZSAnYXV0aCc6XG4gICAgY2FzZSAndXNlcnMnOlxuICAgICAgcmV0dXJuIEFQSV9CQVNFX1VSTFxuICAgIGNhc2UgJ3Byb3BlcnRpZXMnOlxuICAgICAgcmV0dXJuIFBST1BFUlRZX0FQSV9CQVNFX1VSTFxuICAgIGNhc2UgJ2Jvb2tpbmdzJzpcbiAgICAgIHJldHVybiBCT09LSU5HX0FQSV9CQVNFX1VSTFxuICAgIGNhc2UgJ3BheW1lbnRzJzpcbiAgICAgIHJldHVybiBQQVlNRU5UX0FQSV9CQVNFX1VSTFxuICAgIGNhc2UgJ3JlY2xhbWF0aW9ucyc6XG4gICAgY2FzZSAnYWRtaW4tcmVjbGFtYXRpb25zJzpcbiAgICAgIHJldHVybiBSRUNMQU1BVElPTl9BUElfQkFTRV9VUkxcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEFQSV9CQVNFX1VSTFxuICB9XG59XG5cbi8qKlxuICogQnVpbGQgZnVsbCBVUkwgd2l0aCBiYXNlIGFuZCB2ZXJzaW9uXG4gKiBGb3IgR2F0ZXdheSwgcGF0aCBhbHJlYWR5IGluY2x1ZGVzIC9hcGkvdjEvLi4uLCBzbyB3ZSBkb24ndCBhZGQgaXQgYWdhaW5cbiAqL1xuZnVuY3Rpb24gYnVpbGRVcmwocGF0aDogc3RyaW5nLCBzZXJ2aWNlOiAnYXV0aCcgfCAndXNlcnMnIHwgJ3Byb3BlcnRpZXMnIHwgJ2Jvb2tpbmdzJyB8ICdwYXltZW50cycgfCAncmVjbGFtYXRpb25zJyB8ICdhZG1pbi1yZWNsYW1hdGlvbnMnID0gJ3VzZXJzJyk6IHN0cmluZyB7XG4gIGNvbnN0IGJhc2VVcmwgPSBnZXRTZXJ2aWNlVXJsKHNlcnZpY2UpXG5cbiAgaWYgKFVTRV9HQVRFV0FZKSB7XG4gICAgLy8gR2F0ZXdheSByb3V0ZXMgcHJlc2VydmUgdGhlIGZ1bGwgcGF0aFxuICAgIC8vIFBhdGggc2hvdWxkIGFscmVhZHkgaW5jbHVkZSAvYXBpL3YxLy4uLiBvciAvYXBpLy4uLiBwcmVmaXhcbiAgICAvLyBJZiBwYXRoIGRvZXNuJ3Qgc3RhcnQgd2l0aCAvYXBpLCBhZGQgdGhlIGFwcHJvcHJpYXRlIHByZWZpeCBiYXNlZCBvbiBzZXJ2aWNlXG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnL2FwaS8nKSkge1xuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9JHtwYXRofWBcbiAgICB9XG5cbiAgICAvLyBBZGQgYXBwcm9wcmlhdGUgcHJlZml4IGJhc2VkIG9uIHNlcnZpY2VcbiAgICBpZiAoc2VydmljZSA9PT0gJ2F1dGgnIHx8IHNlcnZpY2UgPT09ICd1c2VycycpIHtcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9hcGkvdjEke3BhdGh9YFxuICAgIH0gZWxzZSBpZiAoc2VydmljZSA9PT0gJ3Byb3BlcnRpZXMnKSB7XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vYXBpL3YxJHtwYXRofWBcbiAgICB9IGVsc2UgaWYgKHNlcnZpY2UgPT09ICdib29raW5ncycpIHtcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9hcGkke3BhdGh9YFxuICAgIH0gZWxzZSBpZiAoc2VydmljZSA9PT0gJ3BheW1lbnRzJykge1xuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L2FwaSR7cGF0aH1gXG4gICAgfSBlbHNlIGlmIChzZXJ2aWNlID09PSAncmVjbGFtYXRpb25zJyB8fCBzZXJ2aWNlID09PSAnYWRtaW4tcmVjbGFtYXRpb25zJykge1xuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L2FwaSR7cGF0aH1gXG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2Jhc2VVcmx9JHtwYXRofWBcbiAgfVxuXG4gIC8vIEZvciBkaXJlY3Qgc2VydmljZSBjYWxscywgYWRkIHZlcnNpb24gcHJlZml4XG4gIGNvbnN0IGJhc2VQYXRoID0gYC9hcGkvJHtBUElfVkVSU0lPTn1gXG4gIHJldHVybiBgJHtiYXNlVXJsfSR7YmFzZVBhdGh9JHtwYXRofWBcbn1cblxuLyoqXG4gKiBHZW5lcmljIGZldGNoIHdyYXBwZXIgd2l0aCBlcnJvciBoYW5kbGluZ1xuICovXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0PFQ+KFxuICBwYXRoOiBzdHJpbmcsXG4gIG9wdGlvbnM6IFJlcXVlc3RJbml0ICYgeyByZXF1aXJlc0F1dGg/OiBib29sZWFuOyBzZXJ2aWNlPzogJ2F1dGgnIHwgJ3VzZXJzJyB8ICdwcm9wZXJ0aWVzJyB8ICdib29raW5ncycgfCAncGF5bWVudHMnIHwgJ3JlY2xhbWF0aW9ucycgfCAnYWRtaW4tcmVjbGFtYXRpb25zJyB9ID0ge31cbik6IFByb21pc2U8VD4ge1xuICBjb25zdCB7IHJlcXVpcmVzQXV0aCA9IHRydWUsIHNlcnZpY2UgPSAndXNlcnMnLCAuLi5mZXRjaE9wdGlvbnMgfSA9IG9wdGlvbnNcblxuICBjb25zdCBoZWFkZXJzOiBIZWFkZXJzSW5pdCA9IHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAuLi4ocmVxdWlyZXNBdXRoICYmIGdldEF1dGhIZWFkZXJzKCkpLFxuICAgIC4uLmZldGNoT3B0aW9ucy5oZWFkZXJzLFxuICB9XG5cbiAgY29uc3QgdXJsID0gYnVpbGRVcmwocGF0aCwgc2VydmljZSlcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICBoZWFkZXJzLFxuICAgIH0pXG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsZXQgZXJyb3JEYXRhOiBhbnkgPSB7fVxuICAgICAgbGV0IHJlc3BvbnNlVGV4dCA9IFwiXCJcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICAgIGlmIChyZXNwb25zZVRleHQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXJyb3JEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpXG4gICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgSlNPTiBwYXJzaW5nIGZhaWxzLCB1c2UgdGhlIHJhdyB0ZXh0XG4gICAgICAgICAgICBlcnJvckRhdGEgPSB7IG1lc3NhZ2U6IHJlc3BvbnNlVGV4dCwgcmF3OiByZXNwb25zZVRleHQgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAodGV4dEVycm9yKSB7XG4gICAgICAgIGVycm9yRGF0YSA9IHsgbWVzc2FnZTogYEZhaWxlZCB0byByZWFkIHJlc3BvbnNlOiAke3RleHRFcnJvcn1gIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgZXJyb3JEYXRhIGlzIHN0aWxsIGVtcHR5LCBjcmVhdGUgYSBkZWZhdWx0IGVycm9yXG4gICAgICBpZiAoT2JqZWN0LmtleXMoZXJyb3JEYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZXJyb3JEYXRhID0ge1xuICAgICAgICAgIG1lc3NhZ2U6IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAsXG4gICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEV4dHJhY3QgZXJyb3IgbWVzc2FnZSBmcm9tIEVycm9yUmVzcG9uc2UgZm9ybWF0ICh1c2VkIGJ5IHVzZXItc2VydmljZSlcbiAgICAgIC8vIEVycm9yUmVzcG9uc2UgaGFzOiB0aW1lc3RhbXAsIHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIHBhdGhcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICAgIGVycm9yRGF0YS5tZXNzYWdlIHx8ICAgICAgICAgICAvLyBFcnJvclJlc3BvbnNlLm1lc3NhZ2VcbiAgICAgICAgZXJyb3JEYXRhLmVycm9yIHx8ICAgICAgICAgICAgIC8vIEVycm9yUmVzcG9uc2UuZXJyb3IgKGVycm9yIHRpdGxlKVxuICAgICAgICBlcnJvckRhdGEuZGV0YWlsIHx8ICAgICAgICAgICAgLy8gU3RhbmRhcmQgU3ByaW5nIGVycm9yIGZvcm1hdFxuICAgICAgICBlcnJvckRhdGEucmF3IHx8ICAgICAgICAgICAgICAgLy8gUmF3IHJlc3BvbnNlIHRleHQgaWYgSlNPTiBwYXJzaW5nIGZhaWxlZFxuICAgICAgICAoQXJyYXkuaXNBcnJheShlcnJvckRhdGEuZXJyb3JzKSA/IGVycm9yRGF0YS5lcnJvcnMuam9pbihcIiwgXCIpIDogbnVsbCkgfHwgLy8gVmFsaWRhdGlvbiBlcnJvcnMgYXJyYXlcbiAgICAgICAgKHR5cGVvZiBlcnJvckRhdGEgPT09ICdzdHJpbmcnID8gZXJyb3JEYXRhIDogbnVsbCkgfHxcbiAgICAgICAgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG5cbiAgICAgIGNvbnN0IGFwaUVycm9yID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZSlcbiAgICAgICAgOyAoYXBpRXJyb3IgYXMgYW55KS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgOyAoYXBpRXJyb3IgYXMgYW55KS5lcnJvckRhdGEgPSBlcnJvckRhdGFcbiAgICAgICAgOyAoYXBpRXJyb3IgYXMgYW55KS5yZXNwb25zZVRleHQgPSByZXNwb25zZVRleHRcbiAgICAgIHRocm93IGFwaUVycm9yXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcmVzcG9uc2UgaGFzIGNvbnRlbnRcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpXG4gICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgcmV0dXJuIGRhdGEgYXMgVFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyBKU09OIGNvbnRlbnQsIHJldHVybiBlbXB0eSBvYmplY3QgZm9yIHN1Y2Nlc3NmdWwgcmVzcG9uc2VzXG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICAvLyBUcnkgdG8gcGFyc2UgYXMgSlNPTiwgaWYgZmFpbHMgcmV0dXJuIHRleHQgYXMgbWVzc2FnZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpIGFzIFRcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogdGV4dCB9IGFzIFRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9IGFzIFRcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAvLyBDaGVjayBpZiBpdCdzIGEgY29ubmVjdGlvbiBlcnJvclxuICAgIGlmIChlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRVJSX0NPTk5FQ1RJT05fUkVGVVNFRFwiKSkge1xuICAgICAgY29uc3QgY29ubmVjdGlvbkVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gYmFja2VuZCBzZXJ2ZXIgYXQgJHtBUElfQkFTRV9VUkx9LiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBiYWNrZW5kIGlzIHJ1bm5pbmcuYFxuICAgICAgKVxuICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgIHRocm93IGNvbm5lY3Rpb25FcnJvclxuICAgIH1cblxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBNdWx0aXBhcnQgZm9ybSBkYXRhIHJlcXVlc3QgZm9yIGZpbGUgdXBsb2Fkc1xuICovXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0Rm9ybURhdGE8VD4oXG4gIHBhdGg6IHN0cmluZyxcbiAgZm9ybURhdGE6IEZvcm1EYXRhLFxuICBvcHRpb25zOiBPbWl0PFJlcXVlc3RJbml0LCBcImJvZHlcIj4gJiB7IHJlcXVpcmVzQXV0aD86IGJvb2xlYW47IHNlcnZpY2U/OiAnYXV0aCcgfCAndXNlcnMnIHwgJ3Byb3BlcnRpZXMnIHwgJ2Jvb2tpbmdzJyB8ICdwYXltZW50cycgfCAncmVjbGFtYXRpb25zJyB8ICdhZG1pbi1yZWNsYW1hdGlvbnMnIH0gPSB7fSxcbik6IFByb21pc2U8VD4ge1xuICBjb25zdCB7IHJlcXVpcmVzQXV0aCA9IHRydWUsIHNlcnZpY2UgPSAndXNlcnMnLCAuLi5mZXRjaE9wdGlvbnMgfSA9IG9wdGlvbnNcblxuICBjb25zdCBoZWFkZXJzOiBIZWFkZXJzSW5pdCA9IHtcbiAgICAuLi4ocmVxdWlyZXNBdXRoICYmIGdldEF1dGhIZWFkZXJzKCkpLFxuICAgIC4uLmZldGNoT3B0aW9ucy5oZWFkZXJzLFxuICB9XG5cbiAgLy8gRG9uJ3Qgc2V0IENvbnRlbnQtVHlwZSBmb3IgRm9ybURhdGEgLSBicm93c2VyIHdpbGwgc2V0IGl0IHdpdGggYm91bmRhcnlcbiAgZGVsZXRlIChoZWFkZXJzIGFzIGFueSlbXCJDb250ZW50LVR5cGVcIl1cblxuICBjb25zdCB1cmwgPSBidWlsZFVybChwYXRoLCBzZXJ2aWNlKVxuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgfSlcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIHJldHVybiBkYXRhXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vKipcbiAqIEFQSSBDbGllbnQgLSBPcmdhbml6ZWQgYnkgcmVzb3VyY2VcbiAqL1xuZXhwb3J0IGNvbnN0IGFwaUNsaWVudCA9IHtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gUFJPUEVSVElFUyA9PT09PT09PT09PT09PT09PT09PVxuICBwcm9wZXJ0aWVzOiB7XG4gICAgYXN5bmMgZ2V0QWxsKCk6IFByb21pc2U8UHJvcGVydHlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnRpZXMuZ2V0QWxsKClcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBwcm9wZXJ0eS1zZXJ2aWNlIFVSTCBmb3IgcHJvcGVydHkgZW5kcG9pbnRzXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzYFxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksIC8vIEluY2x1ZGUgYXV0aCBoZWFkZXJzIHRvIGNoZWNrIGlmIHVzZXIgaXMgQURNSU5cbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpKSB7XG4gICAgICAgICAgY29uc3QgY29ubmVjdGlvbkVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBjb25uZWN0IHRvIHByb3BlcnR5LXNlcnZpY2UgYmFja2VuZCBhdCAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0uIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXMgcnVubmluZy5gXG4gICAgICAgICAgKVxuICAgICAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICAgICAgdGhyb3cgY29ubmVjdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgZ2V0QWxsRm9yQWRtaW4oKTogUHJvbWlzZTxQcm9wZXJ0eVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5nZXRBbGwoKVxuICAgICAgfVxuICAgICAgLy8gVXNlIEdhdGV3YXkgb3IgcHJvcGVydHktc2VydmljZSBVUkwgZm9yIGFkbWluIGVuZHBvaW50XG4gICAgICBjb25zdCB1cmwgPSBidWlsZFVybChcIi9wcm9wZXJ0aWVzL2FkbWluL2FsbFwiLCAncHJvcGVydGllcycpXG4gICAgICBjb25zdCBhdXRoSGVhZGVycyA9IGdldEF1dGhIZWFkZXJzKClcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5hdXRoSGVhZGVycyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEuZXJyb3IgfHwgZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG5cbiAgICAgICAgLy8gRW5zdXJlIGRhdGEgaXMgYW4gYXJyYXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgLy8gSWYgaXQncyBhbiBlcnJvciBvYmplY3QsIHRocm93IGl0XG4gICAgICAgICAgaWYgKGRhdGEuZXJyb3IgfHwgZGF0YS5tZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCBkYXRhLm1lc3NhZ2UgfHwgXCJJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdFwiKVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIGVtcHR5IGFycmF5XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkVSUl9DT05ORUNUSU9OX1JFRlVTRURcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gcHJvcGVydHktc2VydmljZSBiYWNrZW5kIGF0ICR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgICAgICApXG4gICAgICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBnZXRCeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPFByb3BlcnR5PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5nZXRCeUlkKGlkKVxuICAgICAgfVxuICAgICAgLy8gVXNlIHByb3BlcnR5LXNlcnZpY2UgVVJMIGZvciBwcm9wZXJ0eSBlbmRwb2ludHNcbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXMvJHtpZH1gXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkVSUl9DT05ORUNUSU9OX1JFRlVTRURcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiQ09SU1wiKSkge1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25FcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgY29ubmVjdCB0byBwcm9wZXJ0eS1zZXJ2aWNlIGJhY2tlbmQgYXQgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9LiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBiYWNrZW5kIGlzIHJ1bm5pbmcuYFxuICAgICAgICAgIClcbiAgICAgICAgICAgIDsgKGNvbm5lY3Rpb25FcnJvciBhcyBhbnkpLmlzQ29ubmVjdGlvbkVycm9yID0gdHJ1ZVxuICAgICAgICAgIHRocm93IGNvbm5lY3Rpb25FcnJvclxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGdldE15UHJvcGVydGllcygpOiBQcm9taXNlPFByb3BlcnR5W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5wcm9wZXJ0aWVzLmdldEFsbCgpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXMvbXktcHJvcGVydGllc2BcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEuZXJyb3IgfHwgZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG5cbiAgICAgICAgLy8gRW5zdXJlIGRhdGEgaXMgYW4gYXJyYXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgLy8gSWYgaXQncyBhbiBlcnJvciBvYmplY3QsIHRocm93IGl0XG4gICAgICAgICAgaWYgKGRhdGEuZXJyb3IgfHwgZGF0YS5tZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCBkYXRhLm1lc3NhZ2UgfHwgXCJJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdFwiKVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIGVtcHR5IGFycmF5XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkVSUl9DT05ORUNUSU9OX1JFRlVTRURcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiQ09SU1wiKSkge1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25FcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgY29ubmVjdCB0byBwcm9wZXJ0eS1zZXJ2aWNlIGJhY2tlbmQgYXQgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9LiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBiYWNrZW5kIGlzIHJ1bm5pbmcuYFxuICAgICAgICAgIClcbiAgICAgICAgICAgIDsgKGNvbm5lY3Rpb25FcnJvciBhcyBhbnkpLmlzQ29ubmVjdGlvbkVycm9yID0gdHJ1ZVxuICAgICAgICAgIHRocm93IGNvbm5lY3Rpb25FcnJvclxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZShkYXRhOiBDcmVhdGVQcm9wZXJ0eVJlcXVlc3QsIGltYWdlczogRmlsZVtdKTogUHJvbWlzZTx7IHByb3BlcnR5SWQ6IHN0cmluZzsgaWQ/OiBzdHJpbmcgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1vY2sucHJvcGVydGllcy5jcmVhdGUoZGF0YSwgaW1hZ2VzKVxuICAgICAgICByZXR1cm4geyBwcm9wZXJ0eUlkOiByZXN1bHQuaWQsIGlkOiByZXN1bHQuaWQgfVxuICAgICAgfVxuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgICAgLy8gQ3JlYXRlIGEgQmxvYiB3aXRoIEpTT04gY29udGVudCB0eXBlIGZvciB0aGUgaW5wdXQgcGFydFxuICAgICAgLy8gU3ByaW5nJ3MgQFJlcXVlc3RQYXJ0IGV4cGVjdHMgQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uIGZvciBKU09OIHBhcnRzXG4gICAgICBjb25zdCBpbnB1dEJsb2IgPSBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkoZGF0YSldLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiIH0pXG4gICAgICBmb3JtRGF0YS5hcHBlbmQoXCJpbnB1dFwiLCBpbnB1dEJsb2IpXG5cbiAgICAgIGltYWdlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImltYWdlc1wiLCBmaWxlKVxuICAgICAgfSlcblxuICAgICAgLy8gVXNlIHByb3BlcnR5LXNlcnZpY2UgVVJMIGZvciBwcm9wZXJ0eSBlbmRwb2ludHNcbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXNgXG4gICAgICBjb25zdCBoZWFkZXJzOiBIZWFkZXJzSW5pdCA9IHtcbiAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHNldCBDb250ZW50LVR5cGUgaGVhZGVyIC0gbGV0IGJyb3dzZXIgc2V0IGl0IHdpdGggYm91bmRhcnkgZm9yIG11bHRpcGFydC9mb3JtLWRhdGFcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIHVwZGF0ZShpZDogc3RyaW5nLCBkYXRhOiBVcGRhdGVQcm9wZXJ0eVJlcXVlc3QpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy51cGRhdGUoaWQsIGRhdGEpXG4gICAgICB9XG4gICAgICAvLyBVc2UgcHJvcGVydHktc2VydmljZSBVUkwgZm9yIHByb3BlcnR5IGVuZHBvaW50c1xuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllcy8ke2lkfWBcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmFja2VuZCByZXR1cm5zIFwiUHJvcGVydHkgdXBkYXRlZFwiIGFzIHBsYWluIHRleHQsIG5vdCBKU09OXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KVxuICAgICAgICAgIHJldHVybiBwYXJzZWRcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gSWYgaXQncyBub3QgSlNPTiwgcmV0dXJuIHN1Y2Nlc3Mgb2JqZWN0XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkNPUlNcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gcHJvcGVydHktc2VydmljZSBiYWNrZW5kIGF0ICR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgICAgICApXG4gICAgICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBkZWxldGUoaWQ6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5wcm9wZXJ0aWVzLmRlbGV0ZShpZClcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBwcm9wZXJ0eS1zZXJ2aWNlIFVSTCBmb3IgcHJvcGVydHkgZW5kcG9pbnRzXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzLyR7aWR9YFxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkNPUlNcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gcHJvcGVydHktc2VydmljZSBiYWNrZW5kIGF0ICR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgICAgICApXG4gICAgICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBhcHByb3ZlKGlkOiBzdHJpbmcsIGlzQXBwcm92ZWQ6IGJvb2xlYW4pOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5hcHByb3ZlKGlkLCBpc0FwcHJvdmVkKVxuICAgICAgfVxuICAgICAgLy8gVXNlIHByb3BlcnR5LXNlcnZpY2UgVVJMIGZvciBwcm9wZXJ0eSBlbmRwb2ludHNcbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXMvJHtpZH0vYXBwcm92ZWBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpc0FwcHJvdmVkIH0gYXMgQXBwcm92ZVByb3BlcnR5UmVxdWVzdCksXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgcHJvcGVydHlcbiAgICAgKi9cbiAgICBhc3luYyBoaWRlKGlkOiBzdHJpbmcsIGlzSGlkZGVuOiBib29sZWFuKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfVxuICAgICAgLy8gVXNlIHByb3BlcnR5LXNlcnZpY2UgVVJMIGZvciBwcm9wZXJ0eSBlbmRwb2ludHNcbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXMvJHtpZH0vaGlkZWBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpc0hpZGRlbiB9KSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgc3VzcGVuZChpZDogc3RyaW5nLCByZWFzb246IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5wcm9wZXJ0aWVzLnN1c3BlbmQoaWQsIHJlYXNvbilcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBwcm9wZXJ0eS1zZXJ2aWNlIFVSTCBmb3IgcHJvcGVydHkgZW5kcG9pbnRzXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzLyR7aWR9L3N1c3BlbmRgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcmVhc29uIH0pLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyByZXZva2VTdXNwZW5zaW9uKGlkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5zdXNwZW5kKGlkLCBcIlwiKSAvLyBNb2NrXG4gICAgICB9XG4gICAgICAvLyBVc2UgcHJvcGVydHktc2VydmljZSBVUkwgZm9yIHByb3BlcnR5IGVuZHBvaW50c1xuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllcy8ke2lkfS9yZXZva2Utc3VzcGVuc2lvbmBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIHN1Ym1pdEZvckFwcHJvdmFsKGlkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5hcHByb3ZlKGlkLCB0cnVlKVxuICAgICAgfVxuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllcy8ke2lkfS9zdWJtaXQtZm9yLWFwcHJvdmFsYFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsQXBwcm92YWxSZXF1ZXN0KGlkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9XG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzLyR7aWR9L2NhbmNlbC1hcHByb3ZhbC1yZXF1ZXN0YFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IEFJLXBvd2VyZWQgcHJpY2Ugc3VnZ2VzdGlvbiBmb3IgYSBwcm9wZXJ0eSBhbmQgZGF0ZSByYW5nZS5cbiAgICAgKiBUaGlzIGNhbGxzIHByb3BlcnR5LXNlcnZpY2UsIHdoaWNoIGZvcndhcmRzIHRoZSByZXF1ZXN0IHRvIHRoZSBwcmljaW5nIG1vZGVsIEFQSS5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVkaWN0UHJpY2UoXG4gICAgICBwcm9wZXJ0eUlkOiBzdHJpbmcsXG4gICAgICBjaGVja0luRGF0ZTogc3RyaW5nLFxuICAgICAgY2hlY2tPdXREYXRlOiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTx7XG4gICAgICBwcmVkaWN0ZWRQcmljZU1hZDogbnVtYmVyXG4gICAgICBwcmVkaWN0ZWRQcmljZVVzZDogbnVtYmVyXG4gICAgICBjb25maWRlbmNlSW50ZXJ2YWxMb3dlcjogbnVtYmVyXG4gICAgICBjb25maWRlbmNlSW50ZXJ2YWxVcHBlcjogbnVtYmVyXG4gICAgICBjaXR5OiBzdHJpbmdcbiAgICAgIHNlYXNvbjogc3RyaW5nXG4gICAgICBtb2RlbFZlcnNpb246IHN0cmluZ1xuICAgICAgcHJlZGljdGlvblRpbWVzdGFtcDogc3RyaW5nXG4gICAgICBjdXJyZW50UHJpY2VNYWQ/OiBudW1iZXJcbiAgICAgIHByaWNlRGlmZmVyZW5jZVBlcmNlbnQ/OiBudW1iZXJcbiAgICAgIHJlY29tbWVuZGF0aW9uPzogc3RyaW5nXG4gICAgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICAvLyBMaWdodHdlaWdodCBtb2NrIGZvciBVSSBkZXZlbG9wbWVudFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByZWRpY3RlZFByaWNlTWFkOiA0MzAsXG4gICAgICAgICAgcHJlZGljdGVkUHJpY2VVc2Q6IDQzLFxuICAgICAgICAgIGNvbmZpZGVuY2VJbnRlcnZhbExvd2VyOiAzODAsXG4gICAgICAgICAgY29uZmlkZW5jZUludGVydmFsVXBwZXI6IDQ4MCxcbiAgICAgICAgICBjaXR5OiBcImNhc2FibGFuY2FcIixcbiAgICAgICAgICBzZWFzb246IFwic3VtbWVyXCIsXG4gICAgICAgICAgbW9kZWxWZXJzaW9uOiBcIjEuMFwiLFxuICAgICAgICAgIHByZWRpY3Rpb25UaW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBjdXJyZW50UHJpY2VNYWQ6IDQwMCxcbiAgICAgICAgICBwcmljZURpZmZlcmVuY2VQZXJjZW50OiA3LjUsXG4gICAgICAgICAgcmVjb21tZW5kYXRpb246IFwiSU5DUkVBU0VcIixcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzLyR7cHJvcGVydHlJZH0vcHJlZGljdC1wcmljZWBcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBwcm9wZXJ0eUlkLFxuICAgICAgICAgIGNoZWNrSW5EYXRlLFxuICAgICAgICAgIGNoZWNrT3V0RGF0ZSxcbiAgICAgICAgfSksXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgZGF0YT8ubWVzc2FnZSB8fFxuICAgICAgICAgIGRhdGE/LmVycm9yIHx8XG4gICAgICAgICAgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gZGF0YSA6IG51bGwpIHx8XG4gICAgICAgICAgYEZhaWxlZCB0byBnZXQgcHJpY2Ugc3VnZ2VzdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9LFxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IFRFTkFOVCBSSVNLID09PT09PT09PT09PT09PT09PT09XG4gIHJpc2s6IHtcbiAgICBnZXRUZW5hbnRSaXNrU2NvcmU6IGFzeW5jICh0ZW5hbnRJZDogbnVtYmVyKTogUHJvbWlzZTxUZW5hbnRSaXNrUmVzcG9uc2U+ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFVzZSBsb2NhbCBOZXh0LmpzIHByb3h5XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdGVuYW50LXJpc2svJHt0ZW5hbnRJZH1gLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1MIEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHJpc2sgc2NvcmU6XCIsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG4gIH0sXG5cbiAgcmVjb21tZW5kYXRpb25zOiB7XG4gICAgZ2V0Rm9yVGVuYW50OiBhc3luYyAodGVuYW50SWQ6IG51bWJlciwgbWF4UmVzdWx0czogbnVtYmVyID0gMyk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3JlY29tbWVuZGF0aW9ucy90ZW5hbnQvJHt0ZW5hbnRJZH0/bWF4X3Jlc3VsdHM9JHttYXhSZXN1bHRzfWApO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggcmVjb21tZW5kYXRpb25zXCIpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHJlY29tbWVuZGF0aW9uczpcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFNpbWlsYXI6IGFzeW5jIChwcm9wZXJ0eUlkOiBzdHJpbmcsIG1heFJlc3VsdHM6IG51bWJlciA9IDMpOiBQcm9taXNlPGFueT4gPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9yZWNvbW1lbmRhdGlvbnMvc2ltaWxhci8ke3Byb3BlcnR5SWR9P21heF9yZXN1bHRzPSR7bWF4UmVzdWx0c31gKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIHNpbWlsYXIgcHJvcGVydGllc1wiKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBzaW1pbGFyIHByb3BlcnRpZXM6XCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IFZFUklGSUNBVElPTiBSRVFVRVNUUyA9PT09PT09PT09PT09PT09PT09PVxuICB2ZXJpZmljYXRpb25SZXF1ZXN0czoge1xuICAgIGFzeW5jIGdldEFsbCgpOiBQcm9taXNlPFZlcmlmaWNhdGlvblJlcXVlc3RbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnZlcmlmaWNhdGlvblJlcXVlc3RzLmdldEFsbCgpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi92ZXJpZmljYXRpb24tcmVxdWVzdHNcIilcbiAgICB9LFxuXG4gICAgYXN5bmMgZ2V0QnlTdGF0dXMoc3RhdHVzOiBzdHJpbmcpOiBQcm9taXNlPFZlcmlmaWNhdGlvblJlcXVlc3RbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnZlcmlmaWNhdGlvblJlcXVlc3RzLmdldEJ5U3RhdHVzKHN0YXR1cylcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KGAvdmVyaWZpY2F0aW9uLXJlcXVlc3RzL2J5LXN0YXR1cy8ke3N0YXR1c31gKVxuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGUocHJvcGVydHlJZDogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nKTogUHJvbWlzZTx7IGlkOiBudW1iZXIgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnZlcmlmaWNhdGlvblJlcXVlc3RzLmNyZWF0ZShwcm9wZXJ0eUlkLCBkZXNjcmlwdGlvbilcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL3ZlcmlmaWNhdGlvbi1yZXF1ZXN0c1wiLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcHJvcGVydHlJZCwgZGVzY3JpcHRpb24gfSksXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyBhcHByb3ZlKGlkOiBudW1iZXIpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sudmVyaWZpY2F0aW9uUmVxdWVzdHMuYXBwcm92ZShpZClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KGAvdmVyaWZpY2F0aW9uLXJlcXVlc3RzLyR7aWR9L2FwcHJvdmVgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVqZWN0KGlkOiBudW1iZXIsIHJlYXNvbjogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnZlcmlmaWNhdGlvblJlcXVlc3RzLnJlamVjdChpZCwgcmVhc29uKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC92ZXJpZmljYXRpb24tcmVxdWVzdHMvJHtpZH0vcmVqZWN0YCwge1xuICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyByZWFzb24gfSksXG4gICAgICB9KVxuICAgIH0sXG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gUFJPUEVSVFkgVFlQRVMgPT09PT09PT09PT09PT09PT09PT1cbiAgcHJvcGVydHlUeXBlczoge1xuICAgIGFzeW5jIGdldEFsbCgpOiBQcm9taXNlPFByb3BlcnR5VHlwZVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydHlUeXBlcy5nZXRBbGwoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvcHJvcGVydHktdHlwZXNcIiwgeyByZXF1aXJlc0F1dGg6IGZhbHNlIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIGdldEJ5SWQoaWQ6IG51bWJlcik6IFByb21pc2U8UHJvcGVydHlUeXBlPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydHlUeXBlcy5nZXRCeUlkKGlkKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC9wcm9wZXJ0eS10eXBlcy8ke2lkfWAsIHsgcmVxdWlyZXNBdXRoOiBmYWxzZSB9KVxuICAgIH0sXG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gVVNFUlMgPT09PT09PT09PT09PT09PT09PT1cbiAgdXNlcnM6IHtcbiAgICBhc3luYyBnZXRNZSgpOiBQcm9taXNlPHtcbiAgICAgIGZpcnN0TmFtZTogc3RyaW5nXG4gICAgICBsYXN0TmFtZTogc3RyaW5nXG4gICAgICBlbWFpbDogc3RyaW5nXG4gICAgICBwcm9maWxlUGljdHVyZT86IHN0cmluZ1xuICAgICAgYmlydGhkYXk/OiBzdHJpbmdcbiAgICAgIHBob25lTnVtYmVyPzogbnVtYmVyXG4gICAgICB3YWxsZXRBZGRyZXNzPzogc3RyaW5nXG4gICAgICByb2xlcz86IHN0cmluZ1tdXG4gICAgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICAvLyBNb2NrIHVzZXIgZGF0YSBmb3IgZGV2ZWxvcG1lbnRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmaXJzdE5hbWU6IFwiTW9ja1wiLFxuICAgICAgICAgIGxhc3ROYW1lOiBcIlVzZXJcIixcbiAgICAgICAgICBlbWFpbDogXCJtb2NrQGV4YW1wbGUuY29tXCIsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL3VzZXJzL21lXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBpbmZvcm1hdGlvbiBieSBJRCAoZm9yIGdldHRpbmcgcGhvbmUgbnVtYmVyLCBldGMuKVxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5SWQodXNlcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPHtcbiAgICAgIGZpcnN0TmFtZTogc3RyaW5nXG4gICAgICBsYXN0TmFtZTogc3RyaW5nXG4gICAgICBlbWFpbDogc3RyaW5nXG4gICAgICBwcm9maWxlUGljdHVyZT86IHN0cmluZ1xuICAgICAgYmlydGhkYXk/OiBzdHJpbmdcbiAgICAgIHBob25lTnVtYmVyPzogbnVtYmVyXG4gICAgICB3YWxsZXRBZGRyZXNzPzogc3RyaW5nXG4gICAgICByb2xlcz86IHN0cmluZ1tdXG4gICAgICBzY29yZT86IG51bWJlclxuICAgICAgcmF0aW5nPzogbnVtYmVyXG4gICAgICBlbmFibGVkPzogYm9vbGVhblxuICAgIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmaXJzdE5hbWU6IFwiTW9ja1wiLFxuICAgICAgICAgIGxhc3ROYW1lOiBcIlVzZXJcIixcbiAgICAgICAgICBlbWFpbDogXCJtb2NrQGV4YW1wbGUuY29tXCIsXG4gICAgICAgICAgcGhvbmVOdW1iZXI6IDEyMzQ1Njc4OTAsXG4gICAgICAgICAgc2NvcmU6IDEwMCxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVHJ5IHRvIGdldCBmcm9tIGFkbWluIGVuZHBvaW50IGZpcnN0IChpZiB1c2VyIGlzIGFkbWluKSBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhbGxVc2VycyA9IGF3YWl0IHRoaXMuZ2V0QWxsRm9yQWRtaW4oKVxuICAgICAgICBjb25zdCB1c2VyID0gYWxsVXNlcnMuZmluZCh1ID0+IFN0cmluZyh1LmlkKSA9PT0gU3RyaW5nKHVzZXJJZCkpXG4gICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpcnN0TmFtZTogdXNlci5maXJzdE5hbWUsXG4gICAgICAgICAgICBsYXN0TmFtZTogdXNlci5sYXN0TmFtZSxcbiAgICAgICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICAgICAgcHJvZmlsZVBpY3R1cmU6IHVzZXIucHJvZmlsZVBpY3R1cmUsXG4gICAgICAgICAgICBiaXJ0aGRheTogdXNlci5iaXJ0aGRheSxcbiAgICAgICAgICAgIHBob25lTnVtYmVyOiB1c2VyLnBob25lTnVtYmVyLFxuICAgICAgICAgICAgd2FsbGV0QWRkcmVzczogdXNlci53YWxsZXRBZGRyZXNzLFxuICAgICAgICAgICAgcm9sZXM6IHVzZXIucm9sZXMsXG4gICAgICAgICAgICBzY29yZTogdXNlci5zY29yZSxcbiAgICAgICAgICAgIGVuYWJsZWQ6IHVzZXIuZW5hYmxlZCxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBJZiBhZG1pbiBlbmRwb2ludCBmYWlscywgZmFsbGJhY2sgdG8gcmVndWxhciBlbmRwb2ludFxuICAgICAgfVxuXG4gICAgICAvLyBGYWxsYmFjayB0byByZWd1bGFyIGVuZHBvaW50XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3VzZXJzLyR7dXNlcklkfWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyB1cGRhdGVNZShkYXRhOiB7XG4gICAgICBmaXJzdE5hbWU/OiBzdHJpbmdcbiAgICAgIGxhc3ROYW1lPzogc3RyaW5nXG4gICAgICBiaXJ0aGRheT86IHN0cmluZyAvLyBZWVlZLU1NLUREIGZvcm1hdFxuICAgICAgcGhvbmVOdW1iZXI/OiBzdHJpbmcgLy8gMTAtMTUgZGlnaXRzXG4gICAgICB3YWxsZXRBZGRyZXNzPzogc3RyaW5nIC8vIEV0aGVyZXVtIGFkZHJlc3NcbiAgICB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIC8vIE1vY2sgdXBkYXRlXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvdXNlcnMvbWVcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyB1cGRhdGVQcm9maWxlUGljdHVyZShmaWxlOiBGaWxlKTogUHJvbWlzZTx7IHVybDogc3RyaW5nIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJsOiBcIi9wbGFjZWhvbGRlci11c2VyLmpwZ1wiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBmaWxlKVxuXG4gICAgICBjb25zdCBoZWFkZXJzID0gZ2V0QXV0aEhlYWRlcnMoKVxuICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBoZWFkZXIgdG8gbGV0IGJyb3dzZXIgc2V0IGl0IHdpdGggYm91bmRhcnkgZm9yIG11bHRpcGFydC9mb3JtLWRhdGFcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdXG5cbiAgICAgIGNvbnN0IHVybCA9IGJ1aWxkVXJsKFwiL3VzZXJzL21lL3Byb2ZpbGUtcGljdHVyZVwiKVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBsZXQgZXJyb3JEYXRhOiBhbnkgPSB7fVxuICAgICAgICBsZXQgcmVzcG9uc2VUZXh0ID0gXCJcIlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICAgICAgaWYgKHJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXJyb3JEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpXG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgZXJyb3JEYXRhID0geyBtZXNzYWdlOiByZXNwb25zZVRleHQsIHJhdzogcmVzcG9uc2VUZXh0IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGVycm9yRGF0YSA9IHsgbWVzc2FnZTogYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPVxuICAgICAgICAgIGVycm9yRGF0YS5tZXNzYWdlIHx8XG4gICAgICAgICAgZXJyb3JEYXRhLmVycm9yIHx8XG4gICAgICAgICAgZXJyb3JEYXRhLnJhdyB8fFxuICAgICAgICAgIGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuXG4gICAgICAgIGNvbnN0IGFwaUVycm9yID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZSlcbiAgICAgICAgICA7IChhcGlFcnJvciBhcyBhbnkpLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgIDsgKGFwaUVycm9yIGFzIGFueSkuZXJyb3JEYXRhID0gZXJyb3JEYXRhXG4gICAgICAgIHRocm93IGFwaUVycm9yXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgIHJldHVybiB7IHVybDogdGV4dCB9IC8vIEJhY2tlbmQgcmV0dXJucyBVUkwgYXMgcGxhaW4gdGV4dFxuICAgIH0sXG5cbiAgICBhc3luYyBjaGFuZ2VQYXNzd29yZChjdXJyZW50UGFzc3dvcmQ6IHN0cmluZywgbmV3UGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIlBhc3N3b3JkIGNoYW5nZWQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvdXNlcnMvbWUvY2hhbmdlLXBhc3N3b3JkXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjdXJyZW50UGFzc3dvcmQsIG5ld1Bhc3N3b3JkIH0pLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgZGVsZXRlUHJvZmlsZVBpY3R1cmUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvdXNlcnMvbWUvcHJvZmlsZS1waWN0dXJlXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyBiZWNvbWVIb3N0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL3VzZXJzL21lL2JlY29tZS1ob3N0XCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgZ2V0QWxsRm9yQWRtaW4oKTogUHJvbWlzZTxBcnJheTx7XG4gICAgICBpZDogbnVtYmVyXG4gICAgICBmaXJzdE5hbWU6IHN0cmluZ1xuICAgICAgbGFzdE5hbWU6IHN0cmluZ1xuICAgICAgZW1haWw6IHN0cmluZ1xuICAgICAgcHJvZmlsZVBpY3R1cmU/OiBzdHJpbmdcbiAgICAgIGJpcnRoZGF5Pzogc3RyaW5nXG4gICAgICBwaG9uZU51bWJlcj86IG51bWJlclxuICAgICAgd2FsbGV0QWRkcmVzcz86IHN0cmluZ1xuICAgICAgcm9sZXM/OiBzdHJpbmdbXVxuICAgICAgZW5hYmxlZDogYm9vbGVhblxuICAgICAgc2NvcmU6IG51bWJlclxuICAgICAgcmF0aW5nPzogbnVtYmVyXG4gICAgfT4+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi91c2Vycy9hZG1pbi9hbGxcIiwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIHJlcXVpcmVzQXV0aDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIGVuYWJsZVVzZXIodXNlcklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3VzZXJzL2FkbWluLyR7dXNlcklkfS9lbmFibGVgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHt9KSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgZGlzYWJsZVVzZXIodXNlcklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3VzZXJzL2FkbWluLyR7dXNlcklkfS9kaXNhYmxlYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7fSksXG4gICAgICAgIHJlcXVpcmVzQXV0aDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIGFkZEFkbWluUm9sZSh1c2VySWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KGAvdXNlcnMvYWRtaW4vJHt1c2VySWR9L2FkZC1hZG1pbi1yb2xlYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyByZW1vdmVBZG1pblJvbGUodXNlcklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3VzZXJzL2FkbWluLyR7dXNlcklkfS9yZW1vdmUtYWRtaW4tcm9sZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgYWRkSG9zdFJvbGVCeUFkbWluKHVzZXJJZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC91c2Vycy9hZG1pbi8ke3VzZXJJZH0vYWRkLWhvc3Qtcm9sZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVtb3ZlSG9zdFJvbGUodXNlcklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3VzZXJzL2FkbWluLyR7dXNlcklkfS9yZW1vdmUtaG9zdC1yb2xlYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gQVVUSEVOVElDQVRJT04gPT09PT09PT09PT09PT09PT09PT1cbiAgYXV0aDoge1xuICAgIGFzeW5jIHJlZ2lzdGVyKGRhdGE6IHtcbiAgICAgIGZpcnN0TmFtZTogc3RyaW5nXG4gICAgICBsYXN0TmFtZTogc3RyaW5nXG4gICAgICBlbWFpbDogc3RyaW5nXG4gICAgICBwYXNzd29yZDogc3RyaW5nXG4gICAgICBiaXJ0aGRheTogc3RyaW5nIC8vIFlZWVktTU0tREQgZm9ybWF0XG4gICAgICBwaG9uZU51bWJlcjogc3RyaW5nXG4gICAgICByb2xlPzogc3RyaW5nXG4gICAgfSk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIC8vIE1vY2sgcmVnaXN0cmF0aW9uIC0gc2ltdWxhdGUgZGVsYXlcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IFwiVXNlciByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseVwiIH1cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICAgICAgZmlyc3ROYW1lOiBkYXRhLmZpcnN0TmFtZSxcbiAgICAgICAgICBsYXN0TmFtZTogZGF0YS5sYXN0TmFtZSxcbiAgICAgICAgICBlbWFpbDogZGF0YS5lbWFpbCxcbiAgICAgICAgICBwYXNzd29yZDogZGF0YS5wYXNzd29yZCxcbiAgICAgICAgICBiaXJ0aGRheTogZGF0YS5iaXJ0aGRheSwgLy8gU2hvdWxkIGJlIFlZWVktTU0tREQgZm9ybWF0IGZvciBMb2NhbERhdGVcbiAgICAgICAgICBwaG9uZU51bWJlcjogZGF0YS5waG9uZU51bWJlciwgLy8gU2hvdWxkIGJlIDEwLTE1IGRpZ2l0cyBvbmx5XG4gICAgICAgICAgLi4uKGRhdGEucm9sZSAmJiB7IHJvbGU6IGRhdGEucm9sZSB9KSxcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QoXCIvYXV0aC9yZWdpc3RlclwiLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgICAgICAgcmVxdWlyZXNBdXRoOiBmYWxzZSxcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgLy8gSWYgY29ubmVjdGlvbiBmYWlscywgdGhyb3cgd2l0aCBoZWxwZnVsIG1lc3NhZ2VcbiAgICAgICAgaWYgKGVycm9yPy5pc0Nvbm5lY3Rpb25FcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiQmFja2VuZCBzZXJ2ZXIgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgdXNlci1zZXJ2aWNlIGlzIHJ1bm5pbmcgb24gcG9ydCA4MDgwLlwiXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGxvZ2luKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHsgdG9rZW46IHN0cmluZzsgand0RXhwaXJhdGlvbjogbnVtYmVyIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICAvLyBNb2NrIGxvZ2luIC0gd291bGQgdXNlIG1vY2sgZGF0YVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2NrIGxvZ2luIG5vdCBpbXBsZW1lbnRlZCAtIHVzZSB1c2VBdXRoIGhvb2tcIilcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL2F1dGgvbG9naW5cIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsLCBwYXNzd29yZCB9KSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIHNldEF1dGgodG9rZW46IHN0cmluZywgdXNlcjogVXNlcik6IHZvaWQge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQVVUSF9UT0tFTl9LRVksIHRva2VuKVxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShVU0VSX0RBVEFfS0VZLCBKU09OLnN0cmluZ2lmeSh1c2VyKSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VG9rZW4oKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGxcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShBVVRIX1RPS0VOX0tFWSlcbiAgICB9LFxuXG4gICAgZ2V0VXNlcigpOiBVc2VyIHwgbnVsbCB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGxcbiAgICAgIGNvbnN0IHVzZXJEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oVVNFUl9EQVRBX0tFWSlcbiAgICAgIHJldHVybiB1c2VyRGF0YSA/IEpTT04ucGFyc2UodXNlckRhdGEpIDogbnVsbFxuICAgIH0sXG5cbiAgICBjbGVhckF1dGgoKTogdm9pZCB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShBVVRIX1RPS0VOX0tFWSlcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oVVNFUl9EQVRBX0tFWSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFzUm9sZShyb2xlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IHVzZXIgPSB0aGlzLmdldFVzZXIoKVxuICAgICAgcmV0dXJuIHVzZXI/LnJvbGVzLmluY2x1ZGVzKHJvbGUgYXMgYW55KSA/PyBmYWxzZVxuICAgIH0sXG5cbiAgICBhc3luYyB2ZXJpZnkoZW1haWw6IHN0cmluZywgdmVyaWZpY2F0aW9uQ29kZTogc3RyaW5nKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIlVzZXIgdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvYXV0aC92ZXJpZnlcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsLCB2ZXJpZmljYXRpb25Db2RlIH0pLFxuICAgICAgICByZXF1aXJlc0F1dGg6IGZhbHNlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVzZW5kVmVyaWZpY2F0aW9uQ29kZShlbWFpbDogc3RyaW5nKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIlZlcmlmaWNhdGlvbiBDb2RlIHJlc2VudCBzdWNjZXNzZnVsbHlcIiB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL2F1dGgvcmVzZW5kP2VtYWlsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGVtYWlsKX1gLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIHJlcXVpcmVzQXV0aDogZmFsc2UsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyBmb3Jnb3RQYXNzd29yZChlbWFpbDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL2F1dGgvZm9yZ290LXBhc3N3b3JkXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCB9KSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIHZlcmlmeVJlc2V0VG9rZW4odG9rZW46IHN0cmluZyk6IFByb21pc2U8eyB2YWxpZDogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi9hdXRoL3ZlcmlmeS1yZXNldC10b2tlblwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdG9rZW4gfSksXG4gICAgICAgIHJlcXVpcmVzQXV0aDogZmFsc2UsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyByZXNldFBhc3N3b3JkKHRva2VuOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvYXV0aC9yZXNldC1wYXNzd29yZFwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdG9rZW4sIHBhc3N3b3JkIH0pLFxuICAgICAgICByZXF1aXJlc0F1dGg6IGZhbHNlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgdmVyaWZ5UmVzZXRDb2RlKGVtYWlsOiBzdHJpbmcsIGNvZGU6IHN0cmluZyk6IFByb21pc2U8eyB2YWxpZDogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi9hdXRoL3ZlcmlmeS1yZXNldC1jb2RlXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCwgY29kZSB9KSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIHJlc2V0UGFzc3dvcmRXaXRoQ29kZShlbWFpbDogc3RyaW5nLCBjb2RlOiBzdHJpbmcsIG5ld1Bhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHsgbWVzc2FnZTogc3RyaW5nIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IFwiUGFzc3dvcmQgcmVzZXQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvYXV0aC9yZXNldC1wYXNzd29yZC13aXRoLWNvZGVcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsLCBjb2RlLCBuZXdQYXNzd29yZCB9KSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfSxcbiAgfSxcblxuICBib29raW5nczoge1xuICAgIC8qKlxuICAgICAqIEdldCBhbGwgYm9va2luZ3MgZm9yIGFkbWluXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsRm9yQWRtaW4oKTogUHJvbWlzZTxBcnJheTx7XG4gICAgICBpZDogbnVtYmVyXG4gICAgICB1c2VySWQ6IG51bWJlclxuICAgICAgcHJvcGVydHlJZDogc3RyaW5nXG4gICAgICBwcm9wZXJ0eVRpdGxlOiBzdHJpbmdcbiAgICAgIHByb3BlcnR5QWRkcmVzczogc3RyaW5nXG4gICAgICBvd25lcklkOiBudW1iZXIgfCBudWxsXG4gICAgICB0ZW5hbnROYW1lOiBzdHJpbmdcbiAgICAgIHRlbmFudEVtYWlsOiBzdHJpbmdcbiAgICAgIGhvc3ROYW1lOiBzdHJpbmdcbiAgICAgIGhvc3RFbWFpbDogc3RyaW5nXG4gICAgICBjaGVja0luRGF0ZTogc3RyaW5nXG4gICAgICBjaGVja091dERhdGU6IHN0cmluZ1xuICAgICAgbnVtYmVyT2ZOaWdodHM6IG51bWJlciB8IG51bGxcbiAgICAgIHRvdGFsUHJpY2U6IG51bWJlciB8IG51bGxcbiAgICAgIGxvbmdTdGF5RGlzY291bnRQZXJjZW50OiBudW1iZXIgfCBudWxsXG4gICAgICByZXF1ZXN0ZWROZWdvdGlhdGlvblBlcmNlbnQ6IG51bWJlciB8IG51bGxcbiAgICAgIHN0YXR1czogc3RyaW5nXG4gICAgICBvbkNoYWluVHhIYXNoOiBzdHJpbmcgfCBudWxsXG4gICAgICBuZWdvdGlhdGlvbkV4cGlyZXNBdDogc3RyaW5nIHwgbnVsbFxuICAgICAgY3JlYXRlZEF0OiBzdHJpbmdcbiAgICAgIHVwZGF0ZWRBdDogc3RyaW5nIHwgbnVsbFxuICAgIH0+PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9hZG1pbi9hbGxgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggYm9va2luZ3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGlmIChlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRVJSX0NPTk5FQ1RJT05fUkVGVVNFRFwiKSkge1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25FcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgY29ubmVjdCB0byBib29raW5nLXNlcnZpY2UgYmFja2VuZCBhdCAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgICAgICApXG4gICAgICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBib29raW5nIHJlcXVlc3RcbiAgICAgKiBTZW5kcyBib29raW5nIGRhdGEgdG8gYm9va2luZy1zZXJ2aWNlIHZpYSBSYWJiaXRNUVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShkYXRhOiB7XG4gICAgICB1c2VySWQ6IHN0cmluZyB8IG51bWJlclxuICAgICAgcHJvcGVydHlJZDogc3RyaW5nIHwgbnVtYmVyXG4gICAgICBjaGVja0luRGF0ZTogc3RyaW5nXG4gICAgICBjaGVja091dERhdGU6IHN0cmluZ1xuICAgICAgbnVtYmVyT2ZHdWVzdHM6IG51bWJlclxuICAgICAgcmVxdWVzdGVkUHJpY2U/OiBudW1iZXJcbiAgICB9KTogUHJvbWlzZTx7IHN0YXR1czogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmc7IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5ib29raW5ncz8uY3JlYXRlPy4oZGF0YSkgfHwgeyBzdGF0dXM6IFwiYWNjZXB0ZWRcIiwgbWVzc2FnZTogXCJCb29raW5nIHJlcXVlc3Qgc2VudFwiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9yZXF1ZXN0YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdXNlcklkOiB0eXBlb2YgZGF0YS51c2VySWQgPT09IFwic3RyaW5nXCIgPyBwYXJzZUludChkYXRhLnVzZXJJZCkgOiBkYXRhLnVzZXJJZCxcbiAgICAgICAgICBwcm9wZXJ0eUlkOiBkYXRhLnByb3BlcnR5SWQsIC8vIEtlZXAgYXMgU3RyaW5nIChVVUlEIGZyb20gcHJvcGVydHktc2VydmljZSlcbiAgICAgICAgICBjaGVja0luRGF0ZTogZGF0YS5jaGVja0luRGF0ZSxcbiAgICAgICAgICBjaGVja091dERhdGU6IGRhdGEuY2hlY2tPdXREYXRlLFxuICAgICAgICAgIG51bWJlck9mR3Vlc3RzOiBkYXRhLm51bWJlck9mR3Vlc3RzLFxuICAgICAgICAgIHJlcXVlc3RlZFByaWNlOiBkYXRhLnJlcXVlc3RlZFByaWNlLFxuICAgICAgICB9KSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIC8vIElmIHN0YXR1cyBpcyBcInJlamVjdGVkXCIsIHJldHVybiB0aGUgcmVzcG9uc2UgZGF0YSBpbnN0ZWFkIG9mIHRocm93aW5nXG4gICAgICAgIGlmIChyZXNwb25zZURhdGEuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2VEYXRhXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gY3JlYXRlIGJvb2tpbmc6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZURhdGFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJvb2tpbmcgYnkgSURcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCeUlkKGlkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLmJvb2tpbmdzPy5nZXRCeUlkPy4oaWQpIHx8IG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy8ke2lkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGJvb2tpbmc6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGJvb2tpbmdzIGJ5IHRlbmFudCBJRFxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5VGVuYW50SWQodGVuYW50SWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5ib29raW5ncz8uZ2V0QnlUZW5hbnRJZD8uKHRlbmFudElkKSB8fCBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzP3RlbmFudElkPSR7dGVuYW50SWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGJvb2tpbmdzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IGJvb2tpbmcgZm9yIGEgdXNlclxuICAgICAqL1xuICAgIGFzeW5jIGdldEN1cnJlbnRCb29raW5nKHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnkgfCBudWxsPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIC8vIE1vY2s6IHJldHVybiBudWxsIGZvciBub3cgKG5vIGN1cnJlbnQgYm9va2luZylcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9jdXJyZW50P3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0IHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGN1cnJlbnQgYm9va2luZzogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGVuZGluZyBib29raW5ncyAobmVnb3RpYXRpb25zKSBmb3IgYSB1c2VyXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UGVuZGluZ0Jvb2tpbmdzKHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICAvLyBNb2NrOiByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvcGVuZGluZz91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHBlbmRpbmcgYm9va2luZ3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGF3YWl0aW5nIHBheW1lbnQgYm9va2luZ3MgZm9yIGEgdXNlclxuICAgICAqL1xuICAgIGFzeW5jIGdldEF3YWl0aW5nUGF5bWVudEJvb2tpbmdzKHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICAvLyBNb2NrOiByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvcGF5bWVudD91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGF3YWl0aW5nIHBheW1lbnQgYm9va2luZ3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHByb3BlcnR5IGluZm8gZm9yIGJvb2tpbmcgKHByaWNlLCBkaXNjb3VudCwgbmVnb3RpYXRpb24pXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJvcGVydHlJbmZvKHByb3BlcnR5SWQ6IHN0cmluZyk6IFByb21pc2U8e1xuICAgICAgaWQ6IHN0cmluZ1xuICAgICAgb3duZXJJZDogbnVtYmVyXG4gICAgICBwcmljZVBlck5pZ2h0OiBudW1iZXIgfCBzdHJpbmcgLy8gQ2FuIGJlIG51bWJlciBvciBzdHJpbmcgKEJpZ0RlY2ltYWwgZnJvbSBiYWNrZW5kKVxuICAgICAgaXNOZWdvdGlhYmxlOiBib29sZWFuXG4gICAgICBkaXNjb3VudEVuYWJsZWQ6IGJvb2xlYW5cbiAgICAgIG1heE5lZ290aWF0aW9uUGVyY2VudD86IG51bWJlclxuICAgIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgLy8gTW9jayBwcm9wZXJ0eSBpbmZvXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IHByb3BlcnR5SWQsXG4gICAgICAgICAgb3duZXJJZDogMSxcbiAgICAgICAgICBwcmljZVBlck5pZ2h0OiAxMDAsXG4gICAgICAgICAgaXNOZWdvdGlhYmxlOiBmYWxzZSxcbiAgICAgICAgICBkaXNjb3VudEVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvcHJvcGVydHkvJHtwcm9wZXJ0eUlkfWBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkNPUlNcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gYm9va2luZy1zZXJ2aWNlIGJhY2tlbmQgYXQgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0uIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXMgcnVubmluZy5gXG4gICAgICAgICAgKVxuICAgICAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICAgICAgdGhyb3cgY29ubmVjdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxhc3QgYm9va2luZyBJRCAoZm9yIHBvbGxpbmcgYWZ0ZXIgY3JlYXRpb24pXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TGFzdEJvb2tpbmdJZCgpOiBQcm9taXNlPHsgYm9va2luZ0lkOiBudW1iZXIgfSB8IG51bGw+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgYm9va2luZ0lkOiAxIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9ib29raW5nLWlkYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIGJvb2tpbmdcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUoaWQ6IHN0cmluZyB8IG51bWJlciwgZGF0YToge1xuICAgICAgY2hlY2tJbkRhdGU/OiBzdHJpbmdcbiAgICAgIGNoZWNrT3V0RGF0ZT86IHN0cmluZ1xuICAgICAgbnVtYmVyT2ZHdWVzdHM/OiBudW1iZXJcbiAgICAgIHJlcXVlc3RlZFByaWNlPzogbnVtYmVyXG4gICAgfSk6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2suYm9va2luZ3M/LnVwZGF0ZT8uKGlkLCBkYXRhKSB8fCBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvJHtpZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGNoZWNrSW5EYXRlOiBkYXRhLmNoZWNrSW5EYXRlLFxuICAgICAgICAgIGNoZWNrT3V0RGF0ZTogZGF0YS5jaGVja091dERhdGUsXG4gICAgICAgICAgbnVtYmVyT2ZHdWVzdHM6IGRhdGEubnVtYmVyT2ZHdWVzdHMsXG4gICAgICAgICAgcmVxdWVzdGVkUHJpY2U6IGRhdGEucmVxdWVzdGVkUHJpY2UsXG4gICAgICAgIH0pLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gdXBkYXRlIGJvb2tpbmc6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKVxuICAgICAgICAgIC8vIEFkZCBzdGF0dXMgYW5kIGVycm9yIGNvZGUgZm9yIGJldHRlciBlcnJvciBoYW5kbGluZ1xuICAgICAgICAgIDsgKGVycm9yIGFzIGFueSkuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzXG4gICAgICAgICAgOyAoZXJyb3IgYXMgYW55KS5lcnJvckNvZGUgPSBlcnJvckRhdGEuZXJyb3JcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZS9DYW5jZWwgYSBib29raW5nIChieSB0ZW5hbnQpXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKGlkOiBzdHJpbmcgfCBudW1iZXIsIHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5ib29raW5ncz8uZGVsZXRlPy4oaWQsIHVzZXJJZClcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy8ke2lkfT91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuZXJyb3IgfHwgYEZhaWxlZCB0byBjYW5jZWwgYm9va2luZzogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUZW5hbnQgY2hlY2tvdXQgKGNoYW5nZXMgc3RhdHVzIHRvIFRFTkFOVF9DSEVDS0VEX09VVClcbiAgICAgKi9cbiAgICBhc3luYyB0ZW5hbnRDaGVja291dChpZDogc3RyaW5nIHwgbnVtYmVyLCB0ZW5hbnRJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJUZW5hbnQgY2hlY2tlZCBvdXQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7aWR9L2NoZWNrb3V0L3RlbmFudD91c2VySWQ9JHt0ZW5hbnRJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuZXJyb3IgfHwgYEZhaWxlZCB0byBjaGVja291dDogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPd25lciBjb25maXJtIGNoZWNrb3V0IChjaGFuZ2VzIHN0YXR1cyB0byBDT01QTEVURUQpXG4gICAgICovXG4gICAgYXN5bmMgb3duZXJDb25maXJtQ2hlY2tvdXQoaWQ6IHN0cmluZyB8IG51bWJlciwgb3duZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJDaGVja291dCBjb25maXJtZWQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7aWR9L2NoZWNrb3V0L293bmVyP3VzZXJJZD0ke293bmVySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gY29uZmlybSBjaGVja291dDogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdGVuYW50Q2hlY2tvdXQoKSBvciBvd25lckNvbmZpcm1DaGVja291dCgpIGluc3RlYWRcbiAgICAgKi9cbiAgICBhc3luYyBtYXJrQXNDaGVja2VkT3V0KGlkOiBzdHJpbmcgfCBudW1iZXIsIHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5ib29raW5ncz8ubWFya0FzQ2hlY2tlZE91dD8uKGlkLCB1c2VySWQpIHx8IG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy8ke2lkfS9jaGVja291dD91c2VySWQ9JHt1c2VySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gbWFyayBhcyBjaGVja2VkIG91dDogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBib29raW5ncyBieSBvd25lciAoaG9zdClcbiAgICAgKi9cbiAgICBhc3luYyBnZXRDdXJyZW50Qm9va2luZ3NCeU93bmVyKG93bmVySWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvY3VycmVudC9vd25lcj9vd25lcklkPSR7b3duZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggY3VycmVudCBib29raW5nczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcGVuZGluZyBuZWdvdGlhdGlvbnMgYnkgb3duZXIgKGhvc3QpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UGVuZGluZ05lZ290aWF0aW9ucyhvd25lcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzL25lZ290aWF0aW9ucz9vd25lcklkPSR7b3duZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggcGVuZGluZyBuZWdvdGlhdGlvbnM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWNjZXB0IG5lZ290aWF0aW9uIChob3N0KVxuICAgICAqL1xuICAgIGFzeW5jIGFjY2VwdE5lZ290aWF0aW9uKGJvb2tpbmdJZDogc3RyaW5nIHwgbnVtYmVyLCBvd25lcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIk5lZ290aWF0aW9uIGFjY2VwdGVkXCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7Ym9va2luZ0lkfS9hY2NlcHQ/b3duZXJJZD0ke293bmVySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gYWNjZXB0IG5lZ290aWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlamVjdCBuZWdvdGlhdGlvbiAoaG9zdClcbiAgICAgKi9cbiAgICBhc3luYyByZWplY3ROZWdvdGlhdGlvbihib29raW5nSWQ6IHN0cmluZyB8IG51bWJlciwgb3duZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJOZWdvdGlhdGlvbiByZWplY3RlZFwiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy8ke2Jvb2tpbmdJZH0vcmVqZWN0P293bmVySWQ9JHtvd25lcklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGVycm9yRGF0YS5lcnJvciB8fCBgRmFpbGVkIHRvIHJlamVjdCBuZWdvdGlhdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGJvb2tpbmdzIGJ5IG93bmVyIChob3N0KVxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5T3duZXJJZChvd25lcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzP293bmVySWQ9JHtvd25lcklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBib29raW5nczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29uZmlybWVkIGJvb2tpbmdzIGJ5IG93bmVyIChob3N0KVxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbmZpcm1lZEJvb2tpbmdzQnlPd25lcihvd25lcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzL2NvbmZpcm1lZC9vd25lcj9vd25lcklkPSR7b3duZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggY29uZmlybWVkIGJvb2tpbmdzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb25maXJtZWQgYm9va2luZ3MgYnkgcHJvcGVydHkgSURcbiAgICAgKi9cbiAgICBhc3luYyBnZXRDb25maXJtZWRCb29raW5nc0J5UHJvcGVydHkocHJvcGVydHlJZDogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9jb25maXJtZWQvcHJvcGVydHkvJHtwcm9wZXJ0eUlkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBjb25maXJtZWQgYm9va2luZ3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwb3J0IGRpc3B1dGUgKGhvc3Qgb3IgdGVuYW50KVxuICAgICAqL1xuICAgIGFzeW5jIHJlcG9ydERpc3B1dGUoYm9va2luZ0lkOiBzdHJpbmcgfCBudW1iZXIsIHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogXCJEaXNwdXRlIHJlcG9ydGVkXCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7Ym9va2luZ0lkfS9kaXNwdXRlP3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gcmVwb3J0IGRpc3B1dGU6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBQYXltZW50IFNlcnZpY2UgQVBJXG4gICAqL1xuICBwYXltZW50czoge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBwYXltZW50IGludGVudFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUludGVudChib29raW5nSWQ6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVmZXJlbmNlSWQ6IFwibW9jay1yZWYtaWRcIixcbiAgICAgICAgICB0bzogXCIweDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBcIixcbiAgICAgICAgICB2YWx1ZTogXCIxMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICBjaGFpbklkOiAzMTMzNyxcbiAgICAgICAgICB0b3RhbEFtb3VudFdlaTogXCIxMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UEFZTUVOVF9BUElfQkFTRV9VUkx9L2FwaS9wYXltZW50cy9pbnRlbnRgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgYm9va2luZ0lkIH0pLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gY3JlYXRlIHBheW1lbnQgaW50ZW50OiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBib29raW5nIGRldGFpbHMgZm9yIHBheW1lbnRcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCb29raW5nRGV0YWlscyhib29raW5nSWQ6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYm9va2luZ0lkLFxuICAgICAgICAgIHN0YXR1czogXCJQRU5ESU5HX1BBWU1FTlRcIixcbiAgICAgICAgICB0b3RhbFByaWNlOiAxMDAuMCxcbiAgICAgICAgICBjaGVja0luRGF0ZTogXCIyMDI1LTEyLTAxXCIsXG4gICAgICAgICAgY2hlY2tPdXREYXRlOiBcIjIwMjUtMTItMDVcIixcbiAgICAgICAgICBwcm9wZXJ0eUlkOiAxLFxuICAgICAgICAgIHByb3BlcnR5VGl0bGU6IFwiTW9jayBQcm9wZXJ0eVwiLFxuICAgICAgICAgIHByb3BlcnR5UHJpY2U6IDIwLjAsXG4gICAgICAgICAgb3duZXJXYWxsZXRBZGRyZXNzOiBcIjB4MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MFwiLFxuICAgICAgICAgIHVzZXJJZDogMSxcbiAgICAgICAgICBjdXJyZW50VXNlcklkOiAxLFxuICAgICAgICAgIHVzZXJGaXJzdE5hbWU6IFwiSm9oblwiLFxuICAgICAgICAgIHVzZXJMYXN0TmFtZTogXCJEb2VcIixcbiAgICAgICAgICB1c2VyRW1haWw6IFwiam9obkBleGFtcGxlLmNvbVwiLFxuICAgICAgICAgIHVzZXJXYWxsZXRBZGRyZXNzOiBudWxsLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1BBWU1FTlRfQVBJX0JBU0VfVVJMfS9hcGkvcGF5bWVudHMvYm9va2luZy8ke2Jvb2tpbmdJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGBGYWlsZWQgdG8gZmV0Y2ggYm9va2luZyBkZXRhaWxzOiAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgICAgLy8gQmFja2VuZCByZXR1cm5zIHsgY29kZSwgbWVzc2FnZSB9IGZvcm1hdFxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yRGF0YS5tZXNzYWdlIHx8IGVycm9yRGF0YS5jb2RlIHx8IGVycm9yTWVzc2FnZVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSWYgcmVzcG9uc2UgaXMgbm90IEpTT04sIHVzZSBzdGF0dXMgdGV4dFxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLnN0YXR1c1RleHQgfHwgZXJyb3JNZXNzYWdlXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgd2FsbGV0IGFkZHJlc3NcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVXYWxsZXRBZGRyZXNzKHVzZXJJZDogbnVtYmVyLCB3YWxsZXRBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1BBWU1FTlRfQVBJX0JBU0VfVVJMfS9hcGkvcGF5bWVudHMvd2FsbGV0LWFkZHJlc3NgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1c2VySWQsIHdhbGxldEFkZHJlc3MgfSksXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byB1cGRhdGUgd2FsbGV0IGFkZHJlc3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVHJhbnNhY3Rpb25IYXNoKGJvb2tpbmdJZDogbnVtYmVyLCB0eEhhc2g6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UEFZTUVOVF9BUElfQkFTRV9VUkx9L2FwaS9wYXltZW50cy9ib29raW5nLyR7Ym9va2luZ0lkfS90eC1oYXNoYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdHhIYXNoIH0pLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gdXBkYXRlIHRyYW5zYWN0aW9uIGhhc2g6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIERhdGUgbW9kaWZpY2F0aW9uIHJlbW92ZWQgLSBkYXRlcyBjYW4gb25seSBiZSBjaGFuZ2VkIGZyb20gYm9va2luZy1zZXJ2aWNlXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdHJhbnNhY3Rpb24gc3RhdHVzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25TdGF0dXModHhIYXNoOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR4SGFzaCxcbiAgICAgICAgICBzdGF0dXM6IFwiUEVORElOR1wiLFxuICAgICAgICAgIGJsb2NrTnVtYmVyOiBudWxsLFxuICAgICAgICAgIGJvb2tpbmdJZDogbnVsbCxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtQQVlNRU5UX0FQSV9CQVNFX1VSTH0vYXBpL3BheW1lbnRzL3R4LyR7dHhIYXNofWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggdHJhbnNhY3Rpb24gc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIGJvb2tpbmcgb24gYmxvY2tjaGFpbiAoY2FsbGVkIGJ5IGhvc3Qgd2hlbiBjb25maXJtaW5nIGNoZWNrb3V0KVxuICAgICAqL1xuICAgIGFzeW5jIGNvbXBsZXRlQm9va2luZyhib29raW5nSWQ6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICBtZXNzYWdlOiBcIkJvb2tpbmcgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBvbiBibG9ja2NoYWluXCIsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UEFZTUVOVF9BUElfQkFTRV9VUkx9L2FwaS9wYXltZW50cy9ib29raW5nLyR7Ym9va2luZ0lkfS9jb21wbGV0ZWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBsZXQgZXJyb3JEYXRhOiBhbnkgPSB7fVxuICAgICAgICBsZXQgZXJyb3JUZXh0ID0gXCJcIlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgICAgIGlmIChlcnJvclRleHQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGVycm9yRGF0YSA9IEpTT04ucGFyc2UoZXJyb3JUZXh0KVxuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIGVycm9yRGF0YSA9IHsgbWVzc2FnZTogZXJyb3JUZXh0IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBJZiByZXNwb25zZSBpcyBub3QgSlNPTiwgdXNlIHN0YXR1cyB0ZXh0XG4gICAgICAgICAgZXJyb3JEYXRhID0geyBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0IHx8IGBTZXJ2ZXIgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGVycm9yVGV4dCB8fCBgRmFpbGVkIHRvIGNvbXBsZXRlIGJvb2tpbmc6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcblxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IFJFQ0xBTUFUSU9OUyA9PT09PT09PT09PT09PT09PT09PVxuICByZWNsYW1hdGlvbnM6IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSByZWNsYW1hdGlvbiBmb3IgYSBib29raW5nXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKFxuICAgICAgYm9va2luZ0lkOiBzdHJpbmcgfCBudW1iZXIsXG4gICAgICB1c2VySWQ6IHN0cmluZyB8IG51bWJlcixcbiAgICAgIGNvbXBsYWluYW50Um9sZTogXCJHVUVTVFwiIHwgXCJIT1NUXCIsXG4gICAgICByZWNsYW1hdGlvblR5cGU6IHN0cmluZyxcbiAgICAgIHRpdGxlPzogc3RyaW5nLFxuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmcsXG4gICAgICBpbWFnZXM/OiBGaWxlW11cbiAgICApOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiLCBtZXNzYWdlOiBcIlJlY2xhbWF0aW9uIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuXG4gICAgICAvLyBVc2UgcmVjbGFtYXRpb24tc2VydmljZSBkaXJlY3RseSB0byBzdXBwb3J0IGltYWdlc1xuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgICAgZm9ybURhdGEuYXBwZW5kKFwiYm9va2luZ0lkXCIsIFN0cmluZyhib29raW5nSWQpKVxuICAgICAgZm9ybURhdGEuYXBwZW5kKFwidXNlcklkXCIsIFN0cmluZyh1c2VySWQpKVxuICAgICAgZm9ybURhdGEuYXBwZW5kKFwiY29tcGxhaW5hbnRSb2xlXCIsIGNvbXBsYWluYW50Um9sZSlcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcInJlY2xhbWF0aW9uVHlwZVwiLCByZWNsYW1hdGlvblR5cGUpXG4gICAgICBpZiAodGl0bGUpIGZvcm1EYXRhLmFwcGVuZChcInRpdGxlXCIsIHRpdGxlKVxuICAgICAgaWYgKGRlc2NyaXB0aW9uKSBmb3JtRGF0YS5hcHBlbmQoXCJkZXNjcmlwdGlvblwiLCBkZXNjcmlwdGlvbilcbiAgICAgIGlmIChpbWFnZXMgJiYgaW1hZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW1hZ2VzLmZvckVhY2goKGltYWdlKSA9PiB7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZXNcIiwgaW1hZ2UpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy9jcmVhdGVgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBjcmVhdGUgcmVjbGFtYXRpb246ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCByZWNsYW1hdGlvbnMgYnkgY29tcGxhaW5hbnQgSUQgKG15IGNvbXBsYWludHMpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TXlDb21wbGFpbnRzKHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvcmVjbGFtYXRpb25zL215LWNvbXBsYWludHM/dXNlcklkPSR7dXNlcklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBjb21wbGFpbnRzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcmVjbGFtYXRpb25zIGFnYWluc3QgYSB1c2VyIChjb21wbGFpbnRzIGFnYWluc3QgbWUpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29tcGxhaW50c0FnYWluc3RNZSh1c2VySWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy9hZ2FpbnN0LW1lP3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggY29tcGxhaW50czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYXR0YWNobWVudHMgKGltYWdlcykgZm9yIGEgcmVjbGFtYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWRBdHRhY2htZW50cyhyZWNsYW1hdGlvbklkOiBudW1iZXIsIGZpbGVzOiBGaWxlW10pOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlc1wiLCBmaWxlKVxuICAgICAgfSlcblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvcmVjbGFtYXRpb25zLyR7cmVjbGFtYXRpb25JZH0vYXR0YWNobWVudHNgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byB1cGxvYWQgYXR0YWNobWVudHM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJlY2xhbWF0aW9uIGJ5IGJvb2tpbmcgSUQgYW5kIGNvbXBsYWluYW50IElEXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QnlCb29raW5nSWRBbmRDb21wbGFpbmFudChcbiAgICAgIGJvb2tpbmdJZDogc3RyaW5nIHwgbnVtYmVyLFxuICAgICAgY29tcGxhaW5hbnRJZDogc3RyaW5nIHwgbnVtYmVyXG4gICAgKTogUHJvbWlzZTxhbnkgfCBudWxsPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy9ib29raW5nLyR7Ym9va2luZ0lkfS9jb21wbGFpbmFudC8ke2NvbXBsYWluYW50SWR9YFxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICAvLyA0MDQgaXMgZXhwZWN0ZWQgd2hlbiBubyByZWNsYW1hdGlvbiBleGlzdHMgLSByZXR1cm4gbnVsbCBzaWxlbnRseVxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAvLyBTaWxlbnRseSBoYW5kbGUgNDA0IGVycm9ycyAobm8gcmVjbGFtYXRpb24gZXhpc3RzIC0gdGhpcyBpcyBub3JtYWwpXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcyhcIjQwNFwiKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcyhcIk5vdCBGb3VuZFwiKSkge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJlY2xhbWF0aW9uIGJ5IElEXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QnlJZChyZWNsYW1hdGlvbklkOiBudW1iZXIpOiBQcm9taXNlPGFueSB8IG51bGw+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvcmVjbGFtYXRpb25zLyR7cmVjbGFtYXRpb25JZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZWNsYW1hdGlvbiBhdHRhY2htZW50cyAoaW1hZ2VzKVxuICAgICAqL1xuICAgIGFzeW5jIGdldEF0dGFjaG1lbnRzKHJlY2xhbWF0aW9uSWQ6IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9L2F0dGFjaG1lbnRzYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGF0dGFjaG1lbnRzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHJlY2xhbWF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHJlY2xhbWF0aW9uSWQ6IHN0cmluZyB8IG51bWJlciwgdXNlcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9P3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZGVsZXRlIHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSByZWNsYW1hdGlvbiAodGl0bGUsIGRlc2NyaXB0aW9uLCBpbWFnZXMpXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKFxuICAgICAgcmVjbGFtYXRpb25JZDogc3RyaW5nIHwgbnVtYmVyLFxuICAgICAgdXNlcklkOiBzdHJpbmcgfCBudW1iZXIsXG4gICAgICB0aXRsZT86IHN0cmluZyxcbiAgICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nLFxuICAgICAgaW1hZ2VzPzogRmlsZVtdXG4gICAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiwgbWVzc2FnZTogXCJSZWNsYW1hdGlvbiB1cGRhdGVkIHN1Y2Nlc3NmdWxseVwiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgICAgZm9ybURhdGEuYXBwZW5kKFwidXNlcklkXCIsIFN0cmluZyh1c2VySWQpKVxuICAgICAgaWYgKHRpdGxlKSBmb3JtRGF0YS5hcHBlbmQoXCJ0aXRsZVwiLCB0aXRsZSlcbiAgICAgIGlmIChkZXNjcmlwdGlvbikgZm9ybURhdGEuYXBwZW5kKFwiZGVzY3JpcHRpb25cIiwgZGVzY3JpcHRpb24pXG4gICAgICBpZiAoaW1hZ2VzICYmIGltYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGltYWdlcy5mb3JFYWNoKChpbWFnZSkgPT4ge1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVzXCIsIGltYWdlKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9yZWNsYW1hdGlvbnMvJHtyZWNsYW1hdGlvbklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gdXBkYXRlIHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIHBob25lIG51bWJlclxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXJQaG9uZU51bWJlcih1c2VySWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9yZWNsYW1hdGlvbnMvdXNlci8ke3VzZXJJZH0vcGhvbmVgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggcGhvbmUgbnVtYmVyOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICByZXR1cm4gZGF0YS5waG9uZU51bWJlciB8fCBudWxsXG4gICAgfSxcbiAgfSxcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSBBRE1JTiBSRUNMQU1BVElPTlMgPT09PT09PT09PT09PT09PT09PT1cbiAgYWRtaW5SZWNsYW1hdGlvbnM6IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHJlY2xhbWF0aW9ucyAoYWRtaW4gb25seSlcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBbGwoKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvYWRtaW4vcmVjbGFtYXRpb25zYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHJlY2xhbWF0aW9uczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVjbGFtYXRpb25zIGJ5IHN0YXR1c1xuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5U3RhdHVzKHN0YXR1czogXCJPUEVOXCIgfCBcIklOX1JFVklFV1wiIHwgXCJSRVNPTFZFRFwiIHwgXCJSRUpFQ1RFRFwiKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvYWRtaW4vcmVjbGFtYXRpb25zL3N0YXR1cy8ke3N0YXR1c31gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggcmVjbGFtYXRpb25zOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZWNsYW1hdGlvbiBieSBJRFxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5SWQocmVjbGFtYXRpb25JZDogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvcmVjbGFtYXRpb25zLyR7cmVjbGFtYXRpb25JZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSByZWNsYW1hdGlvbiBzZXZlcml0eVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVNldmVyaXR5KHJlY2xhbWF0aW9uSWQ6IG51bWJlciwgc2V2ZXJpdHk6IFwiTE9XXCIgfCBcIk1FRElVTVwiIHwgXCJISUdIXCIgfCBcIkNSSVRJQ0FMXCIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvYWRtaW4vcmVjbGFtYXRpb25zLyR7cmVjbGFtYXRpb25JZH0vc2V2ZXJpdHk/c2V2ZXJpdHk9JHtzZXZlcml0eX1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gdXBkYXRlIHNldmVyaXR5OiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldmlldyByZWNsYW1hdGlvbiAobW92ZSB0byBJTl9SRVZJRVcpXG4gICAgICovXG4gICAgYXN5bmMgcmV2aWV3KHJlY2xhbWF0aW9uSWQ6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJzdWNjZXNzXCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9hZG1pbi9yZWNsYW1hdGlvbnMvJHtyZWNsYW1hdGlvbklkfS9yZXZpZXdgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gcmV2aWV3IHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgcmVjbGFtYXRpb24gd2l0aCBwZW5hbHR5XG4gICAgICovXG4gICAgYXN5bmMgcmVzb2x2ZShyZWNsYW1hdGlvbklkOiBudW1iZXIsIHJlc29sdXRpb25Ob3Rlczogc3RyaW5nLCBhcHByb3ZlZDogYm9vbGVhbik6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJzdWNjZXNzXCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9hZG1pbi9yZWNsYW1hdGlvbnMvJHtyZWNsYW1hdGlvbklkfS9yZXNvbHZlYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICByZXNvbHV0aW9uTm90ZXMsXG4gICAgICAgICAgYXBwcm92ZWQsXG4gICAgICAgIH0pLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gcmVzb2x2ZSByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWplY3QgcmVjbGFtYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyByZWplY3QocmVjbGFtYXRpb25JZDogbnVtYmVyLCByZWplY3Rpb25Ob3Rlczogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL2FkbWluL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9L3JlamVjdGBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcmVqZWN0aW9uTm90ZXMsXG4gICAgICAgIH0pLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gcmVqZWN0IHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZWNsYW1hdGlvbiBhdHRhY2htZW50cyAoaW1hZ2VzKVxuICAgICAqL1xuICAgIGFzeW5jIGdldEF0dGFjaG1lbnRzKHJlY2xhbWF0aW9uSWQ6IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL2FkbWluL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9L2F0dGFjaG1lbnRzYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGF0dGFjaG1lbnRzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZWNsYW1hdGlvbiBzdGF0aXN0aWNzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3RhdGlzdGljcygpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvdGFsOiAwLFxuICAgICAgICAgIG9wZW46IDAsXG4gICAgICAgICAgaW5SZXZpZXc6IDAsXG4gICAgICAgICAgcmVzb2x2ZWQ6IDAsXG4gICAgICAgICAgcmVqZWN0ZWQ6IDAsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvYWRtaW4vcmVjbGFtYXRpb25zL3N0YXRpc3RpY3NgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggc3RhdGlzdGljczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gUkVDT01NRU5EQVRJT05TID09PT09PT09PT09PT09PT09PT09XG4gIHJlY29tbWVuZGF0aW9uczoge1xuICAgIGFzeW5jIGdldEZvclRlbmFudCh0ZW5hbnRJZDogc3RyaW5nLCBtYXhSZXN1bHRzOiBudW1iZXIgPSAzKSB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSByZXR1cm4gW107XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3JlY29tbWVuZGF0aW9ucy90ZW5hbnQvJHt0ZW5hbnRJZH0/bWF4X3Jlc3VsdHM9JHttYXhSZXN1bHRzfWApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIHJlY29tbWVuZGF0aW9uc1wiKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSxcbiAgICBhc3luYyBnZXRTaW1pbGFyKHByb3BlcnR5SWQ6IG51bWJlciwgbWF4UmVzdWx0czogbnVtYmVyID0gMykge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkgcmV0dXJuIFtdO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9yZWNvbW1lbmRhdGlvbnMvc2ltaWxhci8ke3Byb3BlcnR5SWR9P21heF9yZXN1bHRzPSR7bWF4UmVzdWx0c31gKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBzaW1pbGFyIHByb3BlcnRpZXNcIik7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0sXG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gTUFSS0VUIFRSRU5EUyA9PT09PT09PT09PT09PT09PT09PVxuICBtYXJrZXRUcmVuZHM6IHtcbiAgICBhc3luYyBnZXRBbGxDaXRpZXMocGVyaW9kTW9udGhzOiBudW1iZXIgPSAxMikge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkgcmV0dXJuIHsgdHJlbmRzOiBbXSwgaW5zaWdodHM6IFtdIH07XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL21hcmtldC10cmVuZHMvYWxsLWNpdGllcz9wZXJpb2RfbW9udGhzPSR7cGVyaW9kTW9udGhzfWApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldCB0cmVuZHNcIik7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0sXG4gICAgYXN5bmMgZ2V0Q2l0eVRyZW5kcyhjaXR5OiBzdHJpbmcsIHBlcmlvZE1vbnRoczogbnVtYmVyID0gMTIpIHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHJldHVybiB7IGRhdGFfcG9pbnRzOiBbXSB9O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9tYXJrZXQtdHJlbmRzL2NpdHkvJHtjaXR5fT9wZXJpb2RfbW9udGhzPSR7cGVyaW9kTW9udGhzfWApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggdHJlbmRzIGZvciAke2NpdHl9YCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0sXG4gICAgYXN5bmMgZ2V0SW5zaWdodHMoY2l0eTogc3RyaW5nKSB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSByZXR1cm4gW107XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL21hcmtldC10cmVuZHMvaW5zaWdodHMvJHtjaXR5fWApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggaW5zaWdodHMgZm9yICR7Y2l0eX1gKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgY29uc3QgYXBpQmFzZVVybCA9IEFQSV9CQVNFX1VSTFxuZXhwb3J0IGNvbnN0IGFwaVZlcnNpb24gPSBBUElfVkVSU0lPTlxuIl0sIm5hbWVzIjpbIkdBVEVXQVlfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0dBVEVXQVlfVVJMIiwiVVNFX0dBVEVXQVkiLCJORVhUX1BVQkxJQ19VU0VfR0FURVdBWSIsIkFQSV9CQVNFX1VSTCIsIk5FWFRfUFVCTElDX0FQSV9CQVNFX1VSTCIsIlBST1BFUlRZX0FQSV9CQVNFX1VSTCIsIk5FWFRfUFVCTElDX1BST1BFUlRZX0FQSV9CQVNFX1VSTCIsIkJPT0tJTkdfQVBJX0JBU0VfVVJMIiwiTkVYVF9QVUJMSUNfQk9PS0lOR19BUElfQkFTRV9VUkwiLCJQQVlNRU5UX0FQSV9CQVNFX1VSTCIsIk5FWFRfUFVCTElDX1BBWU1FTlRfQVBJX0JBU0VfVVJMIiwiUkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMIiwiTkVYVF9QVUJMSUNfUkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMIiwiQVBJX1ZFUlNJT04iLCJORVhUX1BVQkxJQ19BUElfVkVSU0lPTiIsIkFVVEhfVE9LRU5fS0VZIiwiTkVYVF9QVUJMSUNfQVVUSF9TVE9SQUdFX0tFWSIsIlVTRVJfREFUQV9LRVkiLCJORVhUX1BVQkxJQ19VU0VSX1NUT1JBR0VfS0VZIiwiVVNFX01PQ0tfQVBJIiwiTkVYVF9QVUJMSUNfVVNFX01PQ0tfQVBJIiwibW9ja0FwaUNsaWVudCIsImdldE1vY2tBcGkiLCJtb2NrQXBpIiwiZGVjb2RlSldUIiwidG9rZW4iLCJwYXJ0cyIsInNwbGl0IiwibGVuZ3RoIiwicGF5bG9hZCIsImRlY29kZWQiLCJKU09OIiwicGFyc2UiLCJhdG9iIiwicmVwbGFjZSIsInVzZXJJZCIsInN1YiIsInN1YmplY3QiLCJyb2xlcyIsImVycm9yIiwiZ2V0QXV0aEhlYWRlcnMiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidXNlckRhdGEiLCJmaW5hbFVzZXJJZCIsInVzZXIiLCJpZCIsInVzZXJJZFN0cmluZyIsIlN0cmluZyIsImhlYWRlcnMiLCJqb2luIiwiQXV0aG9yaXphdGlvbiIsImdldFNlcnZpY2VVcmwiLCJzZXJ2aWNlIiwiYnVpbGRVcmwiLCJwYXRoIiwiYmFzZVVybCIsInN0YXJ0c1dpdGgiLCJiYXNlUGF0aCIsInJlcXVlc3QiLCJvcHRpb25zIiwicmVxdWlyZXNBdXRoIiwiZmV0Y2hPcHRpb25zIiwidXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiZXJyb3JEYXRhIiwicmVzcG9uc2VUZXh0IiwidGV4dCIsInBhcnNlRXJyb3IiLCJtZXNzYWdlIiwicmF3IiwidGV4dEVycm9yIiwiT2JqZWN0Iiwia2V5cyIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJlcnJvck1lc3NhZ2UiLCJkZXRhaWwiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvcnMiLCJhcGlFcnJvciIsIkVycm9yIiwiY29udGVudFR5cGUiLCJnZXQiLCJpbmNsdWRlcyIsImRhdGEiLCJqc29uIiwiY29ubmVjdGlvbkVycm9yIiwiaXNDb25uZWN0aW9uRXJyb3IiLCJyZXF1ZXN0Rm9ybURhdGEiLCJmb3JtRGF0YSIsIm1ldGhvZCIsImJvZHkiLCJjYXRjaCIsImFwaUNsaWVudCIsInByb3BlcnRpZXMiLCJnZXRBbGwiLCJtb2NrIiwiZ2V0QWxsRm9yQWRtaW4iLCJhdXRoSGVhZGVycyIsImdldEJ5SWQiLCJnZXRNeVByb3BlcnRpZXMiLCJjcmVhdGUiLCJpbWFnZXMiLCJyZXN1bHQiLCJwcm9wZXJ0eUlkIiwiRm9ybURhdGEiLCJpbnB1dEJsb2IiLCJCbG9iIiwic3RyaW5naWZ5IiwidHlwZSIsImFwcGVuZCIsImZvckVhY2giLCJmaWxlIiwidXBkYXRlIiwicGFyc2VkIiwic3VjY2VzcyIsImRlbGV0ZSIsImFwcHJvdmUiLCJpc0FwcHJvdmVkIiwiaGlkZSIsImlzSGlkZGVuIiwic3VzcGVuZCIsInJlYXNvbiIsInJldm9rZVN1c3BlbnNpb24iLCJzdWJtaXRGb3JBcHByb3ZhbCIsImNhbmNlbEFwcHJvdmFsUmVxdWVzdCIsInByZWRpY3RQcmljZSIsImNoZWNrSW5EYXRlIiwiY2hlY2tPdXREYXRlIiwicHJlZGljdGVkUHJpY2VNYWQiLCJwcmVkaWN0ZWRQcmljZVVzZCIsImNvbmZpZGVuY2VJbnRlcnZhbExvd2VyIiwiY29uZmlkZW5jZUludGVydmFsVXBwZXIiLCJjaXR5Iiwic2Vhc29uIiwibW9kZWxWZXJzaW9uIiwicHJlZGljdGlvblRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImN1cnJlbnRQcmljZU1hZCIsInByaWNlRGlmZmVyZW5jZVBlcmNlbnQiLCJyZWNvbW1lbmRhdGlvbiIsInJpc2siLCJnZXRUZW5hbnRSaXNrU2NvcmUiLCJ0ZW5hbnRJZCIsImNvbnNvbGUiLCJyZWNvbW1lbmRhdGlvbnMiLCJnZXRGb3JUZW5hbnQiLCJtYXhSZXN1bHRzIiwiZ2V0U2ltaWxhciIsInZlcmlmaWNhdGlvblJlcXVlc3RzIiwiZ2V0QnlTdGF0dXMiLCJkZXNjcmlwdGlvbiIsInJlamVjdCIsInByb3BlcnR5VHlwZXMiLCJ1c2VycyIsImdldE1lIiwiZmlyc3ROYW1lIiwibGFzdE5hbWUiLCJlbWFpbCIsInBob25lTnVtYmVyIiwic2NvcmUiLCJhbGxVc2VycyIsImZpbmQiLCJ1IiwicHJvZmlsZVBpY3R1cmUiLCJiaXJ0aGRheSIsIndhbGxldEFkZHJlc3MiLCJlbmFibGVkIiwiZXJyIiwidXBkYXRlTWUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInVwZGF0ZVByb2ZpbGVQaWN0dXJlIiwiY2hhbmdlUGFzc3dvcmQiLCJjdXJyZW50UGFzc3dvcmQiLCJuZXdQYXNzd29yZCIsImRlbGV0ZVByb2ZpbGVQaWN0dXJlIiwiYmVjb21lSG9zdCIsImVuYWJsZVVzZXIiLCJkaXNhYmxlVXNlciIsImFkZEFkbWluUm9sZSIsInJlbW92ZUFkbWluUm9sZSIsImFkZEhvc3RSb2xlQnlBZG1pbiIsInJlbW92ZUhvc3RSb2xlIiwiYXV0aCIsInJlZ2lzdGVyIiwic2V0VGltZW91dCIsInJlcXVlc3RCb2R5IiwicGFzc3dvcmQiLCJyb2xlIiwibG9naW4iLCJzZXRBdXRoIiwic2V0SXRlbSIsImdldFRva2VuIiwiZ2V0VXNlciIsImNsZWFyQXV0aCIsInJlbW92ZUl0ZW0iLCJoYXNSb2xlIiwidmVyaWZ5IiwidmVyaWZpY2F0aW9uQ29kZSIsInJlc2VuZFZlcmlmaWNhdGlvbkNvZGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJmb3Jnb3RQYXNzd29yZCIsInZlcmlmeVJlc2V0VG9rZW4iLCJ2YWxpZCIsInJlc2V0UGFzc3dvcmQiLCJ2ZXJpZnlSZXNldENvZGUiLCJjb2RlIiwicmVzZXRQYXNzd29yZFdpdGhDb2RlIiwiYm9va2luZ3MiLCJwYXJzZUludCIsIm51bWJlck9mR3Vlc3RzIiwicmVxdWVzdGVkUHJpY2UiLCJyZXNwb25zZURhdGEiLCJnZXRCeVRlbmFudElkIiwiZ2V0Q3VycmVudEJvb2tpbmciLCJnZXRQZW5kaW5nQm9va2luZ3MiLCJnZXRBd2FpdGluZ1BheW1lbnRCb29raW5ncyIsImdldFByb3BlcnR5SW5mbyIsIm93bmVySWQiLCJwcmljZVBlck5pZ2h0IiwiaXNOZWdvdGlhYmxlIiwiZGlzY291bnRFbmFibGVkIiwiZ2V0TGFzdEJvb2tpbmdJZCIsImJvb2tpbmdJZCIsImVycm9yQ29kZSIsInRlbmFudENoZWNrb3V0Iiwib3duZXJDb25maXJtQ2hlY2tvdXQiLCJtYXJrQXNDaGVja2VkT3V0IiwiZ2V0Q3VycmVudEJvb2tpbmdzQnlPd25lciIsImdldFBlbmRpbmdOZWdvdGlhdGlvbnMiLCJhY2NlcHROZWdvdGlhdGlvbiIsInJlamVjdE5lZ290aWF0aW9uIiwiZ2V0QnlPd25lcklkIiwiZ2V0Q29uZmlybWVkQm9va2luZ3NCeU93bmVyIiwiZ2V0Q29uZmlybWVkQm9va2luZ3NCeVByb3BlcnR5IiwicmVwb3J0RGlzcHV0ZSIsInBheW1lbnRzIiwiY3JlYXRlSW50ZW50IiwicmVmZXJlbmNlSWQiLCJ0byIsInZhbHVlIiwiY2hhaW5JZCIsInRvdGFsQW1vdW50V2VpIiwiZ2V0Qm9va2luZ0RldGFpbHMiLCJ0b3RhbFByaWNlIiwicHJvcGVydHlUaXRsZSIsInByb3BlcnR5UHJpY2UiLCJvd25lcldhbGxldEFkZHJlc3MiLCJjdXJyZW50VXNlcklkIiwidXNlckZpcnN0TmFtZSIsInVzZXJMYXN0TmFtZSIsInVzZXJFbWFpbCIsInVzZXJXYWxsZXRBZGRyZXNzIiwiZSIsInVwZGF0ZVdhbGxldEFkZHJlc3MiLCJ1cGRhdGVUcmFuc2FjdGlvbkhhc2giLCJ0eEhhc2giLCJnZXRUcmFuc2FjdGlvblN0YXR1cyIsImJsb2NrTnVtYmVyIiwiY29tcGxldGVCb29raW5nIiwiZXJyb3JUZXh0IiwicmVjbGFtYXRpb25zIiwiY29tcGxhaW5hbnRSb2xlIiwicmVjbGFtYXRpb25UeXBlIiwidGl0bGUiLCJpbWFnZSIsImdldE15Q29tcGxhaW50cyIsImdldENvbXBsYWludHNBZ2FpbnN0TWUiLCJ1cGxvYWRBdHRhY2htZW50cyIsInJlY2xhbWF0aW9uSWQiLCJmaWxlcyIsImdldEJ5Qm9va2luZ0lkQW5kQ29tcGxhaW5hbnQiLCJjb21wbGFpbmFudElkIiwiZ2V0QXR0YWNobWVudHMiLCJnZXRVc2VyUGhvbmVOdW1iZXIiLCJhZG1pblJlY2xhbWF0aW9ucyIsInVwZGF0ZVNldmVyaXR5Iiwic2V2ZXJpdHkiLCJyZXZpZXciLCJyZXNvbHV0aW9uTm90ZXMiLCJhcHByb3ZlZCIsInJlamVjdGlvbk5vdGVzIiwiZ2V0U3RhdGlzdGljcyIsInRvdGFsIiwib3BlbiIsImluUmV2aWV3IiwicmVzb2x2ZWQiLCJyZWplY3RlZCIsIm1hcmtldFRyZW5kcyIsImdldEFsbENpdGllcyIsInBlcmlvZE1vbnRocyIsInRyZW5kcyIsImluc2lnaHRzIiwiZ2V0Q2l0eVRyZW5kcyIsImRhdGFfcG9pbnRzIiwiZ2V0SW5zaWdodHMiLCJhcGlCYXNlVXJsIiwiYXBpVmVyc2lvbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/services/api.ts\n"));

/***/ })

});