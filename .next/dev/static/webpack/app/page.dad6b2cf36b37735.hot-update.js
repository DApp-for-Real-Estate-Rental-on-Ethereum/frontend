"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/services/api.ts":
/*!*****************************!*\
  !*** ./lib/services/api.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiBaseUrl: () => (/* binding */ apiBaseUrl),\n/* harmony export */   apiClient: () => (/* binding */ apiClient),\n/* harmony export */   apiVersion: () => (/* binding */ apiVersion)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n/**\n * API Service Layer\n *\n * Centralized API communication service that handles:\n * - Base URL configuration from environment variables\n * - Authentication headers (X-User-Id, X-User-Roles)\n * - Request/response interceptors\n * - Error handling\n *\n * Usage:\n * import { apiClient } from '@/lib/services/api'\n * const properties = await apiClient.properties.getAll()\n *\n * Environment Variables (in .env.local):\n * - NEXT_PUBLIC_API_BASE_URL: Backend API base URL (e.g., http://localhost:8080)\n * - NEXT_PUBLIC_API_VERSION: API version path (default: v1)\n */ // Configuration from environment variables\n// Use API Gateway (port 8090) as the single entry point for all services\n// If GATEWAY_URL is not set, fall back to individual service URLs for backward compatibility\nconst GATEWAY_URL = process.env.NEXT_PUBLIC_GATEWAY_URL || \"http://localhost:8090\";\nconst USE_GATEWAY = process.env.NEXT_PUBLIC_USE_GATEWAY !== \"false\" // Default to true\n;\n// Fallback URLs for individual services (used if USE_GATEWAY is false)\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || \"http://localhost:8082\";\nconst PROPERTY_API_BASE_URL = process.env.NEXT_PUBLIC_PROPERTY_API_BASE_URL || \"http://localhost:8081\";\nconst BOOKING_API_BASE_URL = USE_GATEWAY ? GATEWAY_URL : process.env.NEXT_PUBLIC_BOOKING_API_BASE_URL || \"http://localhost:8083\";\nconst PAYMENT_API_BASE_URL = USE_GATEWAY ? GATEWAY_URL : process.env.NEXT_PUBLIC_PAYMENT_API_BASE_URL || \"http://localhost:8085\";\nconst RECLAMATION_API_BASE_URL = process.env.NEXT_PUBLIC_RECLAMATION_API_BASE_URL || \"http://localhost:8091\";\nconst API_VERSION = process.env.NEXT_PUBLIC_API_VERSION || \"v1\";\nconst AUTH_TOKEN_KEY = process.env.NEXT_PUBLIC_AUTH_STORAGE_KEY || \"derent5_auth_token\";\nconst USER_DATA_KEY = process.env.NEXT_PUBLIC_USER_STORAGE_KEY || \"derent5_user_data\";\n// USE_MOCK_API is true if explicitly set to \"true\", otherwise false (use real API)\nconst USE_MOCK_API = false // process.env.NEXT_PUBLIC_USE_MOCK_API === \"true\"\n;\n// Only import mock API if needed (tree-shake when not used)\nlet mockApiClient = null;\nasync function getMockApi() {\n    if (!mockApiClient) {\n        throw new Error(\"Mock API has been removed\");\n    }\n    return mockApiClient;\n}\n/**\n * Decode JWT token to extract userId from subject\n */ function decodeJWT(token) {\n    try {\n        // JWT format: header.payload.signature\n        const parts = token.split(\".\");\n        if (parts.length !== 3) return null;\n        // Decode payload (base64url)\n        const payload = parts[1];\n        const decoded = JSON.parse(atob(payload.replace(/-/g, \"+\").replace(/_/g, \"/\")));\n        return {\n            userId: decoded.sub || decoded.subject,\n            roles: decoded.roles || []\n        };\n    } catch (error) {\n        return null;\n    }\n}\n/**\n * Get authentication headers from localStorage\n * Used for all API requests that require user context\n */ function getAuthHeaders() {\n    // Only run in browser\n    if (false) {}\n    const token = localStorage.getItem(AUTH_TOKEN_KEY);\n    if (!token) {\n        return {};\n    }\n    // Try to get userId from JWT token first\n    const decoded = decodeJWT(token);\n    const userId = decoded?.userId;\n    // Fallback to user data from localStorage\n    const userData = localStorage.getItem(USER_DATA_KEY);\n    let finalUserId = userId;\n    let roles = decoded?.roles || [];\n    if (userData) {\n        try {\n            const user = JSON.parse(userData);\n            finalUserId = finalUserId || user.id || \"\";\n            roles = roles.length > 0 ? roles : user.roles || [];\n        } catch (error) {\n        // Failed to parse user data\n        }\n    }\n    // Ensure userId is always a string (convert number to string if needed)\n    const userIdString = finalUserId ? String(finalUserId) : \"\";\n    const headers = {\n        \"X-User-Id\": userIdString,\n        \"X-User-Roles\": roles.join(\",\"),\n        ...token && {\n            Authorization: `Bearer ${token}`\n        }\n    };\n    return headers;\n}\n/**\n * Helper function to get the correct base URL for a service\n * Uses Gateway if enabled, otherwise falls back to individual service URLs\n */ function getServiceUrl(service) {\n    if (USE_GATEWAY) {\n        // All services go through the Gateway\n        return GATEWAY_URL;\n    }\n    // Fallback to individual service URLs\n    switch(service){\n        case 'auth':\n        case 'users':\n            return API_BASE_URL;\n        case 'properties':\n            return PROPERTY_API_BASE_URL;\n        case 'bookings':\n            return BOOKING_API_BASE_URL;\n        case 'payments':\n            return PAYMENT_API_BASE_URL;\n        case 'reclamations':\n        case 'admin-reclamations':\n            return RECLAMATION_API_BASE_URL;\n        default:\n            return API_BASE_URL;\n    }\n}\n/**\n * Build full URL with base and version\n * For Gateway, path already includes /api/v1/..., so we don't add it again\n */ function buildUrl(path, service = 'users') {\n    const baseUrl = getServiceUrl(service);\n    if (USE_GATEWAY) {\n        // Gateway routes preserve the full path\n        // Path should already include /api/v1/... or /api/... prefix\n        // If path doesn't start with /api, add the appropriate prefix based on service\n        if (path.startsWith('/api/')) {\n            return `${baseUrl}${path}`;\n        }\n        // Add appropriate prefix based on service\n        if (service === 'auth' || service === 'users') {\n            return `${baseUrl}/api/v1${path}`;\n        } else if (service === 'properties') {\n            return `${baseUrl}/api/v1${path}`;\n        } else if (service === 'bookings') {\n            return `${baseUrl}/api${path}`;\n        } else if (service === 'payments') {\n            return `${baseUrl}/api${path}`;\n        } else if (service === 'reclamations' || service === 'admin-reclamations') {\n            return `${baseUrl}/api${path}`;\n        }\n        return `${baseUrl}${path}`;\n    }\n    // For direct service calls, add version prefix\n    const basePath = `/api/${API_VERSION}`;\n    return `${baseUrl}${basePath}${path}`;\n}\n/**\n * Generic fetch wrapper with error handling\n */ async function request(path, options = {}) {\n    const { requiresAuth = true, service = 'users', ...fetchOptions } = options;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        ...requiresAuth && getAuthHeaders(),\n        ...fetchOptions.headers\n    };\n    const url = buildUrl(path, service);\n    try {\n        const response = await fetch(url, {\n            ...fetchOptions,\n            headers\n        });\n        if (!response.ok) {\n            let errorData = {};\n            let responseText = \"\";\n            try {\n                responseText = await response.text();\n                if (responseText) {\n                    try {\n                        errorData = JSON.parse(responseText);\n                    } catch (parseError) {\n                        // If JSON parsing fails, use the raw text\n                        errorData = {\n                            message: responseText,\n                            raw: responseText\n                        };\n                    }\n                }\n            } catch (textError) {\n                errorData = {\n                    message: `Failed to read response: ${textError}`\n                };\n            }\n            // If errorData is still empty, create a default error\n            if (Object.keys(errorData).length === 0) {\n                errorData = {\n                    message: `HTTP ${response.status}: ${response.statusText}`,\n                    status: response.status,\n                    statusText: response.statusText\n                };\n            }\n            // Extract error message from ErrorResponse format (used by user-service)\n            // ErrorResponse has: timestamp, status, error, message, path\n            const errorMessage = errorData.message || // ErrorResponse.message\n            errorData.error || // ErrorResponse.error (error title)\n            errorData.detail || // Standard Spring error format\n            errorData.raw || // Raw response text if JSON parsing failed\n            (Array.isArray(errorData.errors) ? errorData.errors.join(\", \") : null) || // Validation errors array\n            (typeof errorData === 'string' ? errorData : null) || `API Error: ${response.status} ${response.statusText}`;\n            const apiError = new Error(errorMessage);\n            apiError.status = response.status;\n            apiError.errorData = errorData;\n            apiError.responseText = responseText;\n            throw apiError;\n        }\n        // Check if response has content\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.includes(\"application/json\")) {\n            const data = await response.json();\n            return data;\n        } else {\n            // If no JSON content, return empty object for successful responses\n            const text = await response.text();\n            if (text) {\n                // Try to parse as JSON, if fails return text as message\n                try {\n                    return JSON.parse(text);\n                } catch  {\n                    return {\n                        message: text\n                    };\n                }\n            }\n            return {};\n        }\n    } catch (error) {\n        // Check if it's a connection error\n        if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n            const connectionError = new Error(`Cannot connect to backend server at ${API_BASE_URL}. Please make sure the backend is running.`);\n            connectionError.isConnectionError = true;\n            throw connectionError;\n        }\n        throw error;\n    }\n}\n/**\n * Multipart form data request for file uploads\n */ async function requestFormData(path, formData, options = {}) {\n    const { requiresAuth = true, service = 'users', ...fetchOptions } = options;\n    const headers = {\n        ...requiresAuth && getAuthHeaders(),\n        ...fetchOptions.headers\n    };\n    // Don't set Content-Type for FormData - browser will set it with boundary\n    delete headers[\"Content-Type\"];\n    const url = buildUrl(path, service);\n    try {\n        const response = await fetch(url, {\n            method: \"POST\",\n            ...fetchOptions,\n            headers,\n            body: formData\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(errorData.message || `API Error: ${response.status}`);\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        throw error;\n    }\n}\n/**\n * API Client - Organized by resource\n */ const apiClient = {\n    // ==================== PROPERTIES ====================\n    properties: {\n        async getAll () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getAll();\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async getAllForAdmin () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getAll();\n            }\n            // Use Gateway or property-service URL for admin endpoint\n            const url = buildUrl(\"/properties/admin/all\", 'properties');\n            const authHeaders = getAuthHeaders();\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...authHeaders\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    const errorMessage = errorData.error || errorData.message || `API Error: ${response.status}`;\n                    throw new Error(errorMessage);\n                }\n                const data = await response.json();\n                // Ensure data is an array\n                if (!Array.isArray(data)) {\n                    // If it's an error object, throw it\n                    if (data.error || data.message) {\n                        throw new Error(data.error || data.message || \"Invalid response format\");\n                    }\n                    // Otherwise return empty array\n                    return [];\n                }\n                return data;\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async getById (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getById(id);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async getMyProperties () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.getAll();\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/my-properties`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    const errorMessage = errorData.error || errorData.message || `API Error: ${response.status}`;\n                    throw new Error(errorMessage);\n                }\n                const data = await response.json();\n                // Ensure data is an array\n                if (!Array.isArray(data)) {\n                    // If it's an error object, throw it\n                    if (data.error || data.message) {\n                        throw new Error(data.error || data.message || \"Invalid response format\");\n                    }\n                    // Otherwise return empty array\n                    return [];\n                }\n                return data;\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async create (data, images) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                const result = await mock.properties.create(data, images);\n                return {\n                    propertyId: result.id,\n                    id: result.id\n                };\n            }\n            const formData = new FormData();\n            // Create a Blob with JSON content type for the input part\n            // Spring's @RequestPart expects Content-Type: application/json for JSON parts\n            const inputBlob = new Blob([\n                JSON.stringify(data)\n            ], {\n                type: \"application/json\"\n            });\n            formData.append(\"input\", inputBlob);\n            images.forEach((file)=>{\n                formData.append(\"images\", file);\n            });\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties`;\n            const headers = {\n                ...getAuthHeaders()\n            };\n            // Don't set Content-Type header - let browser set it with boundary for multipart/form-data\n            try {\n                const response = await fetch(url, {\n                    method: \"POST\",\n                    headers,\n                    body: formData\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                const result = await response.json();\n                return result;\n            } catch (error) {\n                throw error;\n            }\n        },\n        async update (id, data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.update(id, data);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PUT\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify(data)\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                // Backend returns \"Property updated\" as plain text, not JSON\n                const responseText = await response.text();\n                try {\n                    const parsed = JSON.parse(responseText);\n                    return parsed;\n                } catch  {\n                    // If it's not JSON, return success object\n                    return {\n                        success: true\n                    };\n                }\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async delete (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.delete(id);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"DELETE\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to property-service backend at ${PROPERTY_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        async approve (id, isApproved) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.approve(id, isApproved);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/approve`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify({\n                        isApproved\n                    })\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        /**\n     * Hide property\n     */ async hide (id, isHidden) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return {\n                    success: true\n                };\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/hide`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify({\n                        isHidden\n                    })\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async suspend (id, reason) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.suspend(id, reason);\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/suspend`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    },\n                    body: JSON.stringify({\n                        reason\n                    })\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async revokeSuspension (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.suspend(id, \"\") // Mock\n                ;\n            }\n            // Use property-service URL for property endpoints\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/revoke-suspension`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async submitForApproval (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.properties.approve(id, true);\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/submit-for-approval`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        async cancelApprovalRequest (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return {\n                    success: true\n                };\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${id}/cancel-approval-request`;\n            try {\n                const response = await fetch(url, {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return {\n                    success: true\n                };\n            } catch (error) {\n                throw error;\n            }\n        },\n        /**\n     * Get AI-powered price suggestion for a property and date range.\n     * This calls property-service, which forwards the request to the pricing model API.\n     */ async predictPrice (propertyId, checkInDate, checkOutDate) {\n            if (USE_MOCK_API) {\n                // Lightweight mock for UI development\n                return {\n                    predictedPriceMad: 430,\n                    predictedPriceUsd: 43,\n                    confidenceIntervalLower: 380,\n                    confidenceIntervalUpper: 480,\n                    city: \"casablanca\",\n                    season: \"summer\",\n                    modelVersion: \"1.0\",\n                    predictionTimestamp: new Date().toISOString(),\n                    currentPriceMad: 400,\n                    priceDifferencePercent: 7.5,\n                    recommendation: \"INCREASE\"\n                };\n            }\n            const url = `${PROPERTY_API_BASE_URL}/api/${API_VERSION}/properties/${propertyId}/predict-price`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    propertyId,\n                    checkInDate,\n                    checkOutDate\n                })\n            });\n            const data = await response.json().catch(()=>({}));\n            if (!response.ok) {\n                const message = data?.message || data?.error || (typeof data === \"string\" ? data : null) || `Failed to get price suggestion: ${response.status}`;\n                throw new Error(message);\n            }\n            return data;\n        }\n    },\n    // ==================== TENANT RISK ====================\n    risk: {\n        getTenantRiskScore: async (tenantId)=>{\n            try {\n                // Use local Next.js proxy\n                const response = await fetch(`/api/tenant-risk/${tenantId}`, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    }\n                });\n                if (!response.ok) {\n                    throw new Error(`ML API Error: ${response.status} ${response.statusText}`);\n                }\n                return response.json();\n            } catch (error) {\n                console.error(\"Error fetching risk score:\", error);\n                throw error;\n            }\n        }\n    },\n    recommendations: {\n        getForTenant: async (tenantId, maxResults = 3)=>{\n            try {\n                const response = await fetch(`/api/recommendations/tenant/${tenantId}?max_results=${maxResults}`);\n                if (!response.ok) throw new Error(\"Failed to fetch recommendations\");\n                return response.json();\n            } catch (error) {\n                console.error(\"Error fetching recommendations:\", error);\n                throw error;\n            }\n        },\n        getSimilar: async (propertyId, maxResults = 3)=>{\n            try {\n                const response = await fetch(`/api/recommendations/similar/${propertyId}?max_results=${maxResults}`);\n                if (!response.ok) throw new Error(\"Failed to fetch similar properties\");\n                return response.json();\n            } catch (error) {\n                console.error(\"Error fetching similar properties:\", error);\n                throw error;\n            }\n        }\n    },\n    // ==================== VERIFICATION REQUESTS ====================\n    verificationRequests: {\n        async getAll () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.getAll();\n            }\n            return request(\"/verification-requests\");\n        },\n        async getByStatus (status) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.getByStatus(status);\n            }\n            return request(`/verification-requests/by-status/${status}`);\n        },\n        async create (propertyId, description) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.create(propertyId, description);\n            }\n            return request(\"/verification-requests\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    propertyId,\n                    description\n                })\n            });\n        },\n        async approve (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.approve(id);\n            }\n            return request(`/verification-requests/${id}/approve`, {\n                method: \"PATCH\"\n            });\n        },\n        async reject (id, reason) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.verificationRequests.reject(id, reason);\n            }\n            return request(`/verification-requests/${id}/reject`, {\n                method: \"PATCH\",\n                body: JSON.stringify({\n                    reason\n                })\n            });\n        }\n    },\n    // ==================== PROPERTY TYPES ====================\n    propertyTypes: {\n        async getAll () {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.propertyTypes.getAll();\n            }\n            return request(\"/property-types\", {\n                requiresAuth: false\n            });\n        },\n        async getById (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.propertyTypes.getById(id);\n            }\n            return request(`/property-types/${id}`, {\n                requiresAuth: false\n            });\n        }\n    },\n    // ==================== USERS ====================\n    users: {\n        async getMe () {\n            if (USE_MOCK_API) {\n                // Mock user data for development\n                return {\n                    firstName: \"Mock\",\n                    lastName: \"User\",\n                    email: \"mock@example.com\"\n                };\n            }\n            return request(\"/users/me\", {\n                method: \"GET\",\n                requiresAuth: true\n            });\n        },\n        /**\n     * Get user information by ID (for getting phone number, etc.)\n     */ async getById (userId) {\n            if (USE_MOCK_API) {\n                return {\n                    firstName: \"Mock\",\n                    lastName: \"User\",\n                    email: \"mock@example.com\",\n                    phoneNumber: 1234567890,\n                    score: 100\n                };\n            }\n            // Try to get from admin endpoint first (if user is admin) for more details\n            try {\n                const allUsers = await this.getAllForAdmin();\n                const user = allUsers.find((u)=>String(u.id) === String(userId));\n                if (user) {\n                    return {\n                        firstName: user.firstName,\n                        lastName: user.lastName,\n                        email: user.email,\n                        profilePicture: user.profilePicture,\n                        birthday: user.birthday,\n                        phoneNumber: user.phoneNumber,\n                        walletAddress: user.walletAddress,\n                        roles: user.roles,\n                        score: user.score,\n                        enabled: user.enabled\n                    };\n                }\n            } catch (err) {\n            // If admin endpoint fails, fallback to regular endpoint\n            }\n            // Fallback to regular endpoint\n            return request(`/users/${userId}`, {\n                method: \"GET\",\n                requiresAuth: true\n            });\n        },\n        async updateMe (data) {\n            if (USE_MOCK_API) {\n                // Mock update\n                return Promise.resolve();\n            }\n            return request(\"/users/me\", {\n                method: \"PUT\",\n                body: JSON.stringify(data),\n                requiresAuth: true\n            });\n        },\n        async updateProfilePicture (file) {\n            if (USE_MOCK_API) {\n                return {\n                    url: \"/placeholder-user.jpg\"\n                };\n            }\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            const headers = getAuthHeaders();\n            // Remove Content-Type header to let browser set it with boundary for multipart/form-data\n            delete headers[\"Content-Type\"];\n            const url = buildUrl(\"/users/me/profile-picture\");\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers,\n                body: formData\n            });\n            if (!response.ok) {\n                let errorData = {};\n                let responseText = \"\";\n                try {\n                    responseText = await response.text();\n                    if (responseText) {\n                        try {\n                            errorData = JSON.parse(responseText);\n                        } catch  {\n                            errorData = {\n                                message: responseText,\n                                raw: responseText\n                            };\n                        }\n                    }\n                } catch  {\n                    errorData = {\n                        message: `HTTP ${response.status}: ${response.statusText}`\n                    };\n                }\n                const errorMessage = errorData.message || errorData.error || errorData.raw || `API Error: ${response.status} ${response.statusText}`;\n                const apiError = new Error(errorMessage);\n                apiError.status = response.status;\n                apiError.errorData = errorData;\n                throw apiError;\n            }\n            const text = await response.text();\n            return {\n                url: text\n            } // Backend returns URL as plain text\n            ;\n        },\n        async changePassword (currentPassword, newPassword) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Password changed successfully\"\n                };\n            }\n            return request(\"/users/me/change-password\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    currentPassword,\n                    newPassword\n                })\n            });\n        },\n        async deleteProfilePicture () {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(\"/users/me/profile-picture\", {\n                method: \"DELETE\",\n                requiresAuth: true\n            });\n        },\n        async becomeHost () {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(\"/users/me/become-host\", {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async getAllForAdmin () {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            return request(\"/users/admin/all\", {\n                method: \"GET\",\n                requiresAuth: true\n            });\n        },\n        async enableUser (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/enable`, {\n                method: \"POST\",\n                body: JSON.stringify({}),\n                requiresAuth: true\n            });\n        },\n        async disableUser (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/disable`, {\n                method: \"POST\",\n                body: JSON.stringify({}),\n                requiresAuth: true\n            });\n        },\n        async addAdminRole (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/add-admin-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async removeAdminRole (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/remove-admin-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async addHostRoleByAdmin (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/add-host-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        },\n        async removeHostRole (userId) {\n            if (USE_MOCK_API) {\n                return Promise.resolve();\n            }\n            return request(`/users/admin/${userId}/remove-host-role`, {\n                method: \"POST\",\n                requiresAuth: true\n            });\n        }\n    },\n    // ==================== AUTHENTICATION ====================\n    auth: {\n        async register (data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                // Mock registration - simulate delay\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"User registered successfully\"\n                };\n            }\n            try {\n                const requestBody = {\n                    firstName: data.firstName,\n                    lastName: data.lastName,\n                    email: data.email,\n                    password: data.password,\n                    birthday: data.birthday,\n                    phoneNumber: data.phoneNumber,\n                    ...data.role && {\n                        role: data.role\n                    }\n                };\n                return await request(\"/auth/register\", {\n                    method: \"POST\",\n                    body: JSON.stringify(requestBody),\n                    requiresAuth: false\n                });\n            } catch (error) {\n                // If connection fails, throw with helpful message\n                if (error?.isConnectionError) {\n                    throw new Error(\"Backend server is not available. Please make sure the user-service is running on port 8080.\");\n                }\n                throw error;\n            }\n        },\n        async login (email, password) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                // Mock login - would use mock data\n                throw new Error(\"Mock login not implemented - use useAuth hook\");\n            }\n            return request(\"/auth/login\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    password\n                }),\n                requiresAuth: false\n            });\n        },\n        setAuth (token, user) {\n            if (true) {\n                localStorage.setItem(AUTH_TOKEN_KEY, token);\n                localStorage.setItem(USER_DATA_KEY, JSON.stringify(user));\n            }\n        },\n        getToken () {\n            if (false) {}\n            return localStorage.getItem(AUTH_TOKEN_KEY);\n        },\n        getUser () {\n            if (false) {}\n            const userData = localStorage.getItem(USER_DATA_KEY);\n            return userData ? JSON.parse(userData) : null;\n        },\n        clearAuth () {\n            if (true) {\n                localStorage.removeItem(AUTH_TOKEN_KEY);\n                localStorage.removeItem(USER_DATA_KEY);\n            }\n        },\n        hasRole (role) {\n            const user = this.getUser();\n            return user?.roles.includes(role) ?? false;\n        },\n        async verify (email, verificationCode) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"User verified successfully\"\n                };\n            }\n            return request(\"/auth/verify\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    verificationCode\n                }),\n                requiresAuth: false\n            });\n        },\n        async resendVerificationCode (email) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"Verification Code resent successfully\"\n                };\n            }\n            return request(`/auth/resend?email=${encodeURIComponent(email)}`, {\n                method: \"POST\",\n                requiresAuth: false\n            });\n        },\n        async forgotPassword (email) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return;\n            }\n            return request(\"/auth/forgot-password\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email\n                }),\n                requiresAuth: false\n            });\n        },\n        async verifyResetToken (token) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    valid: true\n                };\n            }\n            return request(\"/auth/verify-reset-token\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    token\n                }),\n                requiresAuth: false\n            });\n        },\n        async resetPassword (token, password) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return;\n            }\n            return request(\"/auth/reset-password\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    token,\n                    password\n                }),\n                requiresAuth: false\n            });\n        },\n        async verifyResetCode (email, code) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    valid: true\n                };\n            }\n            return request(\"/auth/verify-reset-code\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    code\n                }),\n                requiresAuth: false\n            });\n        },\n        async resetPasswordWithCode (email, code, newPassword) {\n            if (USE_MOCK_API) {\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                return {\n                    message: \"Password reset successfully\"\n                };\n            }\n            return request(\"/auth/reset-password-with-code\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                    email,\n                    code,\n                    newPassword\n                }),\n                requiresAuth: false\n            });\n        }\n    },\n    bookings: {\n        /**\n     * Get all bookings for admin\n     */ async getAllForAdmin () {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/admin/all`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `Failed to fetch bookings: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\")) {\n                    const connectionError = new Error(`Cannot connect to booking-service backend at ${BOOKING_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        /**\n     * Create a booking request\n     * Sends booking data to booking-service via RabbitMQ\n     */ async create (data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.create?.(data) || {\n                    status: \"accepted\",\n                    message: \"Booking request sent\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/request`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    userId: typeof data.userId === \"string\" ? parseInt(data.userId) : data.userId,\n                    propertyId: data.propertyId,\n                    checkInDate: data.checkInDate,\n                    checkOutDate: data.checkOutDate,\n                    numberOfGuests: data.numberOfGuests,\n                    requestedPrice: data.requestedPrice\n                })\n            });\n            const responseData = await response.json();\n            if (!response.ok) {\n                // If status is \"rejected\", return the response data instead of throwing\n                if (responseData.status === \"rejected\") {\n                    return responseData;\n                }\n                throw new Error(responseData.message || `Failed to create booking: ${response.status}`);\n            }\n            return responseData;\n        },\n        /**\n     * Get booking by ID\n     */ async getById (id) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.getById?.(id) || null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                if (response.status === 404) {\n                    return null;\n                }\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch booking: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get bookings by tenant ID\n     */ async getByTenantId (tenantId) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.getByTenantId?.(tenantId) || [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings?tenantId=${tenantId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get current booking for a user\n     */ async getCurrentBooking (userId) {\n            if (USE_MOCK_API) {\n                // Mock: return null for now (no current booking)\n                return null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/current?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (response.status === 204 || response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch current booking: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get pending bookings (negotiations) for a user\n     */ async getPendingBookings (userId) {\n            if (USE_MOCK_API) {\n                // Mock: return empty array\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/pending?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch pending bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get awaiting payment bookings for a user\n     */ async getAwaitingPaymentBookings (userId) {\n            if (USE_MOCK_API) {\n                // Mock: return empty array\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/payment?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch awaiting payment bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get property info for booking (price, discount, negotiation)\n     */ async getPropertyInfo (propertyId) {\n            if (USE_MOCK_API) {\n                // Mock property info\n                return {\n                    id: propertyId,\n                    ownerId: 1,\n                    pricePerNight: 100,\n                    isNegotiable: false,\n                    discountEnabled: false\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/property/${propertyId}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `API Error: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                if (error?.message?.includes(\"Failed to fetch\") || error?.message?.includes(\"ERR_CONNECTION_REFUSED\") || error?.message?.includes(\"CORS\")) {\n                    const connectionError = new Error(`Cannot connect to booking-service backend at ${BOOKING_API_BASE_URL}. Please make sure the backend is running.`);\n                    connectionError.isConnectionError = true;\n                    throw connectionError;\n                }\n                throw error;\n            }\n        },\n        /**\n     * Get last booking ID (for polling after creation)\n     */ async getLastBookingId () {\n            if (USE_MOCK_API) {\n                return {\n                    bookingId: 1\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/booking-id`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n            if (response.status === 204 || response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                return null;\n            }\n            return response.json();\n        },\n        /**\n     * Update a booking\n     */ async update (id, data) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.update?.(id, data) || null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    checkInDate: data.checkInDate,\n                    checkOutDate: data.checkOutDate,\n                    numberOfGuests: data.numberOfGuests,\n                    requestedPrice: data.requestedPrice\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                const errorMessage = errorData.message || errorData.error || `Failed to update booking: ${response.status}`;\n                const error = new Error(errorMessage);\n                error.status = response.status;\n                error.errorCode = errorData.error;\n                throw error;\n            }\n            const result = await response.json();\n            return result;\n        },\n        /**\n     * Delete/Cancel a booking (by tenant)\n     */ async delete (id, userId) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.delete?.(id, userId);\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"DELETE\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to cancel booking: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Tenant checkout (changes status to TENANT_CHECKED_OUT)\n     */ async tenantCheckout (id, tenantId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Tenant checked out successfully\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}/checkout/tenant?userId=${tenantId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to checkout: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Owner confirm checkout (changes status to COMPLETED)\n     */ async ownerConfirmCheckout (id, ownerId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Checkout confirmed successfully\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}/checkout/owner?userId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to confirm checkout: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * @deprecated Use tenantCheckout() or ownerConfirmCheckout() instead\n     */ async markAsCheckedOut (id, userId) {\n            if (USE_MOCK_API) {\n                const mock = await getMockApi();\n                return mock.bookings?.markAsCheckedOut?.(id, userId) || null;\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${id}/checkout?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to mark as checked out: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get current bookings by owner (host)\n     */ async getCurrentBookingsByOwner (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/current/owner?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch current bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get pending negotiations by owner (host)\n     */ async getPendingNegotiations (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/negotiations?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch pending negotiations: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Accept negotiation (host)\n     */ async acceptNegotiation (bookingId, ownerId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Negotiation accepted\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${bookingId}/accept?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to accept negotiation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Reject negotiation (host)\n     */ async rejectNegotiation (bookingId, ownerId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Negotiation rejected\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${bookingId}/reject?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to reject negotiation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get all bookings by owner (host)\n     */ async getByOwnerId (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get confirmed bookings by owner (host)\n     */ async getConfirmedBookingsByOwner (ownerId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/confirmed/owner?ownerId=${ownerId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch confirmed bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get confirmed bookings by property ID\n     */ async getConfirmedBookingsByProperty (propertyId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/confirmed/property/${propertyId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch confirmed bookings: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Report dispute (host or tenant)\n     */ async reportDispute (bookingId, userId) {\n            if (USE_MOCK_API) {\n                return {\n                    message: \"Dispute reported\"\n                };\n            }\n            const url = `${BOOKING_API_BASE_URL}/api/bookings/${bookingId}/dispute?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || errorData.error || `Failed to report dispute: ${response.status}`);\n            }\n            return response.json();\n        }\n    },\n    /**\n   * Payment Service API\n   */ payments: {\n        /**\n     * Create payment intent\n     */ async createIntent (bookingId) {\n            if (USE_MOCK_API) {\n                return {\n                    referenceId: \"mock-ref-id\",\n                    to: \"0x1234567890123456789012345678901234567890\",\n                    value: \"1000000000000000000\",\n                    data: null,\n                    chainId: 31337,\n                    totalAmountWei: \"1000000000000000000\"\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/intent`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    bookingId\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to create payment intent: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get booking details for payment\n     */ async getBookingDetails (bookingId) {\n            if (USE_MOCK_API) {\n                return {\n                    bookingId,\n                    status: \"PENDING_PAYMENT\",\n                    totalPrice: 100.0,\n                    checkInDate: \"2025-12-01\",\n                    checkOutDate: \"2025-12-05\",\n                    propertyId: 1,\n                    propertyTitle: \"Mock Property\",\n                    propertyPrice: 20.0,\n                    ownerWalletAddress: \"0x1234567890123456789012345678901234567890\",\n                    userId: 1,\n                    currentUserId: 1,\n                    userFirstName: \"John\",\n                    userLastName: \"Doe\",\n                    userEmail: \"john@example.com\",\n                    userWalletAddress: null\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/booking/${bookingId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                let errorMessage = `Failed to fetch booking details: ${response.status}`;\n                try {\n                    const errorData = await response.json();\n                    // Backend returns { code, message } format\n                    errorMessage = errorData.message || errorData.code || errorMessage;\n                } catch (e) {\n                    // If response is not JSON, use status text\n                    errorMessage = response.statusText || errorMessage;\n                }\n                throw new Error(errorMessage);\n            }\n            return response.json();\n        },\n        /**\n     * Update wallet address\n     */ async updateWalletAddress (userId, walletAddress) {\n            if (USE_MOCK_API) {\n                return;\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/wallet-address`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    userId,\n                    walletAddress\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update wallet address: ${response.status}`);\n            }\n        },\n        /**\n     * Update transaction hash\n     */ async updateTransactionHash (bookingId, txHash) {\n            if (USE_MOCK_API) {\n                return;\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/booking/${bookingId}/tx-hash`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    txHash\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update transaction hash: ${response.status}`);\n            }\n        },\n        // Date modification removed - dates can only be changed from booking-service\n        /**\n     * Get transaction status\n     */ async getTransactionStatus (txHash) {\n            if (USE_MOCK_API) {\n                return {\n                    txHash,\n                    status: \"PENDING\",\n                    blockNumber: null,\n                    bookingId: null\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/tx/${txHash}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch transaction status: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Complete booking on blockchain (called by host when confirming checkout)\n     */ async completeBooking (bookingId) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\",\n                    message: \"Booking completed successfully on blockchain\"\n                };\n            }\n            const url = `${PAYMENT_API_BASE_URL}/api/payments/booking/${bookingId}/complete`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                let errorData = {};\n                let errorText = \"\";\n                try {\n                    errorText = await response.text();\n                    if (errorText) {\n                        try {\n                            errorData = JSON.parse(errorText);\n                        } catch  {\n                            errorData = {\n                                message: errorText\n                            };\n                        }\n                    }\n                } catch (e) {\n                    // If response is not JSON, use status text\n                    errorData = {\n                        message: response.statusText || `Server error: ${response.status}`\n                    };\n                }\n                const errorMessage = errorData.message || errorData.error || errorText || `Failed to complete booking: ${response.status}`;\n                throw new Error(errorMessage);\n            }\n            return response.json();\n        }\n    },\n    // ==================== RECLAMATIONS ====================\n    reclamations: {\n        /**\n     * Create a reclamation for a booking\n     */ async create (bookingId, userId, complainantRole, reclamationType, title, description, images) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\",\n                    message: \"Reclamation created successfully\"\n                };\n            }\n            // Use reclamation-service directly to support images\n            const formData = new FormData();\n            formData.append(\"bookingId\", String(bookingId));\n            formData.append(\"userId\", String(userId));\n            formData.append(\"complainantRole\", complainantRole);\n            formData.append(\"reclamationType\", reclamationType);\n            if (title) formData.append(\"title\", title);\n            if (description) formData.append(\"description\", description);\n            if (images && images.length > 0) {\n                images.forEach((image)=>{\n                    formData.append(\"files\", image);\n                });\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/create`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    ...getAuthHeaders()\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to create reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get all reclamations by complainant ID (my complaints)\n     */ async getMyComplaints (userId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/my-complaints?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch complaints: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get all reclamations against a user (complaints against me)\n     */ async getComplaintsAgainstMe (userId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/against-me?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch complaints: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Upload attachments (images) for a reclamation\n     */ async uploadAttachments (reclamationId, files) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const formData = new FormData();\n            files.forEach((file)=>{\n                formData.append(\"files\", file);\n            });\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}/attachments`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    ...getAuthHeaders()\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to upload attachments: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation by booking ID and complainant ID\n     */ async getByBookingIdAndComplainant (bookingId, complainantId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/booking/${bookingId}/complainant/${complainantId}`;\n            try {\n                const response = await fetch(url, {\n                    method: \"GET\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...getAuthHeaders()\n                    }\n                });\n                // 404 is expected when no reclamation exists - return null silently\n                if (response.status === 404) {\n                    return null;\n                }\n                if (!response.ok) {\n                    const errorData = await response.json().catch(()=>({}));\n                    throw new Error(errorData.message || `Failed to fetch reclamation: ${response.status}`);\n                }\n                return response.json();\n            } catch (error) {\n                // Silently handle 404 errors (no reclamation exists - this is normal)\n                if (error.message?.includes(\"404\") || error.message?.includes(\"Not Found\")) {\n                    return null;\n                }\n                throw error;\n            }\n        },\n        /**\n     * Get reclamation by ID\n     */ async getById (reclamationId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation attachments (images)\n     */ async getAttachments (reclamationId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}/attachments`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch attachments: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Delete a reclamation\n     */ async delete (reclamationId, userId) {\n            if (USE_MOCK_API) {\n                return;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}?userId=${userId}`;\n            const response = await fetch(url, {\n                method: \"DELETE\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to delete reclamation: ${response.status}`);\n            }\n        },\n        /**\n     * Update a reclamation (title, description, images)\n     */ async update (reclamationId, userId, title, description, images) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\",\n                    message: \"Reclamation updated successfully\"\n                };\n            }\n            const formData = new FormData();\n            formData.append(\"userId\", String(userId));\n            if (title) formData.append(\"title\", title);\n            if (description) formData.append(\"description\", description);\n            if (images && images.length > 0) {\n                images.forEach((image)=>{\n                    formData.append(\"files\", image);\n                });\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    ...getAuthHeaders()\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get user phone number\n     */ async getUserPhoneNumber (userId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/user/${userId}/phone`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch phone number: ${response.status}`);\n            }\n            const data = await response.json();\n            return data.phoneNumber || null;\n        }\n    },\n    // ==================== ADMIN RECLAMATIONS ====================\n    adminReclamations: {\n        /**\n     * Get all reclamations (admin only)\n     */ async getAll () {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamations: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamations by status\n     */ async getByStatus (status) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/status/${status}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamations: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation by ID\n     */ async getById (reclamationId) {\n            if (USE_MOCK_API) {\n                return null;\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/reclamations/${reclamationId}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (response.status === 404) {\n                return null;\n            }\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Update reclamation severity\n     */ async updateSeverity (reclamationId, severity) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/severity?severity=${severity}`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to update severity: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Review reclamation (move to IN_REVIEW)\n     */ async review (reclamationId) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/review`;\n            const response = await fetch(url, {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to review reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Resolve reclamation with penalty\n     */ async resolve (reclamationId, resolutionNotes, approved) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/resolve`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    resolutionNotes,\n                    approved\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to resolve reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Reject reclamation\n     */ async reject (reclamationId, rejectionNotes) {\n            if (USE_MOCK_API) {\n                return {\n                    status: \"success\"\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/reject`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                },\n                body: JSON.stringify({\n                    rejectionNotes\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to reject reclamation: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation attachments (images)\n     */ async getAttachments (reclamationId) {\n            if (USE_MOCK_API) {\n                return [];\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/${reclamationId}/attachments`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch attachments: ${response.status}`);\n            }\n            return response.json();\n        },\n        /**\n     * Get reclamation statistics\n     */ async getStatistics () {\n            if (USE_MOCK_API) {\n                return {\n                    total: 0,\n                    open: 0,\n                    inReview: 0,\n                    resolved: 0,\n                    rejected: 0\n                };\n            }\n            const url = `${RECLAMATION_API_BASE_URL}/api/admin/reclamations/statistics`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...getAuthHeaders()\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || `Failed to fetch statistics: ${response.status}`);\n            }\n            return response.json();\n        }\n    },\n    // ==================== TENANT RISK ====================\n    risk: {\n        async getTenantRiskScore (tenantId) {\n            if (USE_MOCK_API) return {\n                tenant_id: tenantId,\n                trust_score: 100,\n                risk_band: \"LOW\"\n            };\n            const response = await fetch(`/api/tenant-risk/${tenantId}`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n            if (!response.ok) throw new Error(`Failed to fetch risk score for ${tenantId}`);\n            return response.json();\n        }\n    },\n    // ==================== MARKET TRENDS ====================\n    marketTrends: {\n        async getAllCities (periodMonths = 12) {\n            if (USE_MOCK_API) return {\n                trends: [],\n                insights: []\n            };\n            const response = await fetch(`/api/market-trends/all-cities?period_months=${periodMonths}`);\n            if (!response.ok) throw new Error(\"Failed to fetch market trends\");\n            return response.json();\n        },\n        async getCityTrends (city, periodMonths = 12) {\n            if (USE_MOCK_API) return {\n                data_points: []\n            };\n            const response = await fetch(`/api/market-trends/city/${city}?period_months=${periodMonths}`);\n            if (!response.ok) throw new Error(`Failed to fetch trends for ${city}`);\n            return response.json();\n        },\n        async getInsights (city) {\n            if (USE_MOCK_API) return [];\n            const response = await fetch(`/api/market-trends/insights/${city}`);\n            if (!response.ok) throw new Error(`Failed to fetch insights for ${city}`);\n            return response.json();\n        }\n    }\n};\nconst apiBaseUrl = API_BASE_URL;\nconst apiVersion = API_VERSION;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zZXJ2aWNlcy9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBYUQsMkNBQTJDO0FBQzNDLHlFQUF5RTtBQUN6RSw2RkFBNkY7QUFDN0YsTUFBTUEsY0FBY0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyx1QkFBdUIsSUFBSTtBQUMzRCxNQUFNQyxjQUFjSCxPQUFPQSxDQUFDQyxHQUFHLENBQUNHLHVCQUF1QixLQUFLLFFBQVEsa0JBQWtCOztBQUV0Rix1RUFBdUU7QUFDdkUsTUFBTUMsZUFBZUwsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDSyx3QkFBd0IsSUFBSTtBQUM3RCxNQUFNQyx3QkFBd0JQLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ08saUNBQWlDLElBQUk7QUFDL0UsTUFBTUMsdUJBQXVCTixjQUN6QkosY0FDQ0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDUyxnQ0FBZ0MsSUFBSTtBQUNyRCxNQUFNQyx1QkFBdUJSLGNBQ3pCSixjQUNDQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNXLGdDQUFnQyxJQUFJO0FBQ3JELE1BQU1DLDJCQUEyQmIsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDYSxvQ0FBb0MsSUFBSTtBQUNyRixNQUFNQyxjQUFjZixPQUFPQSxDQUFDQyxHQUFHLENBQUNlLHVCQUF1QixJQUFJO0FBQzNELE1BQU1DLGlCQUFpQmpCLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ2lCLDRCQUE0QixJQUFJO0FBQ25FLE1BQU1DLGdCQUFnQm5CLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ21CLDRCQUE0QixJQUFJO0FBQ2xFLG1GQUFtRjtBQUNuRixNQUFNQyxlQUFlLE1BQU0sa0RBQWtEOztBQUU3RSw0REFBNEQ7QUFDNUQsSUFBSUMsZ0JBQXFCO0FBRXpCLGVBQWVDO0lBQ2IsSUFBSSxDQUFDRCxlQUFlO1FBQ2xCLE1BQU0sSUFBSUUsTUFBTTtJQUNsQjtJQUNBLE9BQU9GO0FBQ1Q7QUFF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LGVBQXVCLEVBQUU7WUFDekQsSUFBSXRSLGNBQWMsT0FBTztnQkFBRTBSLGFBQWEsRUFBRTtZQUFDO1lBQzNDLE1BQU05TyxXQUFXLE1BQU1DLE1BQU0sQ0FBQyx3QkFBd0IsRUFBRXVFLEtBQUssZUFBZSxFQUFFa0ssY0FBYztZQUM1RixJQUFJLENBQUMxTyxTQUFTRSxFQUFFLEVBQUUsTUFBTSxJQUFJM0MsTUFBTSxDQUFDLDJCQUEyQixFQUFFaUgsTUFBTTtZQUN0RSxPQUFPeEUsU0FBU3dCLElBQUk7UUFDdEI7UUFDQSxNQUFNdU4sYUFBWXZLLElBQVk7WUFDNUIsSUFBSXBILGNBQWMsT0FBTyxFQUFFO1lBQzNCLE1BQU00QyxXQUFXLE1BQU1DLE1BQU0sQ0FBQyw0QkFBNEIsRUFBRXVFLE1BQU07WUFDbEUsSUFBSSxDQUFDeEUsU0FBU0UsRUFBRSxFQUFFLE1BQU0sSUFBSTNDLE1BQU0sQ0FBQyw2QkFBNkIsRUFBRWlILE1BQU07WUFDeEUsT0FBT3hFLFNBQVN3QixJQUFJO1FBQ3RCO0lBQ0Y7QUFDRixFQUFDO0FBRU0sTUFBTXdOLGFBQWE1UyxhQUFZO0FBQy9CLE1BQU02UyxhQUFhblMsWUFBVyIsInNvdXJjZXMiOlsiL2hvbWUvbWVkZ20vdnNjL1Byb2pldCBKRUUvZGVyZW50LW1haW4vbGliL3NlcnZpY2VzL2FwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFQSSBTZXJ2aWNlIExheWVyXG4gKlxuICogQ2VudHJhbGl6ZWQgQVBJIGNvbW11bmljYXRpb24gc2VydmljZSB0aGF0IGhhbmRsZXM6XG4gKiAtIEJhc2UgVVJMIGNvbmZpZ3VyYXRpb24gZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqIC0gQXV0aGVudGljYXRpb24gaGVhZGVycyAoWC1Vc2VyLUlkLCBYLVVzZXItUm9sZXMpXG4gKiAtIFJlcXVlc3QvcmVzcG9uc2UgaW50ZXJjZXB0b3JzXG4gKiAtIEVycm9yIGhhbmRsaW5nXG4gKlxuICogVXNhZ2U6XG4gKiBpbXBvcnQgeyBhcGlDbGllbnQgfSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9hcGknXG4gKiBjb25zdCBwcm9wZXJ0aWVzID0gYXdhaXQgYXBpQ2xpZW50LnByb3BlcnRpZXMuZ2V0QWxsKClcbiAqXG4gKiBFbnZpcm9ubWVudCBWYXJpYWJsZXMgKGluIC5lbnYubG9jYWwpOlxuICogLSBORVhUX1BVQkxJQ19BUElfQkFTRV9VUkw6IEJhY2tlbmQgQVBJIGJhc2UgVVJMIChlLmcuLCBodHRwOi8vbG9jYWxob3N0OjgwODApXG4gKiAtIE5FWFRfUFVCTElDX0FQSV9WRVJTSU9OOiBBUEkgdmVyc2lvbiBwYXRoIChkZWZhdWx0OiB2MSlcbiAqL1xuXG5pbXBvcnQgdHlwZSB7XG4gIFByb3BlcnR5LFxuICBDcmVhdGVQcm9wZXJ0eVJlcXVlc3QsXG4gIFVwZGF0ZVByb3BlcnR5UmVxdWVzdCxcbiAgQXBwcm92ZVByb3BlcnR5UmVxdWVzdCxcbiAgUHJvcGVydHlUeXBlLFxuICBVc2VyLFxuICBWZXJpZmljYXRpb25SZXF1ZXN0LFxuICBUZW5hbnRSaXNrUmVzcG9uc2UsXG59IGZyb20gXCJAL2xpYi90eXBlc1wiXG5cbi8vIENvbmZpZ3VyYXRpb24gZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbi8vIFVzZSBBUEkgR2F0ZXdheSAocG9ydCA4MDkwKSBhcyB0aGUgc2luZ2xlIGVudHJ5IHBvaW50IGZvciBhbGwgc2VydmljZXNcbi8vIElmIEdBVEVXQVlfVVJMIGlzIG5vdCBzZXQsIGZhbGwgYmFjayB0byBpbmRpdmlkdWFsIHNlcnZpY2UgVVJMcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuY29uc3QgR0FURVdBWV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HQVRFV0FZX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6ODA5MFwiXG5jb25zdCBVU0VfR0FURVdBWSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1VTRV9HQVRFV0FZICE9PSBcImZhbHNlXCIgLy8gRGVmYXVsdCB0byB0cnVlXG5cbi8vIEZhbGxiYWNrIFVSTHMgZm9yIGluZGl2aWR1YWwgc2VydmljZXMgKHVzZWQgaWYgVVNFX0dBVEVXQVkgaXMgZmFsc2UpXG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfQkFTRV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjgwODJcIlxuY29uc3QgUFJPUEVSVFlfQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfUFJPUEVSVFlfQVBJX0JBU0VfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo4MDgxXCJcbmNvbnN0IEJPT0tJTkdfQVBJX0JBU0VfVVJMID0gVVNFX0dBVEVXQVlcbiAgPyBHQVRFV0FZX1VSTFxuICA6IChwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CT09LSU5HX0FQSV9CQVNFX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6ODA4M1wiKVxuY29uc3QgUEFZTUVOVF9BUElfQkFTRV9VUkwgPSBVU0VfR0FURVdBWVxuICA/IEdBVEVXQVlfVVJMXG4gIDogKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1BBWU1FTlRfQVBJX0JBU0VfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo4MDg1XCIpXG5jb25zdCBSRUNMQU1BVElPTl9BUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19SRUNMQU1BVElPTl9BUElfQkFTRV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjgwOTFcIlxuY29uc3QgQVBJX1ZFUlNJT04gPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVkVSU0lPTiB8fCBcInYxXCJcbmNvbnN0IEFVVEhfVE9LRU5fS0VZID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVVUSF9TVE9SQUdFX0tFWSB8fCBcImRlcmVudDVfYXV0aF90b2tlblwiXG5jb25zdCBVU0VSX0RBVEFfS0VZID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfVVNFUl9TVE9SQUdFX0tFWSB8fCBcImRlcmVudDVfdXNlcl9kYXRhXCJcbi8vIFVTRV9NT0NLX0FQSSBpcyB0cnVlIGlmIGV4cGxpY2l0bHkgc2V0IHRvIFwidHJ1ZVwiLCBvdGhlcndpc2UgZmFsc2UgKHVzZSByZWFsIEFQSSlcbmNvbnN0IFVTRV9NT0NLX0FQSSA9IGZhbHNlIC8vIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1VTRV9NT0NLX0FQSSA9PT0gXCJ0cnVlXCJcblxuLy8gT25seSBpbXBvcnQgbW9jayBBUEkgaWYgbmVlZGVkICh0cmVlLXNoYWtlIHdoZW4gbm90IHVzZWQpXG5sZXQgbW9ja0FwaUNsaWVudDogYW55ID0gbnVsbFxuXG5hc3luYyBmdW5jdGlvbiBnZXRNb2NrQXBpKCkge1xuICBpZiAoIW1vY2tBcGlDbGllbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2NrIEFQSSBoYXMgYmVlbiByZW1vdmVkXCIpXG4gIH1cbiAgcmV0dXJuIG1vY2tBcGlDbGllbnRcbn1cblxuLyoqXG4gKiBEZWNvZGUgSldUIHRva2VuIHRvIGV4dHJhY3QgdXNlcklkIGZyb20gc3ViamVjdFxuICovXG5mdW5jdGlvbiBkZWNvZGVKV1QodG9rZW46IHN0cmluZyk6IHsgdXNlcklkPzogc3RyaW5nOyByb2xlcz86IHN0cmluZ1tdIH0gfCBudWxsIHtcbiAgdHJ5IHtcbiAgICAvLyBKV1QgZm9ybWF0OiBoZWFkZXIucGF5bG9hZC5zaWduYXR1cmVcbiAgICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KFwiLlwiKVxuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsXG5cbiAgICAvLyBEZWNvZGUgcGF5bG9hZCAoYmFzZTY0dXJsKVxuICAgIGNvbnN0IHBheWxvYWQgPSBwYXJ0c1sxXVxuICAgIGNvbnN0IGRlY29kZWQgPSBKU09OLnBhcnNlKGF0b2IocGF5bG9hZC5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKSkpXG5cbiAgICByZXR1cm4ge1xuICAgICAgdXNlcklkOiBkZWNvZGVkLnN1YiB8fCBkZWNvZGVkLnN1YmplY3QsIC8vIEpXVCBzdWJqZWN0IGNvbnRhaW5zIHVzZXJJZFxuICAgICAgcm9sZXM6IGRlY29kZWQucm9sZXMgfHwgW10sXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYXV0aGVudGljYXRpb24gaGVhZGVycyBmcm9tIGxvY2FsU3RvcmFnZVxuICogVXNlZCBmb3IgYWxsIEFQSSByZXF1ZXN0cyB0aGF0IHJlcXVpcmUgdXNlciBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGdldEF1dGhIZWFkZXJzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAvLyBPbmx5IHJ1biBpbiBicm93c2VyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cblxuICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKEFVVEhfVE9LRU5fS0VZKVxuICBpZiAoIXRva2VuKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cblxuICAvLyBUcnkgdG8gZ2V0IHVzZXJJZCBmcm9tIEpXVCB0b2tlbiBmaXJzdFxuICBjb25zdCBkZWNvZGVkID0gZGVjb2RlSldUKHRva2VuKVxuICBjb25zdCB1c2VySWQgPSBkZWNvZGVkPy51c2VySWRcblxuICAvLyBGYWxsYmFjayB0byB1c2VyIGRhdGEgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgY29uc3QgdXNlckRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShVU0VSX0RBVEFfS0VZKVxuICBsZXQgZmluYWxVc2VySWQgPSB1c2VySWRcbiAgbGV0IHJvbGVzOiBzdHJpbmdbXSA9IGRlY29kZWQ/LnJvbGVzIHx8IFtdXG5cbiAgaWYgKHVzZXJEYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBKU09OLnBhcnNlKHVzZXJEYXRhKVxuICAgICAgZmluYWxVc2VySWQgPSBmaW5hbFVzZXJJZCB8fCB1c2VyLmlkIHx8IFwiXCJcbiAgICAgIHJvbGVzID0gcm9sZXMubGVuZ3RoID4gMCA/IHJvbGVzIDogKHVzZXIucm9sZXMgfHwgW10pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEZhaWxlZCB0byBwYXJzZSB1c2VyIGRhdGFcbiAgICB9XG4gIH1cblxuICAvLyBFbnN1cmUgdXNlcklkIGlzIGFsd2F5cyBhIHN0cmluZyAoY29udmVydCBudW1iZXIgdG8gc3RyaW5nIGlmIG5lZWRlZClcbiAgY29uc3QgdXNlcklkU3RyaW5nID0gZmluYWxVc2VySWQgPyBTdHJpbmcoZmluYWxVc2VySWQpIDogXCJcIlxuXG4gIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgXCJYLVVzZXItSWRcIjogdXNlcklkU3RyaW5nLFxuICAgIFwiWC1Vc2VyLVJvbGVzXCI6IHJvbGVzLmpvaW4oXCIsXCIpLFxuICAgIC4uLih0b2tlbiAmJiB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0pLFxuICB9XG5cbiAgcmV0dXJuIGhlYWRlcnNcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBjb3JyZWN0IGJhc2UgVVJMIGZvciBhIHNlcnZpY2VcbiAqIFVzZXMgR2F0ZXdheSBpZiBlbmFibGVkLCBvdGhlcndpc2UgZmFsbHMgYmFjayB0byBpbmRpdmlkdWFsIHNlcnZpY2UgVVJMc1xuICovXG5mdW5jdGlvbiBnZXRTZXJ2aWNlVXJsKHNlcnZpY2U6ICdhdXRoJyB8ICd1c2VycycgfCAncHJvcGVydGllcycgfCAnYm9va2luZ3MnIHwgJ3BheW1lbnRzJyB8ICdyZWNsYW1hdGlvbnMnIHwgJ2FkbWluLXJlY2xhbWF0aW9ucycpOiBzdHJpbmcge1xuICBpZiAoVVNFX0dBVEVXQVkpIHtcbiAgICAvLyBBbGwgc2VydmljZXMgZ28gdGhyb3VnaCB0aGUgR2F0ZXdheVxuICAgIHJldHVybiBHQVRFV0FZX1VSTFxuICB9XG5cbiAgLy8gRmFsbGJhY2sgdG8gaW5kaXZpZHVhbCBzZXJ2aWNlIFVSTHNcbiAgc3dpdGNoIChzZXJ2aWNlKSB7XG4gICAgY2FzZSAnYXV0aCc6XG4gICAgY2FzZSAndXNlcnMnOlxuICAgICAgcmV0dXJuIEFQSV9CQVNFX1VSTFxuICAgIGNhc2UgJ3Byb3BlcnRpZXMnOlxuICAgICAgcmV0dXJuIFBST1BFUlRZX0FQSV9CQVNFX1VSTFxuICAgIGNhc2UgJ2Jvb2tpbmdzJzpcbiAgICAgIHJldHVybiBCT09LSU5HX0FQSV9CQVNFX1VSTFxuICAgIGNhc2UgJ3BheW1lbnRzJzpcbiAgICAgIHJldHVybiBQQVlNRU5UX0FQSV9CQVNFX1VSTFxuICAgIGNhc2UgJ3JlY2xhbWF0aW9ucyc6XG4gICAgY2FzZSAnYWRtaW4tcmVjbGFtYXRpb25zJzpcbiAgICAgIHJldHVybiBSRUNMQU1BVElPTl9BUElfQkFTRV9VUkxcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEFQSV9CQVNFX1VSTFxuICB9XG59XG5cbi8qKlxuICogQnVpbGQgZnVsbCBVUkwgd2l0aCBiYXNlIGFuZCB2ZXJzaW9uXG4gKiBGb3IgR2F0ZXdheSwgcGF0aCBhbHJlYWR5IGluY2x1ZGVzIC9hcGkvdjEvLi4uLCBzbyB3ZSBkb24ndCBhZGQgaXQgYWdhaW5cbiAqL1xuZnVuY3Rpb24gYnVpbGRVcmwocGF0aDogc3RyaW5nLCBzZXJ2aWNlOiAnYXV0aCcgfCAndXNlcnMnIHwgJ3Byb3BlcnRpZXMnIHwgJ2Jvb2tpbmdzJyB8ICdwYXltZW50cycgfCAncmVjbGFtYXRpb25zJyB8ICdhZG1pbi1yZWNsYW1hdGlvbnMnID0gJ3VzZXJzJyk6IHN0cmluZyB7XG4gIGNvbnN0IGJhc2VVcmwgPSBnZXRTZXJ2aWNlVXJsKHNlcnZpY2UpXG5cbiAgaWYgKFVTRV9HQVRFV0FZKSB7XG4gICAgLy8gR2F0ZXdheSByb3V0ZXMgcHJlc2VydmUgdGhlIGZ1bGwgcGF0aFxuICAgIC8vIFBhdGggc2hvdWxkIGFscmVhZHkgaW5jbHVkZSAvYXBpL3YxLy4uLiBvciAvYXBpLy4uLiBwcmVmaXhcbiAgICAvLyBJZiBwYXRoIGRvZXNuJ3Qgc3RhcnQgd2l0aCAvYXBpLCBhZGQgdGhlIGFwcHJvcHJpYXRlIHByZWZpeCBiYXNlZCBvbiBzZXJ2aWNlXG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnL2FwaS8nKSkge1xuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9JHtwYXRofWBcbiAgICB9XG5cbiAgICAvLyBBZGQgYXBwcm9wcmlhdGUgcHJlZml4IGJhc2VkIG9uIHNlcnZpY2VcbiAgICBpZiAoc2VydmljZSA9PT0gJ2F1dGgnIHx8IHNlcnZpY2UgPT09ICd1c2VycycpIHtcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9hcGkvdjEke3BhdGh9YFxuICAgIH0gZWxzZSBpZiAoc2VydmljZSA9PT0gJ3Byb3BlcnRpZXMnKSB7XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vYXBpL3YxJHtwYXRofWBcbiAgICB9IGVsc2UgaWYgKHNlcnZpY2UgPT09ICdib29raW5ncycpIHtcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9hcGkke3BhdGh9YFxuICAgIH0gZWxzZSBpZiAoc2VydmljZSA9PT0gJ3BheW1lbnRzJykge1xuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L2FwaSR7cGF0aH1gXG4gICAgfSBlbHNlIGlmIChzZXJ2aWNlID09PSAncmVjbGFtYXRpb25zJyB8fCBzZXJ2aWNlID09PSAnYWRtaW4tcmVjbGFtYXRpb25zJykge1xuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L2FwaSR7cGF0aH1gXG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2Jhc2VVcmx9JHtwYXRofWBcbiAgfVxuXG4gIC8vIEZvciBkaXJlY3Qgc2VydmljZSBjYWxscywgYWRkIHZlcnNpb24gcHJlZml4XG4gIGNvbnN0IGJhc2VQYXRoID0gYC9hcGkvJHtBUElfVkVSU0lPTn1gXG4gIHJldHVybiBgJHtiYXNlVXJsfSR7YmFzZVBhdGh9JHtwYXRofWBcbn1cblxuLyoqXG4gKiBHZW5lcmljIGZldGNoIHdyYXBwZXIgd2l0aCBlcnJvciBoYW5kbGluZ1xuICovXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0PFQ+KFxuICBwYXRoOiBzdHJpbmcsXG4gIG9wdGlvbnM6IFJlcXVlc3RJbml0ICYgeyByZXF1aXJlc0F1dGg/OiBib29sZWFuOyBzZXJ2aWNlPzogJ2F1dGgnIHwgJ3VzZXJzJyB8ICdwcm9wZXJ0aWVzJyB8ICdib29raW5ncycgfCAncGF5bWVudHMnIHwgJ3JlY2xhbWF0aW9ucycgfCAnYWRtaW4tcmVjbGFtYXRpb25zJyB9ID0ge31cbik6IFByb21pc2U8VD4ge1xuICBjb25zdCB7IHJlcXVpcmVzQXV0aCA9IHRydWUsIHNlcnZpY2UgPSAndXNlcnMnLCAuLi5mZXRjaE9wdGlvbnMgfSA9IG9wdGlvbnNcblxuICBjb25zdCBoZWFkZXJzOiBIZWFkZXJzSW5pdCA9IHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAuLi4ocmVxdWlyZXNBdXRoICYmIGdldEF1dGhIZWFkZXJzKCkpLFxuICAgIC4uLmZldGNoT3B0aW9ucy5oZWFkZXJzLFxuICB9XG5cbiAgY29uc3QgdXJsID0gYnVpbGRVcmwocGF0aCwgc2VydmljZSlcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICBoZWFkZXJzLFxuICAgIH0pXG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsZXQgZXJyb3JEYXRhOiBhbnkgPSB7fVxuICAgICAgbGV0IHJlc3BvbnNlVGV4dCA9IFwiXCJcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICAgIGlmIChyZXNwb25zZVRleHQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXJyb3JEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpXG4gICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgSlNPTiBwYXJzaW5nIGZhaWxzLCB1c2UgdGhlIHJhdyB0ZXh0XG4gICAgICAgICAgICBlcnJvckRhdGEgPSB7IG1lc3NhZ2U6IHJlc3BvbnNlVGV4dCwgcmF3OiByZXNwb25zZVRleHQgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAodGV4dEVycm9yKSB7XG4gICAgICAgIGVycm9yRGF0YSA9IHsgbWVzc2FnZTogYEZhaWxlZCB0byByZWFkIHJlc3BvbnNlOiAke3RleHRFcnJvcn1gIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgZXJyb3JEYXRhIGlzIHN0aWxsIGVtcHR5LCBjcmVhdGUgYSBkZWZhdWx0IGVycm9yXG4gICAgICBpZiAoT2JqZWN0LmtleXMoZXJyb3JEYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZXJyb3JEYXRhID0ge1xuICAgICAgICAgIG1lc3NhZ2U6IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAsXG4gICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEV4dHJhY3QgZXJyb3IgbWVzc2FnZSBmcm9tIEVycm9yUmVzcG9uc2UgZm9ybWF0ICh1c2VkIGJ5IHVzZXItc2VydmljZSlcbiAgICAgIC8vIEVycm9yUmVzcG9uc2UgaGFzOiB0aW1lc3RhbXAsIHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIHBhdGhcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICAgIGVycm9yRGF0YS5tZXNzYWdlIHx8ICAgICAgICAgICAvLyBFcnJvclJlc3BvbnNlLm1lc3NhZ2VcbiAgICAgICAgZXJyb3JEYXRhLmVycm9yIHx8ICAgICAgICAgICAgIC8vIEVycm9yUmVzcG9uc2UuZXJyb3IgKGVycm9yIHRpdGxlKVxuICAgICAgICBlcnJvckRhdGEuZGV0YWlsIHx8ICAgICAgICAgICAgLy8gU3RhbmRhcmQgU3ByaW5nIGVycm9yIGZvcm1hdFxuICAgICAgICBlcnJvckRhdGEucmF3IHx8ICAgICAgICAgICAgICAgLy8gUmF3IHJlc3BvbnNlIHRleHQgaWYgSlNPTiBwYXJzaW5nIGZhaWxlZFxuICAgICAgICAoQXJyYXkuaXNBcnJheShlcnJvckRhdGEuZXJyb3JzKSA/IGVycm9yRGF0YS5lcnJvcnMuam9pbihcIiwgXCIpIDogbnVsbCkgfHwgLy8gVmFsaWRhdGlvbiBlcnJvcnMgYXJyYXlcbiAgICAgICAgKHR5cGVvZiBlcnJvckRhdGEgPT09ICdzdHJpbmcnID8gZXJyb3JEYXRhIDogbnVsbCkgfHxcbiAgICAgICAgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG5cbiAgICAgIGNvbnN0IGFwaUVycm9yID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZSlcbiAgICAgICAgOyAoYXBpRXJyb3IgYXMgYW55KS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgOyAoYXBpRXJyb3IgYXMgYW55KS5lcnJvckRhdGEgPSBlcnJvckRhdGFcbiAgICAgICAgOyAoYXBpRXJyb3IgYXMgYW55KS5yZXNwb25zZVRleHQgPSByZXNwb25zZVRleHRcbiAgICAgIHRocm93IGFwaUVycm9yXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcmVzcG9uc2UgaGFzIGNvbnRlbnRcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpXG4gICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgcmV0dXJuIGRhdGEgYXMgVFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyBKU09OIGNvbnRlbnQsIHJldHVybiBlbXB0eSBvYmplY3QgZm9yIHN1Y2Nlc3NmdWwgcmVzcG9uc2VzXG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICAvLyBUcnkgdG8gcGFyc2UgYXMgSlNPTiwgaWYgZmFpbHMgcmV0dXJuIHRleHQgYXMgbWVzc2FnZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpIGFzIFRcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogdGV4dCB9IGFzIFRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9IGFzIFRcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAvLyBDaGVjayBpZiBpdCdzIGEgY29ubmVjdGlvbiBlcnJvclxuICAgIGlmIChlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRVJSX0NPTk5FQ1RJT05fUkVGVVNFRFwiKSkge1xuICAgICAgY29uc3QgY29ubmVjdGlvbkVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gYmFja2VuZCBzZXJ2ZXIgYXQgJHtBUElfQkFTRV9VUkx9LiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBiYWNrZW5kIGlzIHJ1bm5pbmcuYFxuICAgICAgKVxuICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgIHRocm93IGNvbm5lY3Rpb25FcnJvclxuICAgIH1cblxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBNdWx0aXBhcnQgZm9ybSBkYXRhIHJlcXVlc3QgZm9yIGZpbGUgdXBsb2Fkc1xuICovXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0Rm9ybURhdGE8VD4oXG4gIHBhdGg6IHN0cmluZyxcbiAgZm9ybURhdGE6IEZvcm1EYXRhLFxuICBvcHRpb25zOiBPbWl0PFJlcXVlc3RJbml0LCBcImJvZHlcIj4gJiB7IHJlcXVpcmVzQXV0aD86IGJvb2xlYW47IHNlcnZpY2U/OiAnYXV0aCcgfCAndXNlcnMnIHwgJ3Byb3BlcnRpZXMnIHwgJ2Jvb2tpbmdzJyB8ICdwYXltZW50cycgfCAncmVjbGFtYXRpb25zJyB8ICdhZG1pbi1yZWNsYW1hdGlvbnMnIH0gPSB7fSxcbik6IFByb21pc2U8VD4ge1xuICBjb25zdCB7IHJlcXVpcmVzQXV0aCA9IHRydWUsIHNlcnZpY2UgPSAndXNlcnMnLCAuLi5mZXRjaE9wdGlvbnMgfSA9IG9wdGlvbnNcblxuICBjb25zdCBoZWFkZXJzOiBIZWFkZXJzSW5pdCA9IHtcbiAgICAuLi4ocmVxdWlyZXNBdXRoICYmIGdldEF1dGhIZWFkZXJzKCkpLFxuICAgIC4uLmZldGNoT3B0aW9ucy5oZWFkZXJzLFxuICB9XG5cbiAgLy8gRG9uJ3Qgc2V0IENvbnRlbnQtVHlwZSBmb3IgRm9ybURhdGEgLSBicm93c2VyIHdpbGwgc2V0IGl0IHdpdGggYm91bmRhcnlcbiAgZGVsZXRlIChoZWFkZXJzIGFzIGFueSlbXCJDb250ZW50LVR5cGVcIl1cblxuICBjb25zdCB1cmwgPSBidWlsZFVybChwYXRoLCBzZXJ2aWNlKVxuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAuLi5mZXRjaE9wdGlvbnMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgfSlcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIHJldHVybiBkYXRhXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vKipcbiAqIEFQSSBDbGllbnQgLSBPcmdhbml6ZWQgYnkgcmVzb3VyY2VcbiAqL1xuZXhwb3J0IGNvbnN0IGFwaUNsaWVudCA9IHtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gUFJPUEVSVElFUyA9PT09PT09PT09PT09PT09PT09PVxuICBwcm9wZXJ0aWVzOiB7XG4gICAgYXN5bmMgZ2V0QWxsKCk6IFByb21pc2U8UHJvcGVydHlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnByb3BlcnRpZXMuZ2V0QWxsKClcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBwcm9wZXJ0eS1zZXJ2aWNlIFVSTCBmb3IgcHJvcGVydHkgZW5kcG9pbnRzXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzYFxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksIC8vIEluY2x1ZGUgYXV0aCBoZWFkZXJzIHRvIGNoZWNrIGlmIHVzZXIgaXMgQURNSU5cbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpKSB7XG4gICAgICAgICAgY29uc3QgY29ubmVjdGlvbkVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBjb25uZWN0IHRvIHByb3BlcnR5LXNlcnZpY2UgYmFja2VuZCBhdCAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0uIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXMgcnVubmluZy5gXG4gICAgICAgICAgKVxuICAgICAgICAgICAgOyAoY29ubmVjdGlvbkVycm9yIGFzIGFueSkuaXNDb25uZWN0aW9uRXJyb3IgPSB0cnVlXG4gICAgICAgICAgdGhyb3cgY29ubmVjdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgZ2V0QWxsRm9yQWRtaW4oKTogUHJvbWlzZTxQcm9wZXJ0eVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5nZXRBbGwoKVxuICAgICAgfVxuICAgICAgLy8gVXNlIEdhdGV3YXkgb3IgcHJvcGVydHktc2VydmljZSBVUkwgZm9yIGFkbWluIGVuZHBvaW50XG4gICAgICBjb25zdCB1cmwgPSBidWlsZFVybChcIi9wcm9wZXJ0aWVzL2FkbWluL2FsbFwiLCAncHJvcGVydGllcycpXG4gICAgICBjb25zdCBhdXRoSGVhZGVycyA9IGdldEF1dGhIZWFkZXJzKClcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5hdXRoSGVhZGVycyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEuZXJyb3IgfHwgZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG5cbiAgICAgICAgLy8gRW5zdXJlIGRhdGEgaXMgYW4gYXJyYXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgLy8gSWYgaXQncyBhbiBlcnJvciBvYmplY3QsIHRocm93IGl0XG4gICAgICAgICAgaWYgKGRhdGEuZXJyb3IgfHwgZGF0YS5tZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCBkYXRhLm1lc3NhZ2UgfHwgXCJJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdFwiKVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIGVtcHR5IGFycmF5XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkVSUl9DT05ORUNUSU9OX1JFRlVTRURcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gcHJvcGVydHktc2VydmljZSBiYWNrZW5kIGF0ICR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgICAgICApXG4gICAgICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBnZXRCeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPFByb3BlcnR5PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5nZXRCeUlkKGlkKVxuICAgICAgfVxuICAgICAgLy8gVXNlIHByb3BlcnR5LXNlcnZpY2UgVVJMIGZvciBwcm9wZXJ0eSBlbmRwb2ludHNcbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXMvJHtpZH1gXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkVSUl9DT05ORUNUSU9OX1JFRlVTRURcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiQ09SU1wiKSkge1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25FcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgY29ubmVjdCB0byBwcm9wZXJ0eS1zZXJ2aWNlIGJhY2tlbmQgYXQgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9LiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBiYWNrZW5kIGlzIHJ1bm5pbmcuYFxuICAgICAgICAgIClcbiAgICAgICAgICAgIDsgKGNvbm5lY3Rpb25FcnJvciBhcyBhbnkpLmlzQ29ubmVjdGlvbkVycm9yID0gdHJ1ZVxuICAgICAgICAgIHRocm93IGNvbm5lY3Rpb25FcnJvclxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGdldE15UHJvcGVydGllcygpOiBQcm9taXNlPFByb3BlcnR5W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5wcm9wZXJ0aWVzLmdldEFsbCgpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXMvbXktcHJvcGVydGllc2BcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEuZXJyb3IgfHwgZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG5cbiAgICAgICAgLy8gRW5zdXJlIGRhdGEgaXMgYW4gYXJyYXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgLy8gSWYgaXQncyBhbiBlcnJvciBvYmplY3QsIHRocm93IGl0XG4gICAgICAgICAgaWYgKGRhdGEuZXJyb3IgfHwgZGF0YS5tZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCBkYXRhLm1lc3NhZ2UgfHwgXCJJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdFwiKVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIGVtcHR5IGFycmF5XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkVSUl9DT05ORUNUSU9OX1JFRlVTRURcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiQ09SU1wiKSkge1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25FcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgY29ubmVjdCB0byBwcm9wZXJ0eS1zZXJ2aWNlIGJhY2tlbmQgYXQgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9LiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBiYWNrZW5kIGlzIHJ1bm5pbmcuYFxuICAgICAgICAgIClcbiAgICAgICAgICAgIDsgKGNvbm5lY3Rpb25FcnJvciBhcyBhbnkpLmlzQ29ubmVjdGlvbkVycm9yID0gdHJ1ZVxuICAgICAgICAgIHRocm93IGNvbm5lY3Rpb25FcnJvclxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZShkYXRhOiBDcmVhdGVQcm9wZXJ0eVJlcXVlc3QsIGltYWdlczogRmlsZVtdKTogUHJvbWlzZTx7IHByb3BlcnR5SWQ6IHN0cmluZzsgaWQ/OiBzdHJpbmcgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1vY2sucHJvcGVydGllcy5jcmVhdGUoZGF0YSwgaW1hZ2VzKVxuICAgICAgICByZXR1cm4geyBwcm9wZXJ0eUlkOiByZXN1bHQuaWQsIGlkOiByZXN1bHQuaWQgfVxuICAgICAgfVxuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgICAgLy8gQ3JlYXRlIGEgQmxvYiB3aXRoIEpTT04gY29udGVudCB0eXBlIGZvciB0aGUgaW5wdXQgcGFydFxuICAgICAgLy8gU3ByaW5nJ3MgQFJlcXVlc3RQYXJ0IGV4cGVjdHMgQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uIGZvciBKU09OIHBhcnRzXG4gICAgICBjb25zdCBpbnB1dEJsb2IgPSBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkoZGF0YSldLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiIH0pXG4gICAgICBmb3JtRGF0YS5hcHBlbmQoXCJpbnB1dFwiLCBpbnB1dEJsb2IpXG5cbiAgICAgIGltYWdlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImltYWdlc1wiLCBmaWxlKVxuICAgICAgfSlcblxuICAgICAgLy8gVXNlIHByb3BlcnR5LXNlcnZpY2UgVVJMIGZvciBwcm9wZXJ0eSBlbmRwb2ludHNcbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXNgXG4gICAgICBjb25zdCBoZWFkZXJzOiBIZWFkZXJzSW5pdCA9IHtcbiAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHNldCBDb250ZW50LVR5cGUgaGVhZGVyIC0gbGV0IGJyb3dzZXIgc2V0IGl0IHdpdGggYm91bmRhcnkgZm9yIG11bHRpcGFydC9mb3JtLWRhdGFcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIHVwZGF0ZShpZDogc3RyaW5nLCBkYXRhOiBVcGRhdGVQcm9wZXJ0eVJlcXVlc3QpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy51cGRhdGUoaWQsIGRhdGEpXG4gICAgICB9XG4gICAgICAvLyBVc2UgcHJvcGVydHktc2VydmljZSBVUkwgZm9yIHByb3BlcnR5IGVuZHBvaW50c1xuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllcy8ke2lkfWBcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmFja2VuZCByZXR1cm5zIFwiUHJvcGVydHkgdXBkYXRlZFwiIGFzIHBsYWluIHRleHQsIG5vdCBKU09OXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KVxuICAgICAgICAgIHJldHVybiBwYXJzZWRcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gSWYgaXQncyBub3QgSlNPTiwgcmV0dXJuIHN1Y2Nlc3Mgb2JqZWN0XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkNPUlNcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gcHJvcGVydHktc2VydmljZSBiYWNrZW5kIGF0ICR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgICAgICApXG4gICAgICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBkZWxldGUoaWQ6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5wcm9wZXJ0aWVzLmRlbGV0ZShpZClcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBwcm9wZXJ0eS1zZXJ2aWNlIFVSTCBmb3IgcHJvcGVydHkgZW5kcG9pbnRzXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzLyR7aWR9YFxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJFUlJfQ09OTkVDVElPTl9SRUZVU0VEXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkNPUlNcIikpIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGNvbm5lY3QgdG8gcHJvcGVydHktc2VydmljZSBiYWNrZW5kIGF0ICR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgICAgICApXG4gICAgICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBhcHByb3ZlKGlkOiBzdHJpbmcsIGlzQXBwcm92ZWQ6IGJvb2xlYW4pOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5hcHByb3ZlKGlkLCBpc0FwcHJvdmVkKVxuICAgICAgfVxuICAgICAgLy8gVXNlIHByb3BlcnR5LXNlcnZpY2UgVVJMIGZvciBwcm9wZXJ0eSBlbmRwb2ludHNcbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXMvJHtpZH0vYXBwcm92ZWBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpc0FwcHJvdmVkIH0gYXMgQXBwcm92ZVByb3BlcnR5UmVxdWVzdCksXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgcHJvcGVydHlcbiAgICAgKi9cbiAgICBhc3luYyBoaWRlKGlkOiBzdHJpbmcsIGlzSGlkZGVuOiBib29sZWFuKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfVxuICAgICAgLy8gVXNlIHByb3BlcnR5LXNlcnZpY2UgVVJMIGZvciBwcm9wZXJ0eSBlbmRwb2ludHNcbiAgICAgIGNvbnN0IHVybCA9IGAke1BST1BFUlRZX0FQSV9CQVNFX1VSTH0vYXBpLyR7QVBJX1ZFUlNJT059L3Byb3BlcnRpZXMvJHtpZH0vaGlkZWBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpc0hpZGRlbiB9KSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgc3VzcGVuZChpZDogc3RyaW5nLCByZWFzb246IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5wcm9wZXJ0aWVzLnN1c3BlbmQoaWQsIHJlYXNvbilcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBwcm9wZXJ0eS1zZXJ2aWNlIFVSTCBmb3IgcHJvcGVydHkgZW5kcG9pbnRzXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzLyR7aWR9L3N1c3BlbmRgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcmVhc29uIH0pLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyByZXZva2VTdXNwZW5zaW9uKGlkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5zdXNwZW5kKGlkLCBcIlwiKSAvLyBNb2NrXG4gICAgICB9XG4gICAgICAvLyBVc2UgcHJvcGVydHktc2VydmljZSBVUkwgZm9yIHByb3BlcnR5IGVuZHBvaW50c1xuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllcy8ke2lkfS9yZXZva2Utc3VzcGVuc2lvbmBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIHN1Ym1pdEZvckFwcHJvdmFsKGlkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydGllcy5hcHByb3ZlKGlkLCB0cnVlKVxuICAgICAgfVxuICAgICAgY29uc3QgdXJsID0gYCR7UFJPUEVSVFlfQVBJX0JBU0VfVVJMfS9hcGkvJHtBUElfVkVSU0lPTn0vcHJvcGVydGllcy8ke2lkfS9zdWJtaXQtZm9yLWFwcHJvdmFsYFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsQXBwcm92YWxSZXF1ZXN0KGlkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XG4gICAgICB9XG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzLyR7aWR9L2NhbmNlbC1hcHByb3ZhbC1yZXF1ZXN0YFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IEFJLXBvd2VyZWQgcHJpY2Ugc3VnZ2VzdGlvbiBmb3IgYSBwcm9wZXJ0eSBhbmQgZGF0ZSByYW5nZS5cbiAgICAgKiBUaGlzIGNhbGxzIHByb3BlcnR5LXNlcnZpY2UsIHdoaWNoIGZvcndhcmRzIHRoZSByZXF1ZXN0IHRvIHRoZSBwcmljaW5nIG1vZGVsIEFQSS5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVkaWN0UHJpY2UoXG4gICAgICBwcm9wZXJ0eUlkOiBzdHJpbmcsXG4gICAgICBjaGVja0luRGF0ZTogc3RyaW5nLFxuICAgICAgY2hlY2tPdXREYXRlOiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTx7XG4gICAgICBwcmVkaWN0ZWRQcmljZU1hZDogbnVtYmVyXG4gICAgICBwcmVkaWN0ZWRQcmljZVVzZDogbnVtYmVyXG4gICAgICBjb25maWRlbmNlSW50ZXJ2YWxMb3dlcjogbnVtYmVyXG4gICAgICBjb25maWRlbmNlSW50ZXJ2YWxVcHBlcjogbnVtYmVyXG4gICAgICBjaXR5OiBzdHJpbmdcbiAgICAgIHNlYXNvbjogc3RyaW5nXG4gICAgICBtb2RlbFZlcnNpb246IHN0cmluZ1xuICAgICAgcHJlZGljdGlvblRpbWVzdGFtcDogc3RyaW5nXG4gICAgICBjdXJyZW50UHJpY2VNYWQ/OiBudW1iZXJcbiAgICAgIHByaWNlRGlmZmVyZW5jZVBlcmNlbnQ/OiBudW1iZXJcbiAgICAgIHJlY29tbWVuZGF0aW9uPzogc3RyaW5nXG4gICAgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICAvLyBMaWdodHdlaWdodCBtb2NrIGZvciBVSSBkZXZlbG9wbWVudFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByZWRpY3RlZFByaWNlTWFkOiA0MzAsXG4gICAgICAgICAgcHJlZGljdGVkUHJpY2VVc2Q6IDQzLFxuICAgICAgICAgIGNvbmZpZGVuY2VJbnRlcnZhbExvd2VyOiAzODAsXG4gICAgICAgICAgY29uZmlkZW5jZUludGVydmFsVXBwZXI6IDQ4MCxcbiAgICAgICAgICBjaXR5OiBcImNhc2FibGFuY2FcIixcbiAgICAgICAgICBzZWFzb246IFwic3VtbWVyXCIsXG4gICAgICAgICAgbW9kZWxWZXJzaW9uOiBcIjEuMFwiLFxuICAgICAgICAgIHByZWRpY3Rpb25UaW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBjdXJyZW50UHJpY2VNYWQ6IDQwMCxcbiAgICAgICAgICBwcmljZURpZmZlcmVuY2VQZXJjZW50OiA3LjUsXG4gICAgICAgICAgcmVjb21tZW5kYXRpb246IFwiSU5DUkVBU0VcIixcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtQUk9QRVJUWV9BUElfQkFTRV9VUkx9L2FwaS8ke0FQSV9WRVJTSU9OfS9wcm9wZXJ0aWVzLyR7cHJvcGVydHlJZH0vcHJlZGljdC1wcmljZWBcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBwcm9wZXJ0eUlkLFxuICAgICAgICAgIGNoZWNrSW5EYXRlLFxuICAgICAgICAgIGNoZWNrT3V0RGF0ZSxcbiAgICAgICAgfSksXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgZGF0YT8ubWVzc2FnZSB8fFxuICAgICAgICAgIGRhdGE/LmVycm9yIHx8XG4gICAgICAgICAgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gZGF0YSA6IG51bGwpIHx8XG4gICAgICAgICAgYEZhaWxlZCB0byBnZXQgcHJpY2Ugc3VnZ2VzdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9LFxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IFRFTkFOVCBSSVNLID09PT09PT09PT09PT09PT09PT09XG4gIHJpc2s6IHtcbiAgICBnZXRUZW5hbnRSaXNrU2NvcmU6IGFzeW5jICh0ZW5hbnRJZDogbnVtYmVyKTogUHJvbWlzZTxUZW5hbnRSaXNrUmVzcG9uc2U+ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFVzZSBsb2NhbCBOZXh0LmpzIHByb3h5XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdGVuYW50LXJpc2svJHt0ZW5hbnRJZH1gLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1MIEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHJpc2sgc2NvcmU6XCIsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG4gIH0sXG5cbiAgcmVjb21tZW5kYXRpb25zOiB7XG4gICAgZ2V0Rm9yVGVuYW50OiBhc3luYyAodGVuYW50SWQ6IG51bWJlciwgbWF4UmVzdWx0czogbnVtYmVyID0gMyk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3JlY29tbWVuZGF0aW9ucy90ZW5hbnQvJHt0ZW5hbnRJZH0/bWF4X3Jlc3VsdHM9JHttYXhSZXN1bHRzfWApO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggcmVjb21tZW5kYXRpb25zXCIpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHJlY29tbWVuZGF0aW9uczpcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFNpbWlsYXI6IGFzeW5jIChwcm9wZXJ0eUlkOiBzdHJpbmcsIG1heFJlc3VsdHM6IG51bWJlciA9IDMpOiBQcm9taXNlPGFueT4gPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9yZWNvbW1lbmRhdGlvbnMvc2ltaWxhci8ke3Byb3BlcnR5SWR9P21heF9yZXN1bHRzPSR7bWF4UmVzdWx0c31gKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIHNpbWlsYXIgcHJvcGVydGllc1wiKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBzaW1pbGFyIHByb3BlcnRpZXM6XCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IFZFUklGSUNBVElPTiBSRVFVRVNUUyA9PT09PT09PT09PT09PT09PT09PVxuICB2ZXJpZmljYXRpb25SZXF1ZXN0czoge1xuICAgIGFzeW5jIGdldEFsbCgpOiBQcm9taXNlPFZlcmlmaWNhdGlvblJlcXVlc3RbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnZlcmlmaWNhdGlvblJlcXVlc3RzLmdldEFsbCgpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi92ZXJpZmljYXRpb24tcmVxdWVzdHNcIilcbiAgICB9LFxuXG4gICAgYXN5bmMgZ2V0QnlTdGF0dXMoc3RhdHVzOiBzdHJpbmcpOiBQcm9taXNlPFZlcmlmaWNhdGlvblJlcXVlc3RbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnZlcmlmaWNhdGlvblJlcXVlc3RzLmdldEJ5U3RhdHVzKHN0YXR1cylcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KGAvdmVyaWZpY2F0aW9uLXJlcXVlc3RzL2J5LXN0YXR1cy8ke3N0YXR1c31gKVxuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGUocHJvcGVydHlJZDogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nKTogUHJvbWlzZTx7IGlkOiBudW1iZXIgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnZlcmlmaWNhdGlvblJlcXVlc3RzLmNyZWF0ZShwcm9wZXJ0eUlkLCBkZXNjcmlwdGlvbilcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL3ZlcmlmaWNhdGlvbi1yZXF1ZXN0c1wiLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcHJvcGVydHlJZCwgZGVzY3JpcHRpb24gfSksXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyBhcHByb3ZlKGlkOiBudW1iZXIpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sudmVyaWZpY2F0aW9uUmVxdWVzdHMuYXBwcm92ZShpZClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KGAvdmVyaWZpY2F0aW9uLXJlcXVlc3RzLyR7aWR9L2FwcHJvdmVgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVqZWN0KGlkOiBudW1iZXIsIHJlYXNvbjogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLnZlcmlmaWNhdGlvblJlcXVlc3RzLnJlamVjdChpZCwgcmVhc29uKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC92ZXJpZmljYXRpb24tcmVxdWVzdHMvJHtpZH0vcmVqZWN0YCwge1xuICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyByZWFzb24gfSksXG4gICAgICB9KVxuICAgIH0sXG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gUFJPUEVSVFkgVFlQRVMgPT09PT09PT09PT09PT09PT09PT1cbiAgcHJvcGVydHlUeXBlczoge1xuICAgIGFzeW5jIGdldEFsbCgpOiBQcm9taXNlPFByb3BlcnR5VHlwZVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydHlUeXBlcy5nZXRBbGwoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvcHJvcGVydHktdHlwZXNcIiwgeyByZXF1aXJlc0F1dGg6IGZhbHNlIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIGdldEJ5SWQoaWQ6IG51bWJlcik6IFByb21pc2U8UHJvcGVydHlUeXBlPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2sucHJvcGVydHlUeXBlcy5nZXRCeUlkKGlkKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC9wcm9wZXJ0eS10eXBlcy8ke2lkfWAsIHsgcmVxdWlyZXNBdXRoOiBmYWxzZSB9KVxuICAgIH0sXG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gVVNFUlMgPT09PT09PT09PT09PT09PT09PT1cbiAgdXNlcnM6IHtcbiAgICBhc3luYyBnZXRNZSgpOiBQcm9taXNlPHtcbiAgICAgIGZpcnN0TmFtZTogc3RyaW5nXG4gICAgICBsYXN0TmFtZTogc3RyaW5nXG4gICAgICBlbWFpbDogc3RyaW5nXG4gICAgICBwcm9maWxlUGljdHVyZT86IHN0cmluZ1xuICAgICAgYmlydGhkYXk/OiBzdHJpbmdcbiAgICAgIHBob25lTnVtYmVyPzogbnVtYmVyXG4gICAgICB3YWxsZXRBZGRyZXNzPzogc3RyaW5nXG4gICAgICByb2xlcz86IHN0cmluZ1tdXG4gICAgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICAvLyBNb2NrIHVzZXIgZGF0YSBmb3IgZGV2ZWxvcG1lbnRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmaXJzdE5hbWU6IFwiTW9ja1wiLFxuICAgICAgICAgIGxhc3ROYW1lOiBcIlVzZXJcIixcbiAgICAgICAgICBlbWFpbDogXCJtb2NrQGV4YW1wbGUuY29tXCIsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL3VzZXJzL21lXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBpbmZvcm1hdGlvbiBieSBJRCAoZm9yIGdldHRpbmcgcGhvbmUgbnVtYmVyLCBldGMuKVxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5SWQodXNlcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPHtcbiAgICAgIGZpcnN0TmFtZTogc3RyaW5nXG4gICAgICBsYXN0TmFtZTogc3RyaW5nXG4gICAgICBlbWFpbDogc3RyaW5nXG4gICAgICBwcm9maWxlUGljdHVyZT86IHN0cmluZ1xuICAgICAgYmlydGhkYXk/OiBzdHJpbmdcbiAgICAgIHBob25lTnVtYmVyPzogbnVtYmVyXG4gICAgICB3YWxsZXRBZGRyZXNzPzogc3RyaW5nXG4gICAgICByb2xlcz86IHN0cmluZ1tdXG4gICAgICBzY29yZT86IG51bWJlclxuICAgICAgcmF0aW5nPzogbnVtYmVyXG4gICAgICBlbmFibGVkPzogYm9vbGVhblxuICAgIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmaXJzdE5hbWU6IFwiTW9ja1wiLFxuICAgICAgICAgIGxhc3ROYW1lOiBcIlVzZXJcIixcbiAgICAgICAgICBlbWFpbDogXCJtb2NrQGV4YW1wbGUuY29tXCIsXG4gICAgICAgICAgcGhvbmVOdW1iZXI6IDEyMzQ1Njc4OTAsXG4gICAgICAgICAgc2NvcmU6IDEwMCxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVHJ5IHRvIGdldCBmcm9tIGFkbWluIGVuZHBvaW50IGZpcnN0IChpZiB1c2VyIGlzIGFkbWluKSBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhbGxVc2VycyA9IGF3YWl0IHRoaXMuZ2V0QWxsRm9yQWRtaW4oKVxuICAgICAgICBjb25zdCB1c2VyID0gYWxsVXNlcnMuZmluZCh1ID0+IFN0cmluZyh1LmlkKSA9PT0gU3RyaW5nKHVzZXJJZCkpXG4gICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpcnN0TmFtZTogdXNlci5maXJzdE5hbWUsXG4gICAgICAgICAgICBsYXN0TmFtZTogdXNlci5sYXN0TmFtZSxcbiAgICAgICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICAgICAgcHJvZmlsZVBpY3R1cmU6IHVzZXIucHJvZmlsZVBpY3R1cmUsXG4gICAgICAgICAgICBiaXJ0aGRheTogdXNlci5iaXJ0aGRheSxcbiAgICAgICAgICAgIHBob25lTnVtYmVyOiB1c2VyLnBob25lTnVtYmVyLFxuICAgICAgICAgICAgd2FsbGV0QWRkcmVzczogdXNlci53YWxsZXRBZGRyZXNzLFxuICAgICAgICAgICAgcm9sZXM6IHVzZXIucm9sZXMsXG4gICAgICAgICAgICBzY29yZTogdXNlci5zY29yZSxcbiAgICAgICAgICAgIGVuYWJsZWQ6IHVzZXIuZW5hYmxlZCxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBJZiBhZG1pbiBlbmRwb2ludCBmYWlscywgZmFsbGJhY2sgdG8gcmVndWxhciBlbmRwb2ludFxuICAgICAgfVxuXG4gICAgICAvLyBGYWxsYmFjayB0byByZWd1bGFyIGVuZHBvaW50XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3VzZXJzLyR7dXNlcklkfWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyB1cGRhdGVNZShkYXRhOiB7XG4gICAgICBmaXJzdE5hbWU/OiBzdHJpbmdcbiAgICAgIGxhc3ROYW1lPzogc3RyaW5nXG4gICAgICBiaXJ0aGRheT86IHN0cmluZyAvLyBZWVlZLU1NLUREIGZvcm1hdFxuICAgICAgcGhvbmVOdW1iZXI/OiBzdHJpbmcgLy8gMTAtMTUgZGlnaXRzXG4gICAgICB3YWxsZXRBZGRyZXNzPzogc3RyaW5nIC8vIEV0aGVyZXVtIGFkZHJlc3NcbiAgICB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIC8vIE1vY2sgdXBkYXRlXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvdXNlcnMvbWVcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyB1cGRhdGVQcm9maWxlUGljdHVyZShmaWxlOiBGaWxlKTogUHJvbWlzZTx7IHVybDogc3RyaW5nIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJsOiBcIi9wbGFjZWhvbGRlci11c2VyLmpwZ1wiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBmaWxlKVxuXG4gICAgICBjb25zdCBoZWFkZXJzID0gZ2V0QXV0aEhlYWRlcnMoKVxuICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBoZWFkZXIgdG8gbGV0IGJyb3dzZXIgc2V0IGl0IHdpdGggYm91bmRhcnkgZm9yIG11bHRpcGFydC9mb3JtLWRhdGFcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdXG5cbiAgICAgIGNvbnN0IHVybCA9IGJ1aWxkVXJsKFwiL3VzZXJzL21lL3Byb2ZpbGUtcGljdHVyZVwiKVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBsZXQgZXJyb3JEYXRhOiBhbnkgPSB7fVxuICAgICAgICBsZXQgcmVzcG9uc2VUZXh0ID0gXCJcIlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICAgICAgaWYgKHJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXJyb3JEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpXG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgZXJyb3JEYXRhID0geyBtZXNzYWdlOiByZXNwb25zZVRleHQsIHJhdzogcmVzcG9uc2VUZXh0IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGVycm9yRGF0YSA9IHsgbWVzc2FnZTogYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPVxuICAgICAgICAgIGVycm9yRGF0YS5tZXNzYWdlIHx8XG4gICAgICAgICAgZXJyb3JEYXRhLmVycm9yIHx8XG4gICAgICAgICAgZXJyb3JEYXRhLnJhdyB8fFxuICAgICAgICAgIGBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuXG4gICAgICAgIGNvbnN0IGFwaUVycm9yID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZSlcbiAgICAgICAgICA7IChhcGlFcnJvciBhcyBhbnkpLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgIDsgKGFwaUVycm9yIGFzIGFueSkuZXJyb3JEYXRhID0gZXJyb3JEYXRhXG4gICAgICAgIHRocm93IGFwaUVycm9yXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgIHJldHVybiB7IHVybDogdGV4dCB9IC8vIEJhY2tlbmQgcmV0dXJucyBVUkwgYXMgcGxhaW4gdGV4dFxuICAgIH0sXG5cbiAgICBhc3luYyBjaGFuZ2VQYXNzd29yZChjdXJyZW50UGFzc3dvcmQ6IHN0cmluZywgbmV3UGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIlBhc3N3b3JkIGNoYW5nZWQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvdXNlcnMvbWUvY2hhbmdlLXBhc3N3b3JkXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBjdXJyZW50UGFzc3dvcmQsIG5ld1Bhc3N3b3JkIH0pLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgZGVsZXRlUHJvZmlsZVBpY3R1cmUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvdXNlcnMvbWUvcHJvZmlsZS1waWN0dXJlXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyBiZWNvbWVIb3N0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL3VzZXJzL21lL2JlY29tZS1ob3N0XCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgZ2V0QWxsRm9yQWRtaW4oKTogUHJvbWlzZTxBcnJheTx7XG4gICAgICBpZDogbnVtYmVyXG4gICAgICBmaXJzdE5hbWU6IHN0cmluZ1xuICAgICAgbGFzdE5hbWU6IHN0cmluZ1xuICAgICAgZW1haWw6IHN0cmluZ1xuICAgICAgcHJvZmlsZVBpY3R1cmU/OiBzdHJpbmdcbiAgICAgIGJpcnRoZGF5Pzogc3RyaW5nXG4gICAgICBwaG9uZU51bWJlcj86IG51bWJlclxuICAgICAgd2FsbGV0QWRkcmVzcz86IHN0cmluZ1xuICAgICAgcm9sZXM/OiBzdHJpbmdbXVxuICAgICAgZW5hYmxlZDogYm9vbGVhblxuICAgICAgc2NvcmU6IG51bWJlclxuICAgICAgcmF0aW5nPzogbnVtYmVyXG4gICAgfT4+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi91c2Vycy9hZG1pbi9hbGxcIiwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIHJlcXVpcmVzQXV0aDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIGVuYWJsZVVzZXIodXNlcklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3VzZXJzL2FkbWluLyR7dXNlcklkfS9lbmFibGVgLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHt9KSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgZGlzYWJsZVVzZXIodXNlcklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3VzZXJzL2FkbWluLyR7dXNlcklkfS9kaXNhYmxlYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7fSksXG4gICAgICAgIHJlcXVpcmVzQXV0aDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIGFkZEFkbWluUm9sZSh1c2VySWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KGAvdXNlcnMvYWRtaW4vJHt1c2VySWR9L2FkZC1hZG1pbi1yb2xlYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyByZW1vdmVBZG1pblJvbGUodXNlcklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3VzZXJzL2FkbWluLyR7dXNlcklkfS9yZW1vdmUtYWRtaW4tcm9sZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgYWRkSG9zdFJvbGVCeUFkbWluKHVzZXJJZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoYC91c2Vycy9hZG1pbi8ke3VzZXJJZH0vYWRkLWhvc3Qtcm9sZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgcmVxdWlyZXNBdXRoOiB0cnVlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVtb3ZlSG9zdFJvbGUodXNlcklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL3VzZXJzL2FkbWluLyR7dXNlcklkfS9yZW1vdmUtaG9zdC1yb2xlYCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWUsXG4gICAgICB9KVxuICAgIH0sXG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gQVVUSEVOVElDQVRJT04gPT09PT09PT09PT09PT09PT09PT1cbiAgYXV0aDoge1xuICAgIGFzeW5jIHJlZ2lzdGVyKGRhdGE6IHtcbiAgICAgIGZpcnN0TmFtZTogc3RyaW5nXG4gICAgICBsYXN0TmFtZTogc3RyaW5nXG4gICAgICBlbWFpbDogc3RyaW5nXG4gICAgICBwYXNzd29yZDogc3RyaW5nXG4gICAgICBiaXJ0aGRheTogc3RyaW5nIC8vIFlZWVktTU0tREQgZm9ybWF0XG4gICAgICBwaG9uZU51bWJlcjogc3RyaW5nXG4gICAgICByb2xlPzogc3RyaW5nXG4gICAgfSk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIC8vIE1vY2sgcmVnaXN0cmF0aW9uIC0gc2ltdWxhdGUgZGVsYXlcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IFwiVXNlciByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseVwiIH1cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICAgICAgZmlyc3ROYW1lOiBkYXRhLmZpcnN0TmFtZSxcbiAgICAgICAgICBsYXN0TmFtZTogZGF0YS5sYXN0TmFtZSxcbiAgICAgICAgICBlbWFpbDogZGF0YS5lbWFpbCxcbiAgICAgICAgICBwYXNzd29yZDogZGF0YS5wYXNzd29yZCxcbiAgICAgICAgICBiaXJ0aGRheTogZGF0YS5iaXJ0aGRheSwgLy8gU2hvdWxkIGJlIFlZWVktTU0tREQgZm9ybWF0IGZvciBMb2NhbERhdGVcbiAgICAgICAgICBwaG9uZU51bWJlcjogZGF0YS5waG9uZU51bWJlciwgLy8gU2hvdWxkIGJlIDEwLTE1IGRpZ2l0cyBvbmx5XG4gICAgICAgICAgLi4uKGRhdGEucm9sZSAmJiB7IHJvbGU6IGRhdGEucm9sZSB9KSxcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QoXCIvYXV0aC9yZWdpc3RlclwiLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgICAgICAgcmVxdWlyZXNBdXRoOiBmYWxzZSxcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgLy8gSWYgY29ubmVjdGlvbiBmYWlscywgdGhyb3cgd2l0aCBoZWxwZnVsIG1lc3NhZ2VcbiAgICAgICAgaWYgKGVycm9yPy5pc0Nvbm5lY3Rpb25FcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiQmFja2VuZCBzZXJ2ZXIgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgdXNlci1zZXJ2aWNlIGlzIHJ1bm5pbmcgb24gcG9ydCA4MDgwLlwiXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGxvZ2luKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHsgdG9rZW46IHN0cmluZzsgand0RXhwaXJhdGlvbjogbnVtYmVyIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICAvLyBNb2NrIGxvZ2luIC0gd291bGQgdXNlIG1vY2sgZGF0YVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2NrIGxvZ2luIG5vdCBpbXBsZW1lbnRlZCAtIHVzZSB1c2VBdXRoIGhvb2tcIilcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL2F1dGgvbG9naW5cIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsLCBwYXNzd29yZCB9KSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIHNldEF1dGgodG9rZW46IHN0cmluZywgdXNlcjogVXNlcik6IHZvaWQge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQVVUSF9UT0tFTl9LRVksIHRva2VuKVxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShVU0VSX0RBVEFfS0VZLCBKU09OLnN0cmluZ2lmeSh1c2VyKSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VG9rZW4oKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGxcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShBVVRIX1RPS0VOX0tFWSlcbiAgICB9LFxuXG4gICAgZ2V0VXNlcigpOiBVc2VyIHwgbnVsbCB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGxcbiAgICAgIGNvbnN0IHVzZXJEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oVVNFUl9EQVRBX0tFWSlcbiAgICAgIHJldHVybiB1c2VyRGF0YSA/IEpTT04ucGFyc2UodXNlckRhdGEpIDogbnVsbFxuICAgIH0sXG5cbiAgICBjbGVhckF1dGgoKTogdm9pZCB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShBVVRIX1RPS0VOX0tFWSlcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oVVNFUl9EQVRBX0tFWSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFzUm9sZShyb2xlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IHVzZXIgPSB0aGlzLmdldFVzZXIoKVxuICAgICAgcmV0dXJuIHVzZXI/LnJvbGVzLmluY2x1ZGVzKHJvbGUgYXMgYW55KSA/PyBmYWxzZVxuICAgIH0sXG5cbiAgICBhc3luYyB2ZXJpZnkoZW1haWw6IHN0cmluZywgdmVyaWZpY2F0aW9uQ29kZTogc3RyaW5nKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIlVzZXIgdmVyaWZpZWQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvYXV0aC92ZXJpZnlcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsLCB2ZXJpZmljYXRpb25Db2RlIH0pLFxuICAgICAgICByZXF1aXJlc0F1dGg6IGZhbHNlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVzZW5kVmVyaWZpY2F0aW9uQ29kZShlbWFpbDogc3RyaW5nKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIlZlcmlmaWNhdGlvbiBDb2RlIHJlc2VudCBzdWNjZXNzZnVsbHlcIiB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChgL2F1dGgvcmVzZW5kP2VtYWlsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGVtYWlsKX1gLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIHJlcXVpcmVzQXV0aDogZmFsc2UsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyBmb3Jnb3RQYXNzd29yZChlbWFpbDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1ZXN0KFwiL2F1dGgvZm9yZ290LXBhc3N3b3JkXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCB9KSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIHZlcmlmeVJlc2V0VG9rZW4odG9rZW46IHN0cmluZyk6IFByb21pc2U8eyB2YWxpZDogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi9hdXRoL3ZlcmlmeS1yZXNldC10b2tlblwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdG9rZW4gfSksXG4gICAgICAgIHJlcXVpcmVzQXV0aDogZmFsc2UsXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyByZXNldFBhc3N3b3JkKHRva2VuOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvYXV0aC9yZXNldC1wYXNzd29yZFwiLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdG9rZW4sIHBhc3N3b3JkIH0pLFxuICAgICAgICByZXF1aXJlc0F1dGg6IGZhbHNlLFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgdmVyaWZ5UmVzZXRDb2RlKGVtYWlsOiBzdHJpbmcsIGNvZGU6IHN0cmluZyk6IFByb21pc2U8eyB2YWxpZDogYm9vbGVhbiB9PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdChcIi9hdXRoL3ZlcmlmeS1yZXNldC1jb2RlXCIsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCwgY29kZSB9KSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGFzeW5jIHJlc2V0UGFzc3dvcmRXaXRoQ29kZShlbWFpbDogc3RyaW5nLCBjb2RlOiBzdHJpbmcsIG5ld1Bhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHsgbWVzc2FnZTogc3RyaW5nIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IFwiUGFzc3dvcmQgcmVzZXQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3QoXCIvYXV0aC9yZXNldC1wYXNzd29yZC13aXRoLWNvZGVcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsLCBjb2RlLCBuZXdQYXNzd29yZCB9KSxcbiAgICAgICAgcmVxdWlyZXNBdXRoOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfSxcbiAgfSxcblxuICBib29raW5nczoge1xuICAgIC8qKlxuICAgICAqIEdldCBhbGwgYm9va2luZ3MgZm9yIGFkbWluXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsRm9yQWRtaW4oKTogUHJvbWlzZTxBcnJheTx7XG4gICAgICBpZDogbnVtYmVyXG4gICAgICB1c2VySWQ6IG51bWJlclxuICAgICAgcHJvcGVydHlJZDogc3RyaW5nXG4gICAgICBwcm9wZXJ0eVRpdGxlOiBzdHJpbmdcbiAgICAgIHByb3BlcnR5QWRkcmVzczogc3RyaW5nXG4gICAgICBvd25lcklkOiBudW1iZXIgfCBudWxsXG4gICAgICB0ZW5hbnROYW1lOiBzdHJpbmdcbiAgICAgIHRlbmFudEVtYWlsOiBzdHJpbmdcbiAgICAgIGhvc3ROYW1lOiBzdHJpbmdcbiAgICAgIGhvc3RFbWFpbDogc3RyaW5nXG4gICAgICBjaGVja0luRGF0ZTogc3RyaW5nXG4gICAgICBjaGVja091dERhdGU6IHN0cmluZ1xuICAgICAgbnVtYmVyT2ZOaWdodHM6IG51bWJlciB8IG51bGxcbiAgICAgIHRvdGFsUHJpY2U6IG51bWJlciB8IG51bGxcbiAgICAgIGxvbmdTdGF5RGlzY291bnRQZXJjZW50OiBudW1iZXIgfCBudWxsXG4gICAgICByZXF1ZXN0ZWROZWdvdGlhdGlvblBlcmNlbnQ6IG51bWJlciB8IG51bGxcbiAgICAgIHN0YXR1czogc3RyaW5nXG4gICAgICBvbkNoYWluVHhIYXNoOiBzdHJpbmcgfCBudWxsXG4gICAgICBuZWdvdGlhdGlvbkV4cGlyZXNBdDogc3RyaW5nIHwgbnVsbFxuICAgICAgY3JlYXRlZEF0OiBzdHJpbmdcbiAgICAgIHVwZGF0ZWRBdDogc3RyaW5nIHwgbnVsbFxuICAgIH0+PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9hZG1pbi9hbGxgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggYm9va2luZ3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGlmIChlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoXCJGYWlsZWQgdG8gZmV0Y2hcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRVJSX0NPTk5FQ1RJT05fUkVGVVNFRFwiKSkge1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25FcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgY29ubmVjdCB0byBib29raW5nLXNlcnZpY2UgYmFja2VuZCBhdCAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgICAgICApXG4gICAgICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBib29raW5nIHJlcXVlc3RcbiAgICAgKiBTZW5kcyBib29raW5nIGRhdGEgdG8gYm9va2luZy1zZXJ2aWNlIHZpYSBSYWJiaXRNUVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShkYXRhOiB7XG4gICAgICB1c2VySWQ6IHN0cmluZyB8IG51bWJlclxuICAgICAgcHJvcGVydHlJZDogc3RyaW5nIHwgbnVtYmVyXG4gICAgICBjaGVja0luRGF0ZTogc3RyaW5nXG4gICAgICBjaGVja091dERhdGU6IHN0cmluZ1xuICAgICAgbnVtYmVyT2ZHdWVzdHM6IG51bWJlclxuICAgICAgcmVxdWVzdGVkUHJpY2U/OiBudW1iZXJcbiAgICB9KTogUHJvbWlzZTx7IHN0YXR1czogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmc7IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5ib29raW5ncz8uY3JlYXRlPy4oZGF0YSkgfHwgeyBzdGF0dXM6IFwiYWNjZXB0ZWRcIiwgbWVzc2FnZTogXCJCb29raW5nIHJlcXVlc3Qgc2VudFwiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9yZXF1ZXN0YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICB1c2VySWQ6IHR5cGVvZiBkYXRhLnVzZXJJZCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlSW50KGRhdGEudXNlcklkKSA6IGRhdGEudXNlcklkLFxuICAgICAgICAgIHByb3BlcnR5SWQ6IGRhdGEucHJvcGVydHlJZCwgLy8gS2VlcCBhcyBTdHJpbmcgKFVVSUQgZnJvbSBwcm9wZXJ0eS1zZXJ2aWNlKVxuICAgICAgICAgIGNoZWNrSW5EYXRlOiBkYXRhLmNoZWNrSW5EYXRlLFxuICAgICAgICAgIGNoZWNrT3V0RGF0ZTogZGF0YS5jaGVja091dERhdGUsXG4gICAgICAgICAgbnVtYmVyT2ZHdWVzdHM6IGRhdGEubnVtYmVyT2ZHdWVzdHMsXG4gICAgICAgICAgcmVxdWVzdGVkUHJpY2U6IGRhdGEucmVxdWVzdGVkUHJpY2UsXG4gICAgICAgIH0pLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgLy8gSWYgc3RhdHVzIGlzIFwicmVqZWN0ZWRcIiwgcmV0dXJuIHRoZSByZXNwb25zZSBkYXRhIGluc3RlYWQgb2YgdGhyb3dpbmdcbiAgICAgICAgaWYgKHJlc3BvbnNlRGF0YS5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZURhdGFcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2VEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBjcmVhdGUgYm9va2luZzogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlRGF0YVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYm9va2luZyBieSBJRFxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5SWQoaWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSBhd2FpdCBnZXRNb2NrQXBpKClcbiAgICAgICAgcmV0dXJuIG1vY2suYm9va2luZ3M/LmdldEJ5SWQ/LihpZCkgfHwgbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7aWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggYm9va2luZzogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYm9va2luZ3MgYnkgdGVuYW50IElEXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QnlUZW5hbnRJZCh0ZW5hbnRJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLmJvb2tpbmdzPy5nZXRCeVRlbmFudElkPy4odGVuYW50SWQpIHx8IFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3M/dGVuYW50SWQ9JHt0ZW5hbnRJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggYm9va2luZ3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgYm9va2luZyBmb3IgYSB1c2VyXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q3VycmVudEJvb2tpbmcodXNlcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueSB8IG51bGw+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgLy8gTW9jazogcmV0dXJuIG51bGwgZm9yIG5vdyAobm8gY3VycmVudCBib29raW5nKVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzL2N1cnJlbnQ/dXNlcklkPSR7dXNlcklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggY3VycmVudCBib29raW5nOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBwZW5kaW5nIGJvb2tpbmdzIChuZWdvdGlhdGlvbnMpIGZvciBhIHVzZXJcbiAgICAgKi9cbiAgICBhc3luYyBnZXRQZW5kaW5nQm9va2luZ3ModXNlcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIC8vIE1vY2s6IHJldHVybiBlbXB0eSBhcnJheVxuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9wZW5kaW5nP3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggcGVuZGluZyBib29raW5nczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYXdhaXRpbmcgcGF5bWVudCBib29raW5ncyBmb3IgYSB1c2VyXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QXdhaXRpbmdQYXltZW50Qm9va2luZ3ModXNlcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIC8vIE1vY2s6IHJldHVybiBlbXB0eSBhcnJheVxuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9wYXltZW50P3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggYXdhaXRpbmcgcGF5bWVudCBib29raW5nczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcHJvcGVydHkgaW5mbyBmb3IgYm9va2luZyAocHJpY2UsIGRpc2NvdW50LCBuZWdvdGlhdGlvbilcbiAgICAgKi9cbiAgICBhc3luYyBnZXRQcm9wZXJ0eUluZm8ocHJvcGVydHlJZDogc3RyaW5nKTogUHJvbWlzZTx7XG4gICAgICBpZDogc3RyaW5nXG4gICAgICBvd25lcklkOiBudW1iZXJcbiAgICAgIHByaWNlUGVyTmlnaHQ6IG51bWJlciB8IHN0cmluZyAvLyBDYW4gYmUgbnVtYmVyIG9yIHN0cmluZyAoQmlnRGVjaW1hbCBmcm9tIGJhY2tlbmQpXG4gICAgICBpc05lZ290aWFibGU6IGJvb2xlYW5cbiAgICAgIGRpc2NvdW50RW5hYmxlZDogYm9vbGVhblxuICAgICAgbWF4TmVnb3RpYXRpb25QZXJjZW50PzogbnVtYmVyXG4gICAgfT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICAvLyBNb2NrIHByb3BlcnR5IGluZm9cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogcHJvcGVydHlJZCxcbiAgICAgICAgICBvd25lcklkOiAxLFxuICAgICAgICAgIHByaWNlUGVyTmlnaHQ6IDEwMCxcbiAgICAgICAgICBpc05lZ290aWFibGU6IGZhbHNlLFxuICAgICAgICAgIGRpc2NvdW50RW5hYmxlZDogZmFsc2UsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9wcm9wZXJ0eS8ke3Byb3BlcnR5SWR9YFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcyhcIkVSUl9DT05ORUNUSU9OX1JFRlVTRURcIikgfHwgZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKFwiQ09SU1wiKSkge1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25FcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgY29ubmVjdCB0byBib29raW5nLXNlcnZpY2UgYmFja2VuZCBhdCAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpcyBydW5uaW5nLmBcbiAgICAgICAgICApXG4gICAgICAgICAgICA7IChjb25uZWN0aW9uRXJyb3IgYXMgYW55KS5pc0Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGFzdCBib29raW5nIElEIChmb3IgcG9sbGluZyBhZnRlciBjcmVhdGlvbilcbiAgICAgKi9cbiAgICBhc3luYyBnZXRMYXN0Qm9va2luZ0lkKCk6IFByb21pc2U8eyBib29raW5nSWQ6IG51bWJlciB9IHwgbnVsbD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBib29raW5nSWQ6IDEgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzL2Jvb2tpbmctaWRgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgYm9va2luZ1xuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShpZDogc3RyaW5nIHwgbnVtYmVyLCBkYXRhOiB7XG4gICAgICBjaGVja0luRGF0ZT86IHN0cmluZ1xuICAgICAgY2hlY2tPdXREYXRlPzogc3RyaW5nXG4gICAgICBudW1iZXJPZkd1ZXN0cz86IG51bWJlclxuICAgICAgcmVxdWVzdGVkUHJpY2U/OiBudW1iZXJcbiAgICB9KTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IGF3YWl0IGdldE1vY2tBcGkoKVxuICAgICAgICByZXR1cm4gbW9jay5ib29raW5ncz8udXBkYXRlPy4oaWQsIGRhdGEpIHx8IG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy8ke2lkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgY2hlY2tJbkRhdGU6IGRhdGEuY2hlY2tJbkRhdGUsXG4gICAgICAgICAgY2hlY2tPdXREYXRlOiBkYXRhLmNoZWNrT3V0RGF0ZSxcbiAgICAgICAgICBudW1iZXJPZkd1ZXN0czogZGF0YS5udW1iZXJPZkd1ZXN0cyxcbiAgICAgICAgICByZXF1ZXN0ZWRQcmljZTogZGF0YS5yZXF1ZXN0ZWRQcmljZSxcbiAgICAgICAgfSksXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuZXJyb3IgfHwgYEZhaWxlZCB0byB1cGRhdGUgYm9va2luZzogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICAgICAgLy8gQWRkIHN0YXR1cyBhbmQgZXJyb3IgY29kZSBmb3IgYmV0dGVyIGVycm9yIGhhbmRsaW5nXG4gICAgICAgICAgOyAoZXJyb3IgYXMgYW55KS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICA7IChlcnJvciBhcyBhbnkpLmVycm9yQ29kZSA9IGVycm9yRGF0YS5lcnJvclxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlL0NhbmNlbCBhIGJvb2tpbmcgKGJ5IHRlbmFudClcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUoaWQ6IHN0cmluZyB8IG51bWJlciwgdXNlcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLmJvb2tpbmdzPy5kZWxldGU/LihpZCwgdXNlcklkKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7aWR9P3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGVycm9yRGF0YS5lcnJvciB8fCBgRmFpbGVkIHRvIGNhbmNlbCBib29raW5nOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRlbmFudCBjaGVja291dCAoY2hhbmdlcyBzdGF0dXMgdG8gVEVOQU5UX0NIRUNLRURfT1VUKVxuICAgICAqL1xuICAgIGFzeW5jIHRlbmFudENoZWNrb3V0KGlkOiBzdHJpbmcgfCBudW1iZXIsIHRlbmFudElkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIlRlbmFudCBjaGVja2VkIG91dCBzdWNjZXNzZnVsbHlcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvJHtpZH0vY2hlY2tvdXQvdGVuYW50P3VzZXJJZD0ke3RlbmFudElkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGVycm9yRGF0YS5lcnJvciB8fCBgRmFpbGVkIHRvIGNoZWNrb3V0OiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE93bmVyIGNvbmZpcm0gY2hlY2tvdXQgKGNoYW5nZXMgc3RhdHVzIHRvIENPTVBMRVRFRClcbiAgICAgKi9cbiAgICBhc3luYyBvd25lckNvbmZpcm1DaGVja291dChpZDogc3RyaW5nIHwgbnVtYmVyLCBvd25lcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIkNoZWNrb3V0IGNvbmZpcm1lZCBzdWNjZXNzZnVsbHlcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvJHtpZH0vY2hlY2tvdXQvb3duZXI/dXNlcklkPSR7b3duZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuZXJyb3IgfHwgYEZhaWxlZCB0byBjb25maXJtIGNoZWNrb3V0OiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB0ZW5hbnRDaGVja291dCgpIG9yIG93bmVyQ29uZmlybUNoZWNrb3V0KCkgaW5zdGVhZFxuICAgICAqL1xuICAgIGFzeW5jIG1hcmtBc0NoZWNrZWRPdXQoaWQ6IHN0cmluZyB8IG51bWJlciwgdXNlcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICBjb25zdCBtb2NrID0gYXdhaXQgZ2V0TW9ja0FwaSgpXG4gICAgICAgIHJldHVybiBtb2NrLmJvb2tpbmdzPy5tYXJrQXNDaGVja2VkT3V0Py4oaWQsIHVzZXJJZCkgfHwgbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7aWR9L2NoZWNrb3V0P3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuZXJyb3IgfHwgYEZhaWxlZCB0byBtYXJrIGFzIGNoZWNrZWQgb3V0OiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IGJvb2tpbmdzIGJ5IG93bmVyIChob3N0KVxuICAgICAqL1xuICAgIGFzeW5jIGdldEN1cnJlbnRCb29raW5nc0J5T3duZXIob3duZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7Qk9PS0lOR19BUElfQkFTRV9VUkx9L2FwaS9ib29raW5ncy9jdXJyZW50L293bmVyP293bmVySWQ9JHtvd25lcklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBjdXJyZW50IGJvb2tpbmdzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBwZW5kaW5nIG5lZ290aWF0aW9ucyBieSBvd25lciAoaG9zdClcbiAgICAgKi9cbiAgICBhc3luYyBnZXRQZW5kaW5nTmVnb3RpYXRpb25zKG93bmVySWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvbmVnb3RpYXRpb25zP293bmVySWQ9JHtvd25lcklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBwZW5kaW5nIG5lZ290aWF0aW9uczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBY2NlcHQgbmVnb3RpYXRpb24gKGhvc3QpXG4gICAgICovXG4gICAgYXN5bmMgYWNjZXB0TmVnb3RpYXRpb24oYm9va2luZ0lkOiBzdHJpbmcgfCBudW1iZXIsIG93bmVySWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IFwiTmVnb3RpYXRpb24gYWNjZXB0ZWRcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvJHtib29raW5nSWR9L2FjY2VwdD9vd25lcklkPSR7b3duZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuZXJyb3IgfHwgYEZhaWxlZCB0byBhY2NlcHQgbmVnb3RpYXRpb246ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVqZWN0IG5lZ290aWF0aW9uIChob3N0KVxuICAgICAqL1xuICAgIGFzeW5jIHJlamVjdE5lZ290aWF0aW9uKGJvb2tpbmdJZDogc3RyaW5nIHwgbnVtYmVyLCBvd25lcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIk5lZ290aWF0aW9uIHJlamVjdGVkXCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzLyR7Ym9va2luZ0lkfS9yZWplY3Q/b3duZXJJZD0ke293bmVySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gcmVqZWN0IG5lZ290aWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgYm9va2luZ3MgYnkgb3duZXIgKGhvc3QpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QnlPd25lcklkKG93bmVySWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3M/b3duZXJJZD0ke293bmVySWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGJvb2tpbmdzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb25maXJtZWQgYm9va2luZ3MgYnkgb3duZXIgKGhvc3QpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29uZmlybWVkQm9va2luZ3NCeU93bmVyKG93bmVySWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvY29uZmlybWVkL293bmVyP293bmVySWQ9JHtvd25lcklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBjb25maXJtZWQgYm9va2luZ3M6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbmZpcm1lZCBib29raW5ncyBieSBwcm9wZXJ0eSBJRFxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbmZpcm1lZEJvb2tpbmdzQnlQcm9wZXJ0eShwcm9wZXJ0eUlkOiBzdHJpbmcpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtCT09LSU5HX0FQSV9CQVNFX1VSTH0vYXBpL2Jvb2tpbmdzL2NvbmZpcm1lZC9wcm9wZXJ0eS8ke3Byb3BlcnR5SWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGNvbmZpcm1lZCBib29raW5nczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgZGlzcHV0ZSAoaG9zdCBvciB0ZW5hbnQpXG4gICAgICovXG4gICAgYXN5bmMgcmVwb3J0RGlzcHV0ZShib29raW5nSWQ6IHN0cmluZyB8IG51bWJlciwgdXNlcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBcIkRpc3B1dGUgcmVwb3J0ZWRcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke0JPT0tJTkdfQVBJX0JBU0VfVVJMfS9hcGkvYm9va2luZ3MvJHtib29raW5nSWR9L2Rpc3B1dGU/dXNlcklkPSR7dXNlcklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBlcnJvckRhdGEuZXJyb3IgfHwgYEZhaWxlZCB0byByZXBvcnQgZGlzcHV0ZTogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIFBheW1lbnQgU2VydmljZSBBUElcbiAgICovXG4gIHBheW1lbnRzOiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBheW1lbnQgaW50ZW50XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlSW50ZW50KGJvb2tpbmdJZDogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZWZlcmVuY2VJZDogXCJtb2NrLXJlZi1pZFwiLFxuICAgICAgICAgIHRvOiBcIjB4MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MFwiLFxuICAgICAgICAgIHZhbHVlOiBcIjEwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgIGNoYWluSWQ6IDMxMzM3LFxuICAgICAgICAgIHRvdGFsQW1vdW50V2VpOiBcIjEwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtQQVlNRU5UX0FQSV9CQVNFX1VSTH0vYXBpL3BheW1lbnRzL2ludGVudGBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGJvb2tpbmdJZCB9KSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGNyZWF0ZSBwYXltZW50IGludGVudDogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYm9va2luZyBkZXRhaWxzIGZvciBwYXltZW50XG4gICAgICovXG4gICAgYXN5bmMgZ2V0Qm9va2luZ0RldGFpbHMoYm9va2luZ0lkOiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJvb2tpbmdJZCxcbiAgICAgICAgICBzdGF0dXM6IFwiUEVORElOR19QQVlNRU5UXCIsXG4gICAgICAgICAgdG90YWxQcmljZTogMTAwLjAsXG4gICAgICAgICAgY2hlY2tJbkRhdGU6IFwiMjAyNS0xMi0wMVwiLFxuICAgICAgICAgIGNoZWNrT3V0RGF0ZTogXCIyMDI1LTEyLTA1XCIsXG4gICAgICAgICAgcHJvcGVydHlJZDogMSxcbiAgICAgICAgICBwcm9wZXJ0eVRpdGxlOiBcIk1vY2sgUHJvcGVydHlcIixcbiAgICAgICAgICBwcm9wZXJ0eVByaWNlOiAyMC4wLFxuICAgICAgICAgIG93bmVyV2FsbGV0QWRkcmVzczogXCIweDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBcIixcbiAgICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgICAgY3VycmVudFVzZXJJZDogMSxcbiAgICAgICAgICB1c2VyRmlyc3ROYW1lOiBcIkpvaG5cIixcbiAgICAgICAgICB1c2VyTGFzdE5hbWU6IFwiRG9lXCIsXG4gICAgICAgICAgdXNlckVtYWlsOiBcImpvaG5AZXhhbXBsZS5jb21cIixcbiAgICAgICAgICB1c2VyV2FsbGV0QWRkcmVzczogbnVsbCxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtQQVlNRU5UX0FQSV9CQVNFX1VSTH0vYXBpL3BheW1lbnRzL2Jvb2tpbmcvJHtib29raW5nSWR9YFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGBGYWlsZWQgdG8gZmV0Y2ggYm9va2luZyBkZXRhaWxzOiAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgICAgLy8gQmFja2VuZCByZXR1cm5zIHsgY29kZSwgbWVzc2FnZSB9IGZvcm1hdFxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yRGF0YS5tZXNzYWdlIHx8IGVycm9yRGF0YS5jb2RlIHx8IGVycm9yTWVzc2FnZVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSWYgcmVzcG9uc2UgaXMgbm90IEpTT04sIHVzZSBzdGF0dXMgdGV4dFxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLnN0YXR1c1RleHQgfHwgZXJyb3JNZXNzYWdlXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgd2FsbGV0IGFkZHJlc3NcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVXYWxsZXRBZGRyZXNzKHVzZXJJZDogbnVtYmVyLCB3YWxsZXRBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1BBWU1FTlRfQVBJX0JBU0VfVVJMfS9hcGkvcGF5bWVudHMvd2FsbGV0LWFkZHJlc3NgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHVzZXJJZCwgd2FsbGV0QWRkcmVzcyB9KSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIHVwZGF0ZSB3YWxsZXQgYWRkcmVzczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVUcmFuc2FjdGlvbkhhc2goYm9va2luZ0lkOiBudW1iZXIsIHR4SGFzaDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtQQVlNRU5UX0FQSV9CQVNFX1VSTH0vYXBpL3BheW1lbnRzL2Jvb2tpbmcvJHtib29raW5nSWR9L3R4LWhhc2hgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHR4SGFzaCB9KSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIHVwZGF0ZSB0cmFuc2FjdGlvbiBoYXNoOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBEYXRlIG1vZGlmaWNhdGlvbiByZW1vdmVkIC0gZGF0ZXMgY2FuIG9ubHkgYmUgY2hhbmdlZCBmcm9tIGJvb2tpbmctc2VydmljZVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRyYW5zYWN0aW9uIHN0YXR1c1xuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uU3RhdHVzKHR4SGFzaDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eEhhc2gsXG4gICAgICAgICAgc3RhdHVzOiBcIlBFTkRJTkdcIixcbiAgICAgICAgICBibG9ja051bWJlcjogbnVsbCxcbiAgICAgICAgICBib29raW5nSWQ6IG51bGwsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UEFZTUVOVF9BUElfQkFTRV9VUkx9L2FwaS9wYXltZW50cy90eC8ke3R4SGFzaH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggdHJhbnNhY3Rpb24gc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIGJvb2tpbmcgb24gYmxvY2tjaGFpbiAoY2FsbGVkIGJ5IGhvc3Qgd2hlbiBjb25maXJtaW5nIGNoZWNrb3V0KVxuICAgICAqL1xuICAgIGFzeW5jIGNvbXBsZXRlQm9va2luZyhib29raW5nSWQ6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICBtZXNzYWdlOiBcIkJvb2tpbmcgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBvbiBibG9ja2NoYWluXCIsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UEFZTUVOVF9BUElfQkFTRV9VUkx9L2FwaS9wYXltZW50cy9ib29raW5nLyR7Ym9va2luZ0lkfS9jb21wbGV0ZWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBsZXQgZXJyb3JEYXRhOiBhbnkgPSB7fVxuICAgICAgICBsZXQgZXJyb3JUZXh0ID0gXCJcIlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgICAgIGlmIChlcnJvclRleHQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGVycm9yRGF0YSA9IEpTT04ucGFyc2UoZXJyb3JUZXh0KVxuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIGVycm9yRGF0YSA9IHsgbWVzc2FnZTogZXJyb3JUZXh0IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBJZiByZXNwb25zZSBpcyBub3QgSlNPTiwgdXNlIHN0YXR1cyB0ZXh0XG4gICAgICAgICAgZXJyb3JEYXRhID0geyBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0IHx8IGBTZXJ2ZXIgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3JEYXRhLmVycm9yIHx8IGVycm9yVGV4dCB8fCBgRmFpbGVkIHRvIGNvbXBsZXRlIGJvb2tpbmc6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcblxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IFJFQ0xBTUFUSU9OUyA9PT09PT09PT09PT09PT09PT09PVxuICByZWNsYW1hdGlvbnM6IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSByZWNsYW1hdGlvbiBmb3IgYSBib29raW5nXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKFxuICAgICAgYm9va2luZ0lkOiBzdHJpbmcgfCBudW1iZXIsXG4gICAgICB1c2VySWQ6IHN0cmluZyB8IG51bWJlcixcbiAgICAgIGNvbXBsYWluYW50Um9sZTogXCJHVUVTVFwiIHwgXCJIT1NUXCIsXG4gICAgICByZWNsYW1hdGlvblR5cGU6IHN0cmluZyxcbiAgICAgIHRpdGxlPzogc3RyaW5nLFxuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmcsXG4gICAgICBpbWFnZXM/OiBGaWxlW11cbiAgICApOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiLCBtZXNzYWdlOiBcIlJlY2xhbWF0aW9uIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5XCIgfVxuICAgICAgfVxuXG4gICAgICAvLyBVc2UgcmVjbGFtYXRpb24tc2VydmljZSBkaXJlY3RseSB0byBzdXBwb3J0IGltYWdlc1xuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgICAgZm9ybURhdGEuYXBwZW5kKFwiYm9va2luZ0lkXCIsIFN0cmluZyhib29raW5nSWQpKVxuICAgICAgZm9ybURhdGEuYXBwZW5kKFwidXNlcklkXCIsIFN0cmluZyh1c2VySWQpKVxuICAgICAgZm9ybURhdGEuYXBwZW5kKFwiY29tcGxhaW5hbnRSb2xlXCIsIGNvbXBsYWluYW50Um9sZSlcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcInJlY2xhbWF0aW9uVHlwZVwiLCByZWNsYW1hdGlvblR5cGUpXG4gICAgICBpZiAodGl0bGUpIGZvcm1EYXRhLmFwcGVuZChcInRpdGxlXCIsIHRpdGxlKVxuICAgICAgaWYgKGRlc2NyaXB0aW9uKSBmb3JtRGF0YS5hcHBlbmQoXCJkZXNjcmlwdGlvblwiLCBkZXNjcmlwdGlvbilcbiAgICAgIGlmIChpbWFnZXMgJiYgaW1hZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW1hZ2VzLmZvckVhY2goKGltYWdlKSA9PiB7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZXNcIiwgaW1hZ2UpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy9jcmVhdGVgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBjcmVhdGUgcmVjbGFtYXRpb246ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCByZWNsYW1hdGlvbnMgYnkgY29tcGxhaW5hbnQgSUQgKG15IGNvbXBsYWludHMpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TXlDb21wbGFpbnRzKHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvcmVjbGFtYXRpb25zL215LWNvbXBsYWludHM/dXNlcklkPSR7dXNlcklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBmZXRjaCBjb21wbGFpbnRzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcmVjbGFtYXRpb25zIGFnYWluc3QgYSB1c2VyIChjb21wbGFpbnRzIGFnYWluc3QgbWUpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29tcGxhaW50c0FnYWluc3RNZSh1c2VySWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy9hZ2FpbnN0LW1lP3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggY29tcGxhaW50czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYXR0YWNobWVudHMgKGltYWdlcykgZm9yIGEgcmVjbGFtYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWRBdHRhY2htZW50cyhyZWNsYW1hdGlvbklkOiBudW1iZXIsIGZpbGVzOiBGaWxlW10pOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlc1wiLCBmaWxlKVxuICAgICAgfSlcblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvcmVjbGFtYXRpb25zLyR7cmVjbGFtYXRpb25JZH0vYXR0YWNobWVudHNgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byB1cGxvYWQgYXR0YWNobWVudHM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJlY2xhbWF0aW9uIGJ5IGJvb2tpbmcgSUQgYW5kIGNvbXBsYWluYW50IElEXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QnlCb29raW5nSWRBbmRDb21wbGFpbmFudChcbiAgICAgIGJvb2tpbmdJZDogc3RyaW5nIHwgbnVtYmVyLFxuICAgICAgY29tcGxhaW5hbnRJZDogc3RyaW5nIHwgbnVtYmVyXG4gICAgKTogUHJvbWlzZTxhbnkgfCBudWxsPiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy9ib29raW5nLyR7Ym9va2luZ0lkfS9jb21wbGFpbmFudC8ke2NvbXBsYWluYW50SWR9YFxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICAvLyA0MDQgaXMgZXhwZWN0ZWQgd2hlbiBubyByZWNsYW1hdGlvbiBleGlzdHMgLSByZXR1cm4gbnVsbCBzaWxlbnRseVxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAvLyBTaWxlbnRseSBoYW5kbGUgNDA0IGVycm9ycyAobm8gcmVjbGFtYXRpb24gZXhpc3RzIC0gdGhpcyBpcyBub3JtYWwpXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcyhcIjQwNFwiKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcyhcIk5vdCBGb3VuZFwiKSkge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJlY2xhbWF0aW9uIGJ5IElEXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QnlJZChyZWNsYW1hdGlvbklkOiBudW1iZXIpOiBQcm9taXNlPGFueSB8IG51bGw+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvcmVjbGFtYXRpb25zLyR7cmVjbGFtYXRpb25JZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZWNsYW1hdGlvbiBhdHRhY2htZW50cyAoaW1hZ2VzKVxuICAgICAqL1xuICAgIGFzeW5jIGdldEF0dGFjaG1lbnRzKHJlY2xhbWF0aW9uSWQ6IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9L2F0dGFjaG1lbnRzYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGF0dGFjaG1lbnRzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHJlY2xhbWF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHJlY2xhbWF0aW9uSWQ6IHN0cmluZyB8IG51bWJlciwgdXNlcklkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9P3VzZXJJZD0ke3VzZXJJZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZGVsZXRlIHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSByZWNsYW1hdGlvbiAodGl0bGUsIGRlc2NyaXB0aW9uLCBpbWFnZXMpXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKFxuICAgICAgcmVjbGFtYXRpb25JZDogc3RyaW5nIHwgbnVtYmVyLFxuICAgICAgdXNlcklkOiBzdHJpbmcgfCBudW1iZXIsXG4gICAgICB0aXRsZT86IHN0cmluZyxcbiAgICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nLFxuICAgICAgaW1hZ2VzPzogRmlsZVtdXG4gICAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiwgbWVzc2FnZTogXCJSZWNsYW1hdGlvbiB1cGRhdGVkIHN1Y2Nlc3NmdWxseVwiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgICAgZm9ybURhdGEuYXBwZW5kKFwidXNlcklkXCIsIFN0cmluZyh1c2VySWQpKVxuICAgICAgaWYgKHRpdGxlKSBmb3JtRGF0YS5hcHBlbmQoXCJ0aXRsZVwiLCB0aXRsZSlcbiAgICAgIGlmIChkZXNjcmlwdGlvbikgZm9ybURhdGEuYXBwZW5kKFwiZGVzY3JpcHRpb25cIiwgZGVzY3JpcHRpb24pXG4gICAgICBpZiAoaW1hZ2VzICYmIGltYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGltYWdlcy5mb3JFYWNoKChpbWFnZSkgPT4ge1xuICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVzXCIsIGltYWdlKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9yZWNsYW1hdGlvbnMvJHtyZWNsYW1hdGlvbklkfWBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gdXBkYXRlIHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIHBob25lIG51bWJlclxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXJQaG9uZU51bWJlcih1c2VySWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9yZWNsYW1hdGlvbnMvdXNlci8ke3VzZXJJZH0vcGhvbmVgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggcGhvbmUgbnVtYmVyOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICByZXR1cm4gZGF0YS5waG9uZU51bWJlciB8fCBudWxsXG4gICAgfSxcbiAgfSxcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSBBRE1JTiBSRUNMQU1BVElPTlMgPT09PT09PT09PT09PT09PT09PT1cbiAgYWRtaW5SZWNsYW1hdGlvbnM6IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHJlY2xhbWF0aW9ucyAoYWRtaW4gb25seSlcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBbGwoKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvYWRtaW4vcmVjbGFtYXRpb25zYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHJlY2xhbWF0aW9uczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVjbGFtYXRpb25zIGJ5IHN0YXR1c1xuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5U3RhdHVzKHN0YXR1czogXCJPUEVOXCIgfCBcIklOX1JFVklFV1wiIHwgXCJSRVNPTFZFRFwiIHwgXCJSRUpFQ1RFRFwiKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvYWRtaW4vcmVjbGFtYXRpb25zL3N0YXR1cy8ke3N0YXR1c31gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggcmVjbGFtYXRpb25zOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZWNsYW1hdGlvbiBieSBJRFxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ5SWQocmVjbGFtYXRpb25JZDogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvcmVjbGFtYXRpb25zLyR7cmVjbGFtYXRpb25JZH1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSByZWNsYW1hdGlvbiBzZXZlcml0eVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVNldmVyaXR5KHJlY2xhbWF0aW9uSWQ6IG51bWJlciwgc2V2ZXJpdHk6IFwiTE9XXCIgfCBcIk1FRElVTVwiIHwgXCJISUdIXCIgfCBcIkNSSVRJQ0FMXCIpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvYWRtaW4vcmVjbGFtYXRpb25zLyR7cmVjbGFtYXRpb25JZH0vc2V2ZXJpdHk/c2V2ZXJpdHk9JHtzZXZlcml0eX1gXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gdXBkYXRlIHNldmVyaXR5OiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldmlldyByZWNsYW1hdGlvbiAobW92ZSB0byBJTl9SRVZJRVcpXG4gICAgICovXG4gICAgYXN5bmMgcmV2aWV3KHJlY2xhbWF0aW9uSWQ6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJzdWNjZXNzXCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9hZG1pbi9yZWNsYW1hdGlvbnMvJHtyZWNsYW1hdGlvbklkfS9yZXZpZXdgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gcmV2aWV3IHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgcmVjbGFtYXRpb24gd2l0aCBwZW5hbHR5XG4gICAgICovXG4gICAgYXN5bmMgcmVzb2x2ZShyZWNsYW1hdGlvbklkOiBudW1iZXIsIHJlc29sdXRpb25Ob3Rlczogc3RyaW5nLCBhcHByb3ZlZDogYm9vbGVhbik6IFByb21pc2U8YW55PiB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJzdWNjZXNzXCIgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cmwgPSBgJHtSRUNMQU1BVElPTl9BUElfQkFTRV9VUkx9L2FwaS9hZG1pbi9yZWNsYW1hdGlvbnMvJHtyZWNsYW1hdGlvbklkfS9yZXNvbHZlYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmdldEF1dGhIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICByZXNvbHV0aW9uTm90ZXMsXG4gICAgICAgICAgYXBwcm92ZWQsXG4gICAgICAgIH0pLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gcmVzb2x2ZSByZWNsYW1hdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWplY3QgcmVjbGFtYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyByZWplY3QocmVjbGFtYXRpb25JZDogbnVtYmVyLCByZWplY3Rpb25Ob3Rlczogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL2FkbWluL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9L3JlamVjdGBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcmVqZWN0aW9uTm90ZXMsXG4gICAgICAgIH0pLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gcmVqZWN0IHJlY2xhbWF0aW9uOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZWNsYW1hdGlvbiBhdHRhY2htZW50cyAoaW1hZ2VzKVxuICAgICAqL1xuICAgIGFzeW5jIGdldEF0dGFjaG1lbnRzKHJlY2xhbWF0aW9uSWQ6IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHtcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVybCA9IGAke1JFQ0xBTUFUSU9OX0FQSV9CQVNFX1VSTH0vYXBpL2FkbWluL3JlY2xhbWF0aW9ucy8ke3JlY2xhbWF0aW9uSWR9L2F0dGFjaG1lbnRzYFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uZ2V0QXV0aEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGZldGNoIGF0dGFjaG1lbnRzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZWNsYW1hdGlvbiBzdGF0aXN0aWNzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3RhdGlzdGljcygpOiBQcm9taXNlPGFueT4ge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvdGFsOiAwLFxuICAgICAgICAgIG9wZW46IDAsXG4gICAgICAgICAgaW5SZXZpZXc6IDAsXG4gICAgICAgICAgcmVzb2x2ZWQ6IDAsXG4gICAgICAgICAgcmVqZWN0ZWQ6IDAsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gYCR7UkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMfS9hcGkvYWRtaW4vcmVjbGFtYXRpb25zL3N0YXRpc3RpY3NgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5nZXRBdXRoSGVhZGVycygpLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gZmV0Y2ggc3RhdGlzdGljczogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKVxuICAgIH0sXG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gVEVOQU5UIFJJU0sgPT09PT09PT09PT09PT09PT09PT1cbiAgcmlzazoge1xuICAgIGFzeW5jIGdldFRlbmFudFJpc2tTY29yZSh0ZW5hbnRJZDogbnVtYmVyKSB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSByZXR1cm4geyB0ZW5hbnRfaWQ6IHRlbmFudElkLCB0cnVzdF9zY29yZTogMTAwLCByaXNrX2JhbmQ6IFwiTE9XXCIgfTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS90ZW5hbnQtcmlzay8ke3RlbmFudElkfWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIiwgLy8gVGhlIE1MIHNlcnZpY2UgZXhwZWN0cyBQT1NUXG4gICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHJpc2sgc2NvcmUgZm9yICR7dGVuYW50SWR9YCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgfSxcblxuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gTUFSS0VUIFRSRU5EUyA9PT09PT09PT09PT09PT09PT09PVxuICBtYXJrZXRUcmVuZHM6IHtcbiAgICBhc3luYyBnZXRBbGxDaXRpZXMocGVyaW9kTW9udGhzOiBudW1iZXIgPSAxMikge1xuICAgICAgaWYgKFVTRV9NT0NLX0FQSSkgcmV0dXJuIHsgdHJlbmRzOiBbXSwgaW5zaWdodHM6IFtdIH07XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL21hcmtldC10cmVuZHMvYWxsLWNpdGllcz9wZXJpb2RfbW9udGhzPSR7cGVyaW9kTW9udGhzfWApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIG1hcmtldCB0cmVuZHNcIik7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0sXG4gICAgYXN5bmMgZ2V0Q2l0eVRyZW5kcyhjaXR5OiBzdHJpbmcsIHBlcmlvZE1vbnRoczogbnVtYmVyID0gMTIpIHtcbiAgICAgIGlmIChVU0VfTU9DS19BUEkpIHJldHVybiB7IGRhdGFfcG9pbnRzOiBbXSB9O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9tYXJrZXQtdHJlbmRzL2NpdHkvJHtjaXR5fT9wZXJpb2RfbW9udGhzPSR7cGVyaW9kTW9udGhzfWApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggdHJlbmRzIGZvciAke2NpdHl9YCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0sXG4gICAgYXN5bmMgZ2V0SW5zaWdodHMoY2l0eTogc3RyaW5nKSB7XG4gICAgICBpZiAoVVNFX01PQ0tfQVBJKSByZXR1cm4gW107XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL21hcmtldC10cmVuZHMvaW5zaWdodHMvJHtjaXR5fWApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggaW5zaWdodHMgZm9yICR7Y2l0eX1gKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgY29uc3QgYXBpQmFzZVVybCA9IEFQSV9CQVNFX1VSTFxuZXhwb3J0IGNvbnN0IGFwaVZlcnNpb24gPSBBUElfVkVSU0lPTlxuIl0sIm5hbWVzIjpbIkdBVEVXQVlfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0dBVEVXQVlfVVJMIiwiVVNFX0dBVEVXQVkiLCJORVhUX1BVQkxJQ19VU0VfR0FURVdBWSIsIkFQSV9CQVNFX1VSTCIsIk5FWFRfUFVCTElDX0FQSV9CQVNFX1VSTCIsIlBST1BFUlRZX0FQSV9CQVNFX1VSTCIsIk5FWFRfUFVCTElDX1BST1BFUlRZX0FQSV9CQVNFX1VSTCIsIkJPT0tJTkdfQVBJX0JBU0VfVVJMIiwiTkVYVF9QVUJMSUNfQk9PS0lOR19BUElfQkFTRV9VUkwiLCJQQVlNRU5UX0FQSV9CQVNFX1VSTCIsIk5FWFRfUFVCTElDX1BBWU1FTlRfQVBJX0JBU0VfVVJMIiwiUkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMIiwiTkVYVF9QVUJMSUNfUkVDTEFNQVRJT05fQVBJX0JBU0VfVVJMIiwiQVBJX1ZFUlNJT04iLCJORVhUX1BVQkxJQ19BUElfVkVSU0lPTiIsIkFVVEhfVE9LRU5fS0VZIiwiTkVYVF9QVUJMSUNfQVVUSF9TVE9SQUdFX0tFWSIsIlVTRVJfREFUQV9LRVkiLCJORVhUX1BVQkxJQ19VU0VSX1NUT1JBR0VfS0VZIiwiVVNFX01PQ0tfQVBJIiwibW9ja0FwaUNsaWVudCIsImdldE1vY2tBcGkiLCJFcnJvciIsImRlY29kZUpXVCIsInRva2VuIiwicGFydHMiLCJzcGxpdCIsImxlbmd0aCIsInBheWxvYWQiLCJkZWNvZGVkIiwiSlNPTiIsInBhcnNlIiwiYXRvYiIsInJlcGxhY2UiLCJ1c2VySWQiLCJzdWIiLCJzdWJqZWN0Iiwicm9sZXMiLCJlcnJvciIsImdldEF1dGhIZWFkZXJzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInVzZXJEYXRhIiwiZmluYWxVc2VySWQiLCJ1c2VyIiwiaWQiLCJ1c2VySWRTdHJpbmciLCJTdHJpbmciLCJoZWFkZXJzIiwiam9pbiIsIkF1dGhvcml6YXRpb24iLCJnZXRTZXJ2aWNlVXJsIiwic2VydmljZSIsImJ1aWxkVXJsIiwicGF0aCIsImJhc2VVcmwiLCJzdGFydHNXaXRoIiwiYmFzZVBhdGgiLCJyZXF1ZXN0Iiwib3B0aW9ucyIsInJlcXVpcmVzQXV0aCIsImZldGNoT3B0aW9ucyIsInVybCIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsImVycm9yRGF0YSIsInJlc3BvbnNlVGV4dCIsInRleHQiLCJwYXJzZUVycm9yIiwibWVzc2FnZSIsInJhdyIsInRleHRFcnJvciIsIk9iamVjdCIsImtleXMiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZXJyb3JNZXNzYWdlIiwiZGV0YWlsIiwiQXJyYXkiLCJpc0FycmF5IiwiZXJyb3JzIiwiYXBpRXJyb3IiLCJjb250ZW50VHlwZSIsImdldCIsImluY2x1ZGVzIiwiZGF0YSIsImpzb24iLCJjb25uZWN0aW9uRXJyb3IiLCJpc0Nvbm5lY3Rpb25FcnJvciIsInJlcXVlc3RGb3JtRGF0YSIsImZvcm1EYXRhIiwibWV0aG9kIiwiYm9keSIsImNhdGNoIiwiYXBpQ2xpZW50IiwicHJvcGVydGllcyIsImdldEFsbCIsIm1vY2siLCJnZXRBbGxGb3JBZG1pbiIsImF1dGhIZWFkZXJzIiwiZ2V0QnlJZCIsImdldE15UHJvcGVydGllcyIsImNyZWF0ZSIsImltYWdlcyIsInJlc3VsdCIsInByb3BlcnR5SWQiLCJGb3JtRGF0YSIsImlucHV0QmxvYiIsIkJsb2IiLCJzdHJpbmdpZnkiLCJ0eXBlIiwiYXBwZW5kIiwiZm9yRWFjaCIsImZpbGUiLCJ1cGRhdGUiLCJwYXJzZWQiLCJzdWNjZXNzIiwiZGVsZXRlIiwiYXBwcm92ZSIsImlzQXBwcm92ZWQiLCJoaWRlIiwiaXNIaWRkZW4iLCJzdXNwZW5kIiwicmVhc29uIiwicmV2b2tlU3VzcGVuc2lvbiIsInN1Ym1pdEZvckFwcHJvdmFsIiwiY2FuY2VsQXBwcm92YWxSZXF1ZXN0IiwicHJlZGljdFByaWNlIiwiY2hlY2tJbkRhdGUiLCJjaGVja091dERhdGUiLCJwcmVkaWN0ZWRQcmljZU1hZCIsInByZWRpY3RlZFByaWNlVXNkIiwiY29uZmlkZW5jZUludGVydmFsTG93ZXIiLCJjb25maWRlbmNlSW50ZXJ2YWxVcHBlciIsImNpdHkiLCJzZWFzb24iLCJtb2RlbFZlcnNpb24iLCJwcmVkaWN0aW9uVGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY3VycmVudFByaWNlTWFkIiwicHJpY2VEaWZmZXJlbmNlUGVyY2VudCIsInJlY29tbWVuZGF0aW9uIiwicmlzayIsImdldFRlbmFudFJpc2tTY29yZSIsInRlbmFudElkIiwiY29uc29sZSIsInJlY29tbWVuZGF0aW9ucyIsImdldEZvclRlbmFudCIsIm1heFJlc3VsdHMiLCJnZXRTaW1pbGFyIiwidmVyaWZpY2F0aW9uUmVxdWVzdHMiLCJnZXRCeVN0YXR1cyIsImRlc2NyaXB0aW9uIiwicmVqZWN0IiwicHJvcGVydHlUeXBlcyIsInVzZXJzIiwiZ2V0TWUiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImVtYWlsIiwicGhvbmVOdW1iZXIiLCJzY29yZSIsImFsbFVzZXJzIiwiZmluZCIsInUiLCJwcm9maWxlUGljdHVyZSIsImJpcnRoZGF5Iiwid2FsbGV0QWRkcmVzcyIsImVuYWJsZWQiLCJlcnIiLCJ1cGRhdGVNZSIsIlByb21pc2UiLCJyZXNvbHZlIiwidXBkYXRlUHJvZmlsZVBpY3R1cmUiLCJjaGFuZ2VQYXNzd29yZCIsImN1cnJlbnRQYXNzd29yZCIsIm5ld1Bhc3N3b3JkIiwiZGVsZXRlUHJvZmlsZVBpY3R1cmUiLCJiZWNvbWVIb3N0IiwiZW5hYmxlVXNlciIsImRpc2FibGVVc2VyIiwiYWRkQWRtaW5Sb2xlIiwicmVtb3ZlQWRtaW5Sb2xlIiwiYWRkSG9zdFJvbGVCeUFkbWluIiwicmVtb3ZlSG9zdFJvbGUiLCJhdXRoIiwicmVnaXN0ZXIiLCJzZXRUaW1lb3V0IiwicmVxdWVzdEJvZHkiLCJwYXNzd29yZCIsInJvbGUiLCJsb2dpbiIsInNldEF1dGgiLCJzZXRJdGVtIiwiZ2V0VG9rZW4iLCJnZXRVc2VyIiwiY2xlYXJBdXRoIiwicmVtb3ZlSXRlbSIsImhhc1JvbGUiLCJ2ZXJpZnkiLCJ2ZXJpZmljYXRpb25Db2RlIiwicmVzZW5kVmVyaWZpY2F0aW9uQ29kZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImZvcmdvdFBhc3N3b3JkIiwidmVyaWZ5UmVzZXRUb2tlbiIsInZhbGlkIiwicmVzZXRQYXNzd29yZCIsInZlcmlmeVJlc2V0Q29kZSIsImNvZGUiLCJyZXNldFBhc3N3b3JkV2l0aENvZGUiLCJib29raW5ncyIsInBhcnNlSW50IiwibnVtYmVyT2ZHdWVzdHMiLCJyZXF1ZXN0ZWRQcmljZSIsInJlc3BvbnNlRGF0YSIsImdldEJ5VGVuYW50SWQiLCJnZXRDdXJyZW50Qm9va2luZyIsImdldFBlbmRpbmdCb29raW5ncyIsImdldEF3YWl0aW5nUGF5bWVudEJvb2tpbmdzIiwiZ2V0UHJvcGVydHlJbmZvIiwib3duZXJJZCIsInByaWNlUGVyTmlnaHQiLCJpc05lZ290aWFibGUiLCJkaXNjb3VudEVuYWJsZWQiLCJnZXRMYXN0Qm9va2luZ0lkIiwiYm9va2luZ0lkIiwiZXJyb3JDb2RlIiwidGVuYW50Q2hlY2tvdXQiLCJvd25lckNvbmZpcm1DaGVja291dCIsIm1hcmtBc0NoZWNrZWRPdXQiLCJnZXRDdXJyZW50Qm9va2luZ3NCeU93bmVyIiwiZ2V0UGVuZGluZ05lZ290aWF0aW9ucyIsImFjY2VwdE5lZ290aWF0aW9uIiwicmVqZWN0TmVnb3RpYXRpb24iLCJnZXRCeU93bmVySWQiLCJnZXRDb25maXJtZWRCb29raW5nc0J5T3duZXIiLCJnZXRDb25maXJtZWRCb29raW5nc0J5UHJvcGVydHkiLCJyZXBvcnREaXNwdXRlIiwicGF5bWVudHMiLCJjcmVhdGVJbnRlbnQiLCJyZWZlcmVuY2VJZCIsInRvIiwidmFsdWUiLCJjaGFpbklkIiwidG90YWxBbW91bnRXZWkiLCJnZXRCb29raW5nRGV0YWlscyIsInRvdGFsUHJpY2UiLCJwcm9wZXJ0eVRpdGxlIiwicHJvcGVydHlQcmljZSIsIm93bmVyV2FsbGV0QWRkcmVzcyIsImN1cnJlbnRVc2VySWQiLCJ1c2VyRmlyc3ROYW1lIiwidXNlckxhc3ROYW1lIiwidXNlckVtYWlsIiwidXNlcldhbGxldEFkZHJlc3MiLCJlIiwidXBkYXRlV2FsbGV0QWRkcmVzcyIsInVwZGF0ZVRyYW5zYWN0aW9uSGFzaCIsInR4SGFzaCIsImdldFRyYW5zYWN0aW9uU3RhdHVzIiwiYmxvY2tOdW1iZXIiLCJjb21wbGV0ZUJvb2tpbmciLCJlcnJvclRleHQiLCJyZWNsYW1hdGlvbnMiLCJjb21wbGFpbmFudFJvbGUiLCJyZWNsYW1hdGlvblR5cGUiLCJ0aXRsZSIsImltYWdlIiwiZ2V0TXlDb21wbGFpbnRzIiwiZ2V0Q29tcGxhaW50c0FnYWluc3RNZSIsInVwbG9hZEF0dGFjaG1lbnRzIiwicmVjbGFtYXRpb25JZCIsImZpbGVzIiwiZ2V0QnlCb29raW5nSWRBbmRDb21wbGFpbmFudCIsImNvbXBsYWluYW50SWQiLCJnZXRBdHRhY2htZW50cyIsImdldFVzZXJQaG9uZU51bWJlciIsImFkbWluUmVjbGFtYXRpb25zIiwidXBkYXRlU2V2ZXJpdHkiLCJzZXZlcml0eSIsInJldmlldyIsInJlc29sdXRpb25Ob3RlcyIsImFwcHJvdmVkIiwicmVqZWN0aW9uTm90ZXMiLCJnZXRTdGF0aXN0aWNzIiwidG90YWwiLCJvcGVuIiwiaW5SZXZpZXciLCJyZXNvbHZlZCIsInJlamVjdGVkIiwidGVuYW50X2lkIiwidHJ1c3Rfc2NvcmUiLCJyaXNrX2JhbmQiLCJtYXJrZXRUcmVuZHMiLCJnZXRBbGxDaXRpZXMiLCJwZXJpb2RNb250aHMiLCJ0cmVuZHMiLCJpbnNpZ2h0cyIsImdldENpdHlUcmVuZHMiLCJkYXRhX3BvaW50cyIsImdldEluc2lnaHRzIiwiYXBpQmFzZVVybCIsImFwaVZlcnNpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/services/api.ts\n"));

/***/ })

});